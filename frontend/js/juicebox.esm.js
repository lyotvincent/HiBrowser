function div$1(options) {
  return create$1("div", options);
}

function create$1(tag, options) {
  const elem = document.createElement(tag);
  if (options) {
    if (options.class) {
      elem.classList.add(options.class);
    }
    if (options.id) {
      elem.id = options.id;
    }
    if (options.style) {
      applyStyle$1(elem, options.style);
    }
  }
  return elem;
}

function hide$1(elem) {
  const cssStyle = getComputedStyle(elem);
  if (cssStyle.display !== "none") {
    elem._initialDisplay = cssStyle.display;
  }
  elem.style.display = "none";
}

function offset$1(elem) {
  // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
  // Support: IE <=11 only
  // Running getBoundingClientRect on a
  // disconnected node in IE throws an error
  if (!elem.getClientRects().length) {
    return { top: 0, left: 0 };
  }

  // Get document-relative position by adding viewport scroll to viewport-relative gBCR
  const rect = elem.getBoundingClientRect();
  const win = elem.ownerDocument.defaultView;
  return {
    top: rect.top + win.pageYOffset,
    left: rect.left + win.pageXOffset
  };
}

function applyStyle$1(elem, style) {
  for (let key of Object.keys(style)) {
    elem.style[key] = style[key];
  }
}

function guid() {
  return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
}

let getMouseXY = (domElement, { clientX, clientY }) => {

  // DOMRect object with eight properties: left, top, right, bottom, x, y, width, height
  const { left, top, width, height } = domElement.getBoundingClientRect();

  const x = clientX - left;
  const y = clientY - top;
  return { x, y, xNormalized: x / width, yNormalized: y / height, width, height };

};

/**
* Translate the mouse coordinates for the event to the coordinates for the given target element
* @param event
* @param domElement
* @returns {{x: number, y: number}}
*/
function translateMouseCoordinates(event, domElement) {

  const { clientX, clientY } = event;
  return getMouseXY(domElement, { clientX, clientY });

}

function createCheckbox$1(name, initialState) {
  const container = div$1({ class: 'igv-ui-trackgear-popover-check-container' });
  const svg = iconMarkup$2('check', (true === initialState ? '#444' : 'transparent'));
  svg.style.borderColor = 'gray';
  svg.style.borderWidth = '1px';
  svg.style.borderStyle = 'solid';

  container.appendChild(svg);
  let label = div$1(); //{ class: 'igv-some-label-class' });
  label.textContent = name;
  container.appendChild(label);

  return container;
}

function createIcon$2(name, color) {
  return iconMarkup$2(name, color);
}

function iconMarkup$2(name, color) {
  color = color || "currentColor";
  let icon = icons$2[name];
  if (!icon) {
    console.error(`No icon named: ${name}`);
    icon = icons$2["question"];
  }

  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttributeNS(null, 'viewBox', '0 0 ' + icon[0] + ' ' + icon[1]);
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttributeNS(null, 'fill', color);
  path.setAttributeNS(null, 'd', icon[4]);
  svg.appendChild(path);
  return svg;
}

const icons$2 = {
  "check": [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"],
  "cog": [512, 512, [], "f013", "M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z"],
  "exclamation": [192, 512, [], "f12a", "M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z"],
  "exclamation-circle": [512, 512, [], "f06a", "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
  "exclamation-triangle": [576, 512, [], "f071", "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
  "minus": [448, 512, [], "f068", "M424 318.2c13.3 0 24-10.7 24-24v-76.4c0-13.3-10.7-24-24-24H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h400z"],
  "minus-circle": [512, 512, [], "f056", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z"],
  "minus-square": [448, 512, [], "f146", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM92 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H92z"],
  "plus": [448, 512, [], "f067", "M448 294.2v-76.4c0-13.3-10.7-24-24-24H286.2V56c0-13.3-10.7-24-24-24h-76.4c-13.3 0-24 10.7-24 24v137.8H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h137.8V456c0 13.3 10.7 24 24 24h76.4c13.3 0 24-10.7 24-24V318.2H424c13.3 0 24-10.7 24-24z"],
  "plus-circle": [512, 512, [], "f055", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
  "plus-square": [448, 512, [], "f0fe", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-32 252c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92H92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
  "question": [384, 512, [], "f128", "M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"],
  "save": [448, 512, [], "f0c7", "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"],
  "search": [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"],
  "share": [512, 512, [], "f064", "M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z"],
  "spinner": [512, 512, [], "f110", "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"],
  "square": [448, 512, [], "f0c8", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z"],
  "square-full": [512, 512, [], "f45c", "M512 512H0V0h512v512z"],
  "times": [384, 512, [], "f00d", "M323.1 441l53.9-53.9c9.4-9.4 9.4-24.5 0-33.9L279.8 256l97.2-97.2c9.4-9.4 9.4-24.5 0-33.9L323.1 71c-9.4-9.4-24.5-9.4-33.9 0L192 168.2 94.8 71c-9.4-9.4-24.5-9.4-33.9 0L7 124.9c-9.4 9.4-9.4 24.5 0 33.9l97.2 97.2L7 353.2c-9.4 9.4-9.4 24.5 0 33.9L60.9 441c9.4 9.4 24.5 9.4 33.9 0l97.2-97.2 97.2 97.2c9.3 9.3 24.5 9.3 33.9 0z"],
  "times-circle": [512, 512, [], "f057", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"],
  "wrench": [512, 512, [], "f0ad", "M481.156 200c9.3 0 15.12 10.155 10.325 18.124C466.295 259.992 420.419 288 368 288c-79.222 0-143.501-63.974-143.997-143.079C223.505 65.469 288.548-.001 368.002 0c52.362.001 98.196 27.949 123.4 69.743C496.24 77.766 490.523 88 481.154 88H376l-40 56 40 56h105.156zm-171.649 93.003L109.255 493.255c-24.994 24.993-65.515 24.994-90.51 0-24.993-24.994-24.993-65.516 0-90.51L218.991 202.5c16.16 41.197 49.303 74.335 90.516 90.503zM104 432c0-13.255-10.745-24-24-24s-24 10.745-24 24 10.745 24 24 24 24-10.745 24-24z"],
};

function attachDialogCloseHandlerWithParent$1(parent, closeHandler) {

  var container = document.createElement("div");
  parent.appendChild(container);
  container.appendChild(createIcon$2("times"));
  container.addEventListener('click', function (e) {
    e.preventDefault;
    e.stopPropagation();
    closeHandler();
  });
}

/**
* @fileoverview Zlib namespace. Zlib の仕様に準拠した圧縮は Zlib.Deflate で実装
* されている. これは Inflate との共存を考慮している為.
*/
const ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE$2 = 65000;

var Zlib$2 = {
  Huffman: {},
  Util: {},
  CRC32: {}
};


/**
* Compression Method
* @enum {number}
*/
Zlib$2.CompressionMethod = {
  DEFLATE: 8,
  RESERVED: 15
};




/**
* @param {Object=} opt_params options.
* @constructor
*/
Zlib$2.Zip = function (opt_params) {
  opt_params = opt_params || {};
  /** @type {Array.<{
   *   buffer: !(Array.<number>|Uint8Array),
   *   option: Object,
   *   compressed: boolean,
   *   encrypted: boolean,
   *   size: number,
   *   crc32: number
   * }>} */
  this.files = [];
  /** @type {(Array.<number>|Uint8Array)} */
  this.comment = opt_params['comment'];
  /** @type {(Array.<number>|Uint8Array)} */
  this.password;
};


/**
* @enum {number}
*/
Zlib$2.Zip.CompressionMethod = {
  STORE: 0,
  DEFLATE: 8
};

/**
* @enum {number}
*/
Zlib$2.Zip.OperatingSystem = {
  MSDOS: 0,
  UNIX: 3,
  MACINTOSH: 7
};

/**
* @enum {number}
*/
Zlib$2.Zip.Flags = {
  ENCRYPT: 0x0001,
  DESCRIPTOR: 0x0008,
  UTF8: 0x0800
};

/**
* @type {Array.<number>}
* @const
*/
Zlib$2.Zip.FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];

/**
* @type {Array.<number>}
* @const
*/
Zlib$2.Zip.LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];

/**
* @type {Array.<number>}
* @const
*/
Zlib$2.Zip.CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];

/**
* @param {Array.<number>|Uint8Array} input
* @param {Object=} opt_params options.
*/
Zlib$2.Zip.prototype.addFile = function (input, opt_params) {
  opt_params = opt_params || {};
  /** @type {string} */
  opt_params['filename'];
  /** @type {boolean} */
  var compressed;
  /** @type {number} */
  var size = input.length;
  /** @type {number} */
  var crc32 = 0;

  if (input instanceof Array) {
    input = new Uint8Array(input);
  }

  // default
  if (typeof opt_params['compressionMethod'] !== 'number') {
    opt_params['compressionMethod'] = Zlib$2.Zip.CompressionMethod.DEFLATE;
  }

  // その場で圧縮する場合
  if (opt_params['compress']) {
    switch (opt_params['compressionMethod']) {
      case Zlib$2.Zip.CompressionMethod.STORE:
        break;
      case Zlib$2.Zip.CompressionMethod.DEFLATE:
        crc32 = Zlib$2.CRC32.calc(input);
        input = this.deflateWithOption(input, opt_params);
        compressed = true;
        break;
      default:
        throw new Error('unknown compression method:' + opt_params['compressionMethod']);
    }
  }

  this.files.push({
    buffer: input,
    option: opt_params,
    compressed: compressed,
    encrypted: false,
    size: size,
    crc32: crc32
  });
};

/**
* @param {(Array.<number>|Uint8Array)} password
*/
Zlib$2.Zip.prototype.setPassword = function (password) {
  this.password = password;
};

Zlib$2.Zip.prototype.compress = function () {
  /** @type {Array.<{
   *   buffer: !(Array.<number>|Uint8Array),
   *   option: Object,
   *   compressed: boolean,
   *   encrypted: boolean,
   *   size: number,
   *   crc32: number
   * }>} */
  var files = this.files;
  /** @type {{
   *   buffer: !(Array.<number>|Uint8Array),
   *   option: Object,
   *   compressed: boolean,
   *   encrypted: boolean,
   *   size: number,
   *   crc32: number
   * }} */
  var file;
  /** @type {!(Array.<number>|Uint8Array)} */
  var output;
  /** @type {number} */
  var op1;
  /** @type {number} */
  var op2;
  /** @type {number} */
  var op3;
  /** @type {number} */
  var localFileSize = 0;
  /** @type {number} */
  var centralDirectorySize = 0;
  /** @type {number} */
  var endOfCentralDirectorySize;
  /** @type {number} */
  var offset;
  /** @type {number} */
  var needVersion;
  /** @type {number} */
  var flags;
  /** @type {Zlib.Zip.CompressionMethod} */
  var compressionMethod;
  /** @type {Date} */
  var date;
  /** @type {number} */
  var crc32;
  /** @type {number} */
  var size;
  /** @type {number} */
  var plainSize;
  /** @type {number} */
  var filenameLength;
  /** @type {number} */
  var extraFieldLength;
  /** @type {number} */
  var commentLength;
  /** @type {(Array.<number>|Uint8Array)} */
  var filename;
  /** @type {(Array.<number>|Uint8Array)} */
  var extraField;
  /** @type {(Array.<number>|Uint8Array)} */
  var comment;
  /** @type {(Array.<number>|Uint8Array)} */
  var buffer;
  /** @type {*} */
  var tmp;
  /** @type {Array.<number>|Uint32Array|Object} */
  var key;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;
  /** @type {number} */
  var j;
  /** @type {number} */
  var jl;

  // ファイルの圧縮
  for (i = 0, il = files.length; i < il; ++i) {
    file = files[i];
    filenameLength =
      (file.option['filename']) ? file.option['filename'].length : 0;
    extraFieldLength =
      (file.option['extraField']) ? file.option['extraField'].length : 0;
    commentLength =
      (file.option['comment']) ? file.option['comment'].length : 0;

    // 圧縮されていなかったら圧縮
    if (!file.compressed) {
      // 圧縮前に CRC32 の計算をしておく
      file.crc32 = Zlib$2.CRC32.calc(file.buffer);

      switch (file.option['compressionMethod']) {
        case Zlib$2.Zip.CompressionMethod.STORE:
          break;
        case Zlib$2.Zip.CompressionMethod.DEFLATE:
          file.buffer = this.deflateWithOption(file.buffer, file.option);
          file.compressed = true;
          break;
        default:
          throw new Error('unknown compression method:' + file.option['compressionMethod']);
      }
    }

    // encryption
    if (file.option['password'] !== void 0 || this.password !== void 0) {
      // init encryption
      key = this.createEncryptionKey(file.option['password'] || this.password);

      // add header
      buffer = file.buffer;
      {
        tmp = new Uint8Array(buffer.length + 12);
        tmp.set(buffer, 12);
        buffer = tmp;
      }

      for (j = 0; j < 12; ++j) {
        buffer[j] = this.encode(
          key,
          i === 11 ? (file.crc32 & 0xff) : (Math.random() * 256 | 0)
        );
      }

      // data encryption
      for (jl = buffer.length; j < jl; ++j) {
        buffer[j] = this.encode(key, buffer[j]);
      }
      file.buffer = buffer;
    }

    // 必要バッファサイズの計算
    localFileSize +=
      // local file header
      30 + filenameLength +
      // file data
      file.buffer.length;

    centralDirectorySize +=
      // file header
      46 + filenameLength + commentLength;
  }

  // end of central directory
  endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);
  output = new (Uint8Array)(
    localFileSize + centralDirectorySize + endOfCentralDirectorySize
  );
  op1 = 0;
  op2 = localFileSize;
  op3 = op2 + centralDirectorySize;

  // ファイルの圧縮
  for (i = 0, il = files.length; i < il; ++i) {
    file = files[i];
    filenameLength =
      file.option['filename'] ? file.option['filename'].length : 0;
    extraFieldLength = 0; // TODO
    commentLength =
      file.option['comment'] ? file.option['comment'].length : 0;

    //-------------------------------------------------------------------------
    // local file header & file header
    //-------------------------------------------------------------------------

    offset = op1;

    // signature
    // local file header
    output[op1++] = Zlib$2.Zip.LocalFileHeaderSignature[0];
    output[op1++] = Zlib$2.Zip.LocalFileHeaderSignature[1];
    output[op1++] = Zlib$2.Zip.LocalFileHeaderSignature[2];
    output[op1++] = Zlib$2.Zip.LocalFileHeaderSignature[3];
    // file header
    output[op2++] = Zlib$2.Zip.FileHeaderSignature[0];
    output[op2++] = Zlib$2.Zip.FileHeaderSignature[1];
    output[op2++] = Zlib$2.Zip.FileHeaderSignature[2];
    output[op2++] = Zlib$2.Zip.FileHeaderSignature[3];

    // compressor info
    needVersion = 20;
    output[op2++] = needVersion & 0xff;
    output[op2++] =
      /** @type {Zlib.Zip.OperatingSystem} */
      (file.option['os']) ||
      Zlib$2.Zip.OperatingSystem.MSDOS;

    // need version
    output[op1++] = output[op2++] = needVersion & 0xff;
    output[op1++] = output[op2++] = (needVersion >> 8) & 0xff;

    // general purpose bit flag
    flags = 0;
    if (file.option['password'] || this.password) {
      flags |= Zlib$2.Zip.Flags.ENCRYPT;
    }
    output[op1++] = output[op2++] = flags & 0xff;
    output[op1++] = output[op2++] = (flags >> 8) & 0xff;

    // compression method
    compressionMethod =
      /** @type {Zlib.Zip.CompressionMethod} */
      (file.option['compressionMethod']);
    output[op1++] = output[op2++] = compressionMethod & 0xff;
    output[op1++] = output[op2++] = (compressionMethod >> 8) & 0xff;

    // date
    date = /** @type {(Date|undefined)} */(file.option['date']) || new Date();
    output[op1++] = output[op2++] =
      ((date.getMinutes() & 0x7) << 5) |
      (date.getSeconds() / 2 | 0);
    output[op1++] = output[op2++] =
      (date.getHours() << 3) |
      (date.getMinutes() >> 3);
    //
    output[op1++] = output[op2++] =
      ((date.getMonth() + 1 & 0x7) << 5) |
      (date.getDate());
    output[op1++] = output[op2++] =
      ((date.getFullYear() - 1980 & 0x7f) << 1) |
      (date.getMonth() + 1 >> 3);

    // CRC-32
    crc32 = file.crc32;
    output[op1++] = output[op2++] = crc32 & 0xff;
    output[op1++] = output[op2++] = (crc32 >> 8) & 0xff;
    output[op1++] = output[op2++] = (crc32 >> 16) & 0xff;
    output[op1++] = output[op2++] = (crc32 >> 24) & 0xff;

    // compressed size
    size = file.buffer.length;
    output[op1++] = output[op2++] = size & 0xff;
    output[op1++] = output[op2++] = (size >> 8) & 0xff;
    output[op1++] = output[op2++] = (size >> 16) & 0xff;
    output[op1++] = output[op2++] = (size >> 24) & 0xff;

    // uncompressed size
    plainSize = file.size;
    output[op1++] = output[op2++] = plainSize & 0xff;
    output[op1++] = output[op2++] = (plainSize >> 8) & 0xff;
    output[op1++] = output[op2++] = (plainSize >> 16) & 0xff;
    output[op1++] = output[op2++] = (plainSize >> 24) & 0xff;

    // filename length
    output[op1++] = output[op2++] = filenameLength & 0xff;
    output[op1++] = output[op2++] = (filenameLength >> 8) & 0xff;

    // extra field length
    output[op1++] = output[op2++] = extraFieldLength & 0xff;
    output[op1++] = output[op2++] = (extraFieldLength >> 8) & 0xff;

    // file comment length
    output[op2++] = commentLength & 0xff;
    output[op2++] = (commentLength >> 8) & 0xff;

    // disk number start
    output[op2++] = 0;
    output[op2++] = 0;

    // internal file attributes
    output[op2++] = 0;
    output[op2++] = 0;

    // external file attributes
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;

    // relative offset of local header
    output[op2++] = offset & 0xff;
    output[op2++] = (offset >> 8) & 0xff;
    output[op2++] = (offset >> 16) & 0xff;
    output[op2++] = (offset >> 24) & 0xff;

    // filename
    filename = file.option['filename'];
    if (filename) {
      {
        output.set(filename, op1);
        output.set(filename, op2);
        op1 += filenameLength;
        op2 += filenameLength;
      }
    }

    // extra field
    extraField = file.option['extraField'];
    if (extraField) {
      {
        output.set(extraField, op1);
        output.set(extraField, op2);
        op1 += extraFieldLength;
        op2 += extraFieldLength;
      }
    }

    // comment
    comment = file.option['comment'];
    if (comment) {
      {
        output.set(comment, op2);
        op2 += commentLength;
      }
    }

    //-------------------------------------------------------------------------
    // file data
    //-------------------------------------------------------------------------

    {
      output.set(file.buffer, op1);
      op1 += file.buffer.length;
    }
  }

  //-------------------------------------------------------------------------
  // end of central directory
  //-------------------------------------------------------------------------

  // signature
  output[op3++] = Zlib$2.Zip.CentralDirectorySignature[0];
  output[op3++] = Zlib$2.Zip.CentralDirectorySignature[1];
  output[op3++] = Zlib$2.Zip.CentralDirectorySignature[2];
  output[op3++] = Zlib$2.Zip.CentralDirectorySignature[3];

  // number of this disk
  output[op3++] = 0;
  output[op3++] = 0;

  // number of the disk with the start of the central directory
  output[op3++] = 0;
  output[op3++] = 0;

  // total number of entries in the central directory on this disk
  output[op3++] = il & 0xff;
  output[op3++] = (il >> 8) & 0xff;

  // total number of entries in the central directory
  output[op3++] = il & 0xff;
  output[op3++] = (il >> 8) & 0xff;

  // size of the central directory
  output[op3++] = centralDirectorySize & 0xff;
  output[op3++] = (centralDirectorySize >> 8) & 0xff;
  output[op3++] = (centralDirectorySize >> 16) & 0xff;
  output[op3++] = (centralDirectorySize >> 24) & 0xff;

  // offset of start of central directory with respect to the starting disk number
  output[op3++] = localFileSize & 0xff;
  output[op3++] = (localFileSize >> 8) & 0xff;
  output[op3++] = (localFileSize >> 16) & 0xff;
  output[op3++] = (localFileSize >> 24) & 0xff;

  // .ZIP file comment length
  commentLength = this.comment ? this.comment.length : 0;
  output[op3++] = commentLength & 0xff;
  output[op3++] = (commentLength >> 8) & 0xff;

  // .ZIP file comment
  if (this.comment) {
    {
      output.set(this.comment, op3);
      op3 += commentLength;
    }
  }

  return output;
};

/**
* @param {!(Array.<number>|Uint8Array)} input
* @param {Object=} opt_params options.
* @return {!(Array.<number>|Uint8Array)}
*/
Zlib$2.Zip.prototype.deflateWithOption = function (input, opt_params) {
  /** @type {Zlib.RawDeflate} */
  var deflator = new Zlib$2.RawDeflate(input, opt_params['deflateOption']);

  return deflator.compress();
};

/**
* @param {(Array.<number>|Uint32Array)} key
* @return {number}
*/
Zlib$2.Zip.prototype.getByte = function (key) {
  /** @type {number} */
  var tmp = ((key[2] & 0xffff) | 2);

  return ((tmp * (tmp ^ 1)) >> 8) & 0xff;
};

/**
* @param {(Array.<number>|Uint32Array|Object)} key
* @param {number} n
* @return {number}
*/
Zlib$2.Zip.prototype.encode = function (key, n) {
  /** @type {number} */
  var tmp = this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));

  this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);

  return tmp ^ n;
};

/**
* @param {(Array.<number>|Uint32Array)} key
* @param {number} n
*/
Zlib$2.Zip.prototype.updateKeys = function (key, n) {
  key[0] = Zlib$2.CRC32.single(key[0], n);
  key[1] =
    (((((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681) >>> 0) + 1) >>> 0;
  key[2] = Zlib$2.CRC32.single(key[2], key[1] >>> 24);
};

/**
* @param {(Array.<number>|Uint8Array)} password
* @return {!(Array.<number>|Uint32Array|Object)}
*/
Zlib$2.Zip.prototype.createEncryptionKey = function (password) {
  /** @type {!(Array.<number>|Uint32Array)} */
  var key = [305419896, 591751049, 878082192];
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  {
    key = new Uint32Array(key);
  }

  for (i = 0, il = password.length; i < il; ++i) {
    this.updateKeys(key, password[i] & 0xff);
  }

  return key;
};



/**
* build huffman table from length list.
* @param {!(Array.<number>|Uint8Array)} lengths length list.
* @return {!Array} huffman table.
*/
Zlib$2.Huffman.buildHuffmanTable = function (lengths) {
  /** @type {number} length list size. */
  var listSize = lengths.length;
  /** @type {number} max code length for table size. */
  var maxCodeLength = 0;
  /** @type {number} min code length for table size. */
  var minCodeLength = Number.POSITIVE_INFINITY;
  /** @type {number} table size. */
  var size;
  /** @type {!(Array|Uint8Array)} huffman code table. */
  var table;
  /** @type {number} bit length. */
  var bitLength;
  /** @type {number} huffman code. */
  var code;
  /**
   * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.
   * @type {number} skip length for table filling.
   */
  var skip;
  /** @type {number} reversed code. */
  var reversed;
  /** @type {number} reverse temp. */
  var rtemp;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limit. */
  var il;
  /** @type {number} loop counter. */
  var j;
  /** @type {number} table value. */
  var value;

  // Math.max は遅いので最長の値は for-loop で取得する
  for (i = 0, il = listSize; i < il; ++i) {
    if (lengths[i] > maxCodeLength) {
      maxCodeLength = lengths[i];
    }
    if (lengths[i] < minCodeLength) {
      minCodeLength = lengths[i];
    }
  }

  size = 1 << maxCodeLength;
  table = new (Uint32Array)(size);

  // ビット長の短い順からハフマン符号を割り当てる
  for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {
    for (i = 0; i < listSize; ++i) {
      if (lengths[i] === bitLength) {
        // ビットオーダーが逆になるためビット長分並びを反転する
        for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {
          reversed = (reversed << 1) | (rtemp & 1);
          rtemp >>= 1;
        }

        // 最大ビット長をもとにテーブルを作るため、
        // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる
        // そのどちらでも良い場所は同じ値で埋めることで
        // 本来のビット長以上のビット数取得しても問題が起こらないようにする
        value = (bitLength << 16) | i;
        for (j = reversed; j < size; j += skip) {
          table[j] = value;
        }

        ++code;
      }
    }

    // 次のビット長へ
    ++bitLength;
    code <<= 1;
    skip <<= 1;
  }

  return [table, maxCodeLength, minCodeLength];
};




//-----------------------------------------------------------------------------

/** @define {number} buffer block size. */
var ZLIB_RAW_INFLATE_BUFFER_SIZE$2 = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]

//-----------------------------------------------------------------------------


var buildHuffmanTable$2 = Zlib$2.Huffman.buildHuffmanTable;

/**
* @constructor
* @param {!(Uint8Array|Array.<number>)} input input buffer.
* @param {Object} opt_params option parameter.
*
* opt_params は以下のプロパティを指定する事ができます。
*   - index: input buffer の deflate コンテナの開始位置.
*   - blockSize: バッファのブロックサイズ.
*   - bufferType: Zlib.RawInflate.BufferType の値によってバッファの管理方法を指定する.
*   - resize: 確保したバッファが実際の大きさより大きかった場合に切り詰める.
*/
Zlib$2.RawInflate = function (input, opt_params) {
  /** @type {!(Array.<number>|Uint8Array)} inflated buffer */
  this.buffer;
  /** @type {!Array.<(Array.<number>|Uint8Array)>} */
  this.blocks = [];
  /** @type {number} block size. */
  this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE$2;
  /** @type {!number} total output buffer pointer. */
  this.totalpos = 0;
  /** @type {!number} input buffer pointer. */
  this.ip = 0;
  /** @type {!number} bit stream reader buffer. */
  this.bitsbuf = 0;
  /** @type {!number} bit stream reader buffer size. */
  this.bitsbuflen = 0;
  /** @type {!(Array.<number>|Uint8Array)} input buffer. */
  this.input = new Uint8Array(input);
  /** @type {!(Uint8Array|Array.<number>)} output buffer. */
  this.output;
  /** @type {!number} output buffer pointer. */
  this.op;
  /** @type {boolean} is final block flag. */
  this.bfinal = false;
  /** @type {Zlib.RawInflate.BufferType} buffer management. */
  this.bufferType = Zlib$2.RawInflate.BufferType.ADAPTIVE;
  /** @type {boolean} resize flag for memory size optimization. */
  this.resize = false;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (opt_params['index']) {
      this.ip = opt_params['index'];
    }
    if (opt_params['bufferSize']) {
      this.bufferSize = opt_params['bufferSize'];
    }
    if (opt_params['bufferType']) {
      this.bufferType = opt_params['bufferType'];
    }
    if (opt_params['resize']) {
      this.resize = opt_params['resize'];
    }
  }

  // initialize
  switch (this.bufferType) {
    case Zlib$2.RawInflate.BufferType.BLOCK:
      this.op = Zlib$2.RawInflate.MaxBackwardLength;
      this.output =
        new (Uint8Array)(
          Zlib$2.RawInflate.MaxBackwardLength +
          this.bufferSize +
          Zlib$2.RawInflate.MaxCopyLength
        );
      break;
    case Zlib$2.RawInflate.BufferType.ADAPTIVE:
      this.op = 0;
      this.output = new (Uint8Array)(this.bufferSize);
      break;
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
* @enum {number}
*/
Zlib$2.RawInflate.BufferType = {
  BLOCK: 0,
  ADAPTIVE: 1
};

/**
* decompress.
* @return {!(Uint8Array|Array.<number>)} inflated buffer.
*/
Zlib$2.RawInflate.prototype.decompress = function () {
  while (!this.bfinal) {
    this.parseBlock();
  }

  switch (this.bufferType) {
    case Zlib$2.RawInflate.BufferType.BLOCK:
      return this.concatBufferBlock();
    case Zlib$2.RawInflate.BufferType.ADAPTIVE:
      return this.concatBufferDynamic();
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
* @const
* @type {number} max backward length for LZ77.
*/
Zlib$2.RawInflate.MaxBackwardLength = 32768;

/**
* @const
* @type {number} max copy length for LZ77.
*/
Zlib$2.RawInflate.MaxCopyLength = 258;

/**
* huffman order
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib$2.RawInflate.Order = (function (table) {
  return new Uint16Array(table);
})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

/**
* huffman length code table.
* @const
* @type {!(Array.<number>|Uint16Array)}
*/
Zlib$2.RawInflate.LengthCodeTable = (function (table) {
  return new Uint16Array(table);
})([
  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,
  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,
  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,
  0x00e3, 0x0102, 0x0102, 0x0102
]);

/**
* huffman length extra-bits table.
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib$2.RawInflate.LengthExtraTable = (function (table) {
  return new Uint8Array(table);
})([
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 5, 0, 0, 0
]);

/**
* huffman dist code table.
* @const
* @type {!(Array.<number>|Uint16Array)}
*/
Zlib$2.RawInflate.DistCodeTable = (function (table) {
  return new Uint16Array(table);
})([
  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,
  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,
  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,
  0x3001, 0x4001, 0x6001
]);

/**
* huffman dist extra-bits table.
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib$2.RawInflate.DistExtraTable = (function (table) {
  return new Uint8Array(table);
})([
  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
  11, 12, 12, 13, 13
]);

/**
* fixed huffman length code table
* @const
* @type {!Array}
*/
Zlib$2.RawInflate.FixedLiteralLengthTable = (function (table) {
  return table;
})((function () {
  var lengths = new (Uint8Array)(288);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] =
      (i <= 143) ? 8 :
        (i <= 255) ? 9 :
          (i <= 279) ? 7 :
            8;
  }

  return buildHuffmanTable$2(lengths);
})());

/**
* fixed huffman distance code table
* @const
* @type {!Array}
*/
Zlib$2.RawInflate.FixedDistanceTable = (function (table) {
  return table;
})((function () {
  var lengths = new (Uint8Array)(30);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = 5;
  }

  return buildHuffmanTable$2(lengths);
})());

/**
* parse deflated block.
*/
Zlib$2.RawInflate.prototype.parseBlock = function () {
  /** @type {number} header */
  var hdr = this.readBits(3);

  // BFINAL
  if (hdr & 0x1) {
    this.bfinal = true;
  }

  // BTYPE
  hdr >>>= 1;
  switch (hdr) {
    // uncompressed
    case 0:
      this.parseUncompressedBlock();
      break;
    // fixed huffman
    case 1:
      this.parseFixedHuffmanBlock();
      break;
    // dynamic huffman
    case 2:
      this.parseDynamicHuffmanBlock();
      break;
    // reserved or other
    default:
      throw new Error('unknown BTYPE: ' + hdr);
  }
};

/**
* read inflate bits
* @param {number} length bits length.
* @return {number} read bits.
*/
Zlib$2.RawInflate.prototype.readBits = function (length) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} */
  var inputLength = input.length;
  /** @type {number} input and output byte. */
  var octet;

  // input byte
  if (ip + ((length - bitsbuflen + 7) >> 3) >= inputLength) {
    throw new Error('input buffer is broken');
  }

  // not enough buffer
  while (bitsbuflen < length) {
    bitsbuf |= input[ip++] << bitsbuflen;
    bitsbuflen += 8;
  }

  // output byte
  octet = bitsbuf & /* MASK */ ((1 << length) - 1);
  bitsbuf >>>= length;
  bitsbuflen -= length;

  this.bitsbuf = bitsbuf;
  this.bitsbuflen = bitsbuflen;
  this.ip = ip;

  return octet;
};

/**
* read huffman code using table
* @param {!(Array.<number>|Uint8Array|Uint16Array)} table huffman code table.
* @return {number} huffman code.
*/
Zlib$2.RawInflate.prototype.readCodeByTable = function (table) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} */
  var inputLength = input.length;
  /** @type {!(Array.<number>|Uint8Array)} huffman code table */
  var codeTable = table[0];
  /** @type {number} */
  var maxCodeLength = table[1];
  /** @type {number} code length & code (16bit, 16bit) */
  var codeWithLength;
  /** @type {number} code bits length */
  var codeLength;

  // not enough buffer
  while (bitsbuflen < maxCodeLength) {
    if (ip >= inputLength) {
      break;
    }
    bitsbuf |= input[ip++] << bitsbuflen;
    bitsbuflen += 8;
  }

  // read max length
  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];
  codeLength = codeWithLength >>> 16;

  if (codeLength > bitsbuflen) {
    throw new Error('invalid code length: ' + codeLength);
  }

  this.bitsbuf = bitsbuf >> codeLength;
  this.bitsbuflen = bitsbuflen - codeLength;
  this.ip = ip;

  return codeWithLength & 0xffff;
};

/**
* parse uncompressed block.
*/
Zlib$2.RawInflate.prototype.parseUncompressedBlock = function () {
  var input = this.input;
  var ip = this.ip;
  var output = this.output;
  var op = this.op;

  /** @type {number} */
  var inputLength = input.length;
  /** @type {number} block length */
  var len;
  /** @type {number} number for check block length */
  var nlen;
  /** @type {number} output buffer length */
  var olength = output.length;
  /** @type {number} copy counter */
  var preCopy;

  // skip buffered header bits
  this.bitsbuf = 0;
  this.bitsbuflen = 0;

  // len
  if (ip + 1 >= inputLength) {
    throw new Error('invalid uncompressed block header: LEN');
  }
  len = input[ip++] | (input[ip++] << 8);

  // nlen
  if (ip + 1 >= inputLength) {
    throw new Error('invalid uncompressed block header: NLEN');
  }
  nlen = input[ip++] | (input[ip++] << 8);

  // check len & nlen
  if (len === ~nlen) {
    throw new Error('invalid uncompressed block header: length verify');
  }

  // check size
  if (ip + len > input.length) { throw new Error('input buffer is broken'); }

  // expand buffer
  switch (this.bufferType) {
    case Zlib$2.RawInflate.BufferType.BLOCK:
      // pre copy
      while (op + len > output.length) {
        preCopy = olength - op;
        len -= preCopy;
        {
          output.set(input.subarray(ip, ip + preCopy), op);
          op += preCopy;
          ip += preCopy;
        }
        this.op = op;
        output = this.expandBufferBlock();
        op = this.op;
      }
      break;
    case Zlib$2.RawInflate.BufferType.ADAPTIVE:
      while (op + len > output.length) {
        output = this.expandBufferAdaptive({ fixRatio: 2 });
      }
      break;
    default:
      throw new Error('invalid inflate mode');
  }

  // copy
  {
    output.set(input.subarray(ip, ip + len), op);
    op += len;
    ip += len;
  }

  this.ip = ip;
  this.op = op;
  this.output = output;
};

/**
* parse fixed huffman block.
*/
Zlib$2.RawInflate.prototype.parseFixedHuffmanBlock = function () {
  switch (this.bufferType) {
    case Zlib$2.RawInflate.BufferType.ADAPTIVE:
      this.decodeHuffmanAdaptive(
        Zlib$2.RawInflate.FixedLiteralLengthTable,
        Zlib$2.RawInflate.FixedDistanceTable
      );
      break;
    case Zlib$2.RawInflate.BufferType.BLOCK:
      this.decodeHuffmanBlock(
        Zlib$2.RawInflate.FixedLiteralLengthTable,
        Zlib$2.RawInflate.FixedDistanceTable
      );
      break;
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
* parse dynamic huffman block.
*/
Zlib$2.RawInflate.prototype.parseDynamicHuffmanBlock = function () {
  /** @type {number} number of literal and length codes. */
  var hlit = this.readBits(5) + 257;
  /** @type {number} number of distance codes. */
  var hdist = this.readBits(5) + 1;
  /** @type {number} number of code lengths. */
  var hclen = this.readBits(4) + 4;
  /** @type {!(Uint8Array|Array.<number>)} code lengths. */
  var codeLengths =
    new (Uint8Array)(Zlib$2.RawInflate.Order.length);
  /** @type {!Array} code lengths table. */
  var codeLengthsTable;
  /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */
  var litlenTable;
  /** @type {!(Uint8Array|Array.<number>)} distance code table. */
  var distTable;
  /** @type {!(Uint8Array|Array.<number>)} code length table. */
  var lengthTable;
  /** @type {number} */
  var code;
  /** @type {number} */
  var prev;
  /** @type {number} */
  var repeat;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limit. */
  var il;

  // decode code lengths
  for (i = 0; i < hclen; ++i) {
    codeLengths[Zlib$2.RawInflate.Order[i]] = this.readBits(3);
  }

  // decode length table
  codeLengthsTable = buildHuffmanTable$2(codeLengths);
  lengthTable = new (Uint8Array)(hlit + hdist);
  for (i = 0, il = hlit + hdist; i < il;) {
    code = this.readCodeByTable(codeLengthsTable);
    switch (code) {
      case 16:
        repeat = 3 + this.readBits(2);
        while (repeat--) { lengthTable[i++] = prev; }
        break;
      case 17:
        repeat = 3 + this.readBits(3);
        while (repeat--) { lengthTable[i++] = 0; }
        prev = 0;
        break;
      case 18:
        repeat = 11 + this.readBits(7);
        while (repeat--) { lengthTable[i++] = 0; }
        prev = 0;
        break;
      default:
        lengthTable[i++] = code;
        prev = code;
        break;
    }
  }

  litlenTable = buildHuffmanTable$2(lengthTable.subarray(0, hlit))
    ;
  distTable = buildHuffmanTable$2(lengthTable.subarray(hlit))
    ;

  switch (this.bufferType) {
    case Zlib$2.RawInflate.BufferType.ADAPTIVE:
      this.decodeHuffmanAdaptive(litlenTable, distTable);
      break;
    case Zlib$2.RawInflate.BufferType.BLOCK:
      this.decodeHuffmanBlock(litlenTable, distTable);
      break;
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
* decode huffman code
* @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.
* @param {!(Array.<number>|Uint8Array)} dist distination code table.
*/
Zlib$2.RawInflate.prototype.decodeHuffmanBlock = function (litlen, dist) {
  var output = this.output;
  var op = this.op;

  this.currentLitlenTable = litlen;

  /** @type {number} output position limit. */
  var olength = output.length - Zlib$2.RawInflate.MaxCopyLength;
  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  var lengthCodeTable = Zlib$2.RawInflate.LengthCodeTable;
  var lengthExtraTable = Zlib$2.RawInflate.LengthExtraTable;
  var distCodeTable = Zlib$2.RawInflate.DistCodeTable;
  var distExtraTable = Zlib$2.RawInflate.DistExtraTable;

  while ((code = this.readCodeByTable(litlen)) !== 256) {
    // literal
    if (code < 256) {
      if (op >= olength) {
        this.op = op;
        output = this.expandBufferBlock();
        op = this.op;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = lengthCodeTable[ti];
    if (lengthExtraTable[ti] > 0) {
      codeLength += this.readBits(lengthExtraTable[ti]);
    }

    // dist code
    code = this.readCodeByTable(dist);
    codeDist = distCodeTable[code];
    if (distExtraTable[code] > 0) {
      codeDist += this.readBits(distExtraTable[code]);
    }

    // lz77 decode
    if (op >= olength) {
      this.op = op;
      output = this.expandBufferBlock();
      op = this.op;
    }
    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};

/**
* decode huffman code (adaptive)
* @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.
* @param {!(Array.<number>|Uint8Array)} dist distination code table.
*/
Zlib$2.RawInflate.prototype.decodeHuffmanAdaptive = function (litlen, dist) {
  var output = this.output;
  var op = this.op;

  this.currentLitlenTable = litlen;

  /** @type {number} output position limit. */
  var olength = output.length;
  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  var lengthCodeTable = Zlib$2.RawInflate.LengthCodeTable;
  var lengthExtraTable = Zlib$2.RawInflate.LengthExtraTable;
  var distCodeTable = Zlib$2.RawInflate.DistCodeTable;
  var distExtraTable = Zlib$2.RawInflate.DistExtraTable;

  while ((code = this.readCodeByTable(litlen)) !== 256) {
    // literal
    if (code < 256) {
      if (op >= olength) {
        output = this.expandBufferAdaptive();
        olength = output.length;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = lengthCodeTable[ti];
    if (lengthExtraTable[ti] > 0) {
      codeLength += this.readBits(lengthExtraTable[ti]);
    }

    // dist code
    code = this.readCodeByTable(dist);
    codeDist = distCodeTable[code];
    if (distExtraTable[code] > 0) {
      codeDist += this.readBits(distExtraTable[code]);
    }

    // lz77 decode
    if (op + codeLength > olength) {
      output = this.expandBufferAdaptive();
      olength = output.length;
    }
    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};

/**
* expand output buffer.
* @param {Object=} opt_param option parameters.
* @return {!(Array.<number>|Uint8Array)} output buffer.
*/
Zlib$2.RawInflate.prototype.expandBufferBlock = function (opt_param) {
  /** @type {!(Array.<number>|Uint8Array)} store buffer. */
  var buffer =
    new (Uint8Array)(
      this.op - Zlib$2.RawInflate.MaxBackwardLength
    );
  /** @type {number} backward base point */
  var backward = this.op - Zlib$2.RawInflate.MaxBackwardLength;

  var output = this.output;

  // copy to output buffer
  {
    buffer.set(output.subarray(Zlib$2.RawInflate.MaxBackwardLength, buffer.length));
  }

  this.blocks.push(buffer);
  this.totalpos += buffer.length;

  // copy to backward buffer
  {
    output.set(
      output.subarray(backward, backward + Zlib$2.RawInflate.MaxBackwardLength)
    );
  }

  this.op = Zlib$2.RawInflate.MaxBackwardLength;

  return output;
};

/**
* expand output buffer. (adaptive)
* @param {Object=} opt_param option parameters.
* @return {!(Array.<number>|Uint8Array)} output buffer pointer.
*/
Zlib$2.RawInflate.prototype.expandBufferAdaptive = function (opt_param) {
  /** @type {!(Array.<number>|Uint8Array)} store buffer. */
  var buffer;
  /** @type {number} expantion ratio. */
  var ratio = (this.input.length / this.ip + 1) | 0;
  /** @type {number} maximum number of huffman code. */
  var maxHuffCode;
  /** @type {number} new output buffer size. */
  var newSize;
  /** @type {number} max inflate size. */
  var maxInflateSize;

  var input = this.input;
  var output = this.output;

  if (opt_param) {
    if (typeof opt_param.fixRatio === 'number') {
      ratio = opt_param.fixRatio;
    }
    if (typeof opt_param.addRatio === 'number') {
      ratio += opt_param.addRatio;
    }
  }

  // calculate new buffer size
  if (ratio < 2) {
    maxHuffCode =
      (input.length - this.ip) / this.currentLitlenTable[2];
    maxInflateSize = (maxHuffCode / 2 * 258) | 0;
    newSize = maxInflateSize < output.length ?
      output.length + maxInflateSize :
      output.length << 1;
  } else {
    newSize = output.length * ratio;
  }

  // buffer expantion
  {
    buffer = new Uint8Array(newSize);
    buffer.set(output);
  }

  this.output = buffer;

  return this.output;
};

/**
* concat output buffer.
* @return {!(Array.<number>|Uint8Array)} output buffer.
*/
Zlib$2.RawInflate.prototype.concatBufferBlock = function () {
  /** @type {number} buffer pointer. */
  var pos = 0;
  /** @type {number} buffer pointer. */
  var limit = this.totalpos + (this.op - Zlib$2.RawInflate.MaxBackwardLength);
  /** @type {!(Array.<number>|Uint8Array)} output block array. */
  var output = this.output;
  /** @type {!Array} blocks array. */
  var blocks = this.blocks;
  /** @type {!(Array.<number>|Uint8Array)} output block array. */
  var block;
  /** @type {!(Array.<number>|Uint8Array)} output buffer. */
  var buffer = new (Uint8Array)(limit);
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limiter. */
  var il;
  /** @type {number} loop counter. */
  var j;
  /** @type {number} loop limiter. */
  var jl;

  // single buffer
  if (blocks.length === 0) {
    return this.output.subarray(Zlib$2.RawInflate.MaxBackwardLength, this.op);
  }

  // copy to buffer
  for (i = 0, il = blocks.length; i < il; ++i) {
    block = blocks[i];
    for (j = 0, jl = block.length; j < jl; ++j) {
      buffer[pos++] = block[j];
    }
  }

  // current buffer
  for (i = Zlib$2.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {
    buffer[pos++] = output[i];
  }

  this.blocks = [];
  this.buffer = buffer;

  return this.buffer;
};

/**
* concat output buffer. (dynamic)
* @return {!(Array.<number>|Uint8Array)} output buffer.
*/
Zlib$2.RawInflate.prototype.concatBufferDynamic = function () {
  /** @type {Array.<number>|Uint8Array} output buffer. */
  var buffer;
  var op = this.op;

  {
    if (this.resize) {
      buffer = new Uint8Array(op);
      buffer.set(this.output.subarray(0, op));
    } else {
      buffer = this.output.subarray(0, op);
    }
  }

  this.buffer = buffer;

  return this.buffer;
};




var buildHuffmanTable$2 = Zlib$2.Huffman.buildHuffmanTable;

/**
* @param {!(Uint8Array|Array.<number>)} input input buffer.
* @param {number} ip input buffer pointer.
* @param {number=} opt_buffersize buffer block size.
* @constructor
*/
Zlib$2.RawInflateStream = function (input, ip, opt_buffersize) {
  /** @type {!Array.<(Array|Uint8Array)>} */
  this.blocks = [];
  /** @type {number} block size. */
  this.bufferSize =
    opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE$2;
  /** @type {!number} total output buffer pointer. */
  this.totalpos = 0;
  /** @type {!number} input buffer pointer. */
  this.ip = ip === void 0 ? 0 : ip;
  /** @type {!number} bit stream reader buffer. */
  this.bitsbuf = 0;
  /** @type {!number} bit stream reader buffer size. */
  this.bitsbuflen = 0;
  /** @type {!(Array|Uint8Array)} input buffer. */
  this.input = new Uint8Array(input);
  /** @type {!(Uint8Array|Array)} output buffer. */
  this.output = new (Uint8Array)(this.bufferSize);
  /** @type {!number} output buffer pointer. */
  this.op = 0;
  /** @type {boolean} is final block flag. */
  this.bfinal = false;
  /** @type {number} uncompressed block length. */
  this.blockLength;
  /** @type {boolean} resize flag for memory size optimization. */
  this.resize = false;
  /** @type {Array} */
  this.litlenTable;
  /** @type {Array} */
  this.distTable;
  /** @type {number} */
  this.sp = 0; // stream pointer
  /** @type {Zlib.RawInflateStream.Status} */
  this.status = Zlib$2.RawInflateStream.Status.INITIALIZED;

  //
  // backup
  //
  /** @type {!number} */
  this.ip_;
  /** @type {!number} */
  this.bitsbuflen_;
  /** @type {!number} */
  this.bitsbuf_;
};

/**
* @enum {number}
*/
Zlib$2.RawInflateStream.BlockType = {
  UNCOMPRESSED: 0,
  FIXED: 1,
  DYNAMIC: 2
};

/**
* @enum {number}
*/
Zlib$2.RawInflateStream.Status = {
  INITIALIZED: 0,
  BLOCK_HEADER_START: 1,
  BLOCK_HEADER_END: 2,
  BLOCK_BODY_START: 3,
  BLOCK_BODY_END: 4,
  DECODE_BLOCK_START: 5,
  DECODE_BLOCK_END: 6
};

/**
* decompress.
* @return {!(Uint8Array|Array)} inflated buffer.
*/
Zlib$2.RawInflateStream.prototype.decompress = function (newInput, ip) {
  /** @type {boolean} */
  var stop = false;

  if (newInput !== void 0) {
    this.input = newInput;
  }

  if (ip !== void 0) {
    this.ip = ip;
  }

  // decompress
  while (!stop) {
    switch (this.status) {
      // block header
      case Zlib$2.RawInflateStream.Status.INITIALIZED:
      case Zlib$2.RawInflateStream.Status.BLOCK_HEADER_START:
        if (this.readBlockHeader() < 0) {
          stop = true;
        }
        break;
      // block body
      case Zlib$2.RawInflateStream.Status.BLOCK_HEADER_END: /* FALLTHROUGH */
      case Zlib$2.RawInflateStream.Status.BLOCK_BODY_START:
        switch (this.currentBlockType) {
          case Zlib$2.RawInflateStream.BlockType.UNCOMPRESSED:
            if (this.readUncompressedBlockHeader() < 0) {
              stop = true;
            }
            break;
          case Zlib$2.RawInflateStream.BlockType.FIXED:
            if (this.parseFixedHuffmanBlock() < 0) {
              stop = true;
            }
            break;
          case Zlib$2.RawInflateStream.BlockType.DYNAMIC:
            if (this.parseDynamicHuffmanBlock() < 0) {
              stop = true;
            }
            break;
        }
        break;
      // decode data
      case Zlib$2.RawInflateStream.Status.BLOCK_BODY_END:
      case Zlib$2.RawInflateStream.Status.DECODE_BLOCK_START:
        switch (this.currentBlockType) {
          case Zlib$2.RawInflateStream.BlockType.UNCOMPRESSED:
            if (this.parseUncompressedBlock() < 0) {
              stop = true;
            }
            break;
          case Zlib$2.RawInflateStream.BlockType.FIXED: /* FALLTHROUGH */
          case Zlib$2.RawInflateStream.BlockType.DYNAMIC:
            if (this.decodeHuffman() < 0) {
              stop = true;
            }
            break;
        }
        break;
      case Zlib$2.RawInflateStream.Status.DECODE_BLOCK_END:
        if (this.bfinal) {
          stop = true;
        } else {
          this.status = Zlib$2.RawInflateStream.Status.INITIALIZED;
        }
        break;
    }
  }

  return this.concatBuffer();
};

/**
* @const
* @type {number} max backward length for LZ77.
*/
Zlib$2.RawInflateStream.MaxBackwardLength = 32768;

/**
* @const
* @type {number} max copy length for LZ77.
*/
Zlib$2.RawInflateStream.MaxCopyLength = 258;

/**
* huffman order
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib$2.RawInflateStream.Order = (function (table) {
  return new Uint16Array(table);
})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

/**
* huffman length code table.
* @const
* @type {!(Array.<number>|Uint16Array)}
*/
Zlib$2.RawInflateStream.LengthCodeTable = (function (table) {
  return new Uint16Array(table);
})([
  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,
  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,
  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,
  0x00e3, 0x0102, 0x0102, 0x0102
]);

/**
* huffman length extra-bits table.
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib$2.RawInflateStream.LengthExtraTable = (function (table) {
  return new Uint8Array(table);
})([
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 5, 0, 0, 0
]);

/**
* huffman dist code table.
* @const
* @type {!(Array.<number>|Uint16Array)}
*/
Zlib$2.RawInflateStream.DistCodeTable = (function (table) {
  return new Uint16Array(table);
})([
  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,
  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,
  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,
  0x3001, 0x4001, 0x6001
]);

/**
* huffman dist extra-bits table.
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib$2.RawInflateStream.DistExtraTable = (function (table) {
  return new Uint8Array(table);
})([
  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
  11, 12, 12, 13, 13
]);

/**
* fixed huffman length code table
* @const
* @type {!Array}
*/
Zlib$2.RawInflateStream.FixedLiteralLengthTable = (function (table) {
  return table;
})((function () {
  var lengths = new (Uint8Array)(288);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] =
      (i <= 143) ? 8 :
        (i <= 255) ? 9 :
          (i <= 279) ? 7 :
            8;
  }

  return buildHuffmanTable$2(lengths);
})());

/**
* fixed huffman distance code table
* @const
* @type {!Array}
*/
Zlib$2.RawInflateStream.FixedDistanceTable = (function (table) {
  return table;
})((function () {
  var lengths = new (Uint8Array)(30);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = 5;
  }

  return buildHuffmanTable$2(lengths);
})());

/**
* parse deflated block.
*/
Zlib$2.RawInflateStream.prototype.readBlockHeader = function () {
  /** @type {number} header */
  var hdr;

  this.status = Zlib$2.RawInflateStream.Status.BLOCK_HEADER_START;

  this.save_();
  if ((hdr = this.readBits(3)) < 0) {
    this.restore_();
    return -1;
  }

  // BFINAL
  if (hdr & 0x1) {
    this.bfinal = true;
  }

  // BTYPE
  hdr >>>= 1;
  switch (hdr) {
    case 0: // uncompressed
      this.currentBlockType = Zlib$2.RawInflateStream.BlockType.UNCOMPRESSED;
      break;
    case 1: // fixed huffman
      this.currentBlockType = Zlib$2.RawInflateStream.BlockType.FIXED;
      break;
    case 2: // dynamic huffman
      this.currentBlockType = Zlib$2.RawInflateStream.BlockType.DYNAMIC;
      break;
    default: // reserved or other
      throw new Error('unknown BTYPE: ' + hdr);
  }

  this.status = Zlib$2.RawInflateStream.Status.BLOCK_HEADER_END;
};

/**
* read inflate bits
* @param {number} length bits length.
* @return {number} read bits.
*/
Zlib$2.RawInflateStream.prototype.readBits = function (length) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} input and output byte. */
  var octet;

  // not enough buffer
  while (bitsbuflen < length) {
    // input byte
    if (input.length <= ip) {
      return -1;
    }
    octet = input[ip++];

    // concat octet
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }

  // output byte
  octet = bitsbuf & /* MASK */ ((1 << length) - 1);
  bitsbuf >>>= length;
  bitsbuflen -= length;

  this.bitsbuf = bitsbuf;
  this.bitsbuflen = bitsbuflen;
  this.ip = ip;

  return octet;
};

/**
* read huffman code using table
* @param {Array} table huffman code table.
* @return {number} huffman code.
*/
Zlib$2.RawInflateStream.prototype.readCodeByTable = function (table) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {!(Array|Uint8Array)} huffman code table */
  var codeTable = table[0];
  /** @type {number} */
  var maxCodeLength = table[1];
  /** @type {number} input byte */
  var octet;
  /** @type {number} code length & code (16bit, 16bit) */
  var codeWithLength;
  /** @type {number} code bits length */
  var codeLength;

  // not enough buffer
  while (bitsbuflen < maxCodeLength) {
    if (input.length <= ip) {
      return -1;
    }
    octet = input[ip++];
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }

  // read max length
  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];
  codeLength = codeWithLength >>> 16;

  if (codeLength > bitsbuflen) {
    throw new Error('invalid code length: ' + codeLength);
  }

  this.bitsbuf = bitsbuf >> codeLength;
  this.bitsbuflen = bitsbuflen - codeLength;
  this.ip = ip;

  return codeWithLength & 0xffff;
};

/**
* read uncompressed block header
*/
Zlib$2.RawInflateStream.prototype.readUncompressedBlockHeader = function () {
  /** @type {number} block length */
  var len;
  /** @type {number} number for check block length */
  var nlen;

  var input = this.input;
  var ip = this.ip;

  this.status = Zlib$2.RawInflateStream.Status.BLOCK_BODY_START;

  if (ip + 4 >= input.length) {
    return -1;
  }

  len = input[ip++] | (input[ip++] << 8);
  nlen = input[ip++] | (input[ip++] << 8);

  // check len & nlen
  if (len === ~nlen) {
    throw new Error('invalid uncompressed block header: length verify');
  }

  // skip buffered header bits
  this.bitsbuf = 0;
  this.bitsbuflen = 0;

  this.ip = ip;
  this.blockLength = len;
  this.status = Zlib$2.RawInflateStream.Status.BLOCK_BODY_END;
};

/**
* parse uncompressed block.
*/
Zlib$2.RawInflateStream.prototype.parseUncompressedBlock = function () {
  var input = this.input;
  var ip = this.ip;
  var output = this.output;
  var op = this.op;
  var len = this.blockLength;

  this.status = Zlib$2.RawInflateStream.Status.DECODE_BLOCK_START;

  // copy
  // XXX: とりあえず素直にコピー
  while (len--) {
    if (op === output.length) {
      output = this.expandBuffer({ fixRatio: 2 });
    }

    // not enough input buffer
    if (ip >= input.length) {
      this.ip = ip;
      this.op = op;
      this.blockLength = len + 1; // コピーしてないので戻す
      return -1;
    }

    output[op++] = input[ip++];
  }

  if (len < 0) {
    this.status = Zlib$2.RawInflateStream.Status.DECODE_BLOCK_END;
  }

  this.ip = ip;
  this.op = op;

  return 0;
};

/**
* parse fixed huffman block.
*/
Zlib$2.RawInflateStream.prototype.parseFixedHuffmanBlock = function () {
  this.status = Zlib$2.RawInflateStream.Status.BLOCK_BODY_START;

  this.litlenTable = Zlib$2.RawInflateStream.FixedLiteralLengthTable;
  this.distTable = Zlib$2.RawInflateStream.FixedDistanceTable;

  this.status = Zlib$2.RawInflateStream.Status.BLOCK_BODY_END;

  return 0;
};

/**
* オブジェクトのコンテキストを別のプロパティに退避する.
* @private
*/
Zlib$2.RawInflateStream.prototype.save_ = function () {
  this.ip_ = this.ip;
  this.bitsbuflen_ = this.bitsbuflen;
  this.bitsbuf_ = this.bitsbuf;
};

/**
* 別のプロパティに退避したコンテキストを復元する.
* @private
*/
Zlib$2.RawInflateStream.prototype.restore_ = function () {
  this.ip = this.ip_;
  this.bitsbuflen = this.bitsbuflen_;
  this.bitsbuf = this.bitsbuf_;
};

/**
* parse dynamic huffman block.
*/
Zlib$2.RawInflateStream.prototype.parseDynamicHuffmanBlock = function () {
  /** @type {number} number of literal and length codes. */
  var hlit;
  /** @type {number} number of distance codes. */
  var hdist;
  /** @type {number} number of code lengths. */
  var hclen;
  /** @type {!(Uint8Array|Array)} code lengths. */
  var codeLengths =
    new (Uint8Array)(Zlib$2.RawInflateStream.Order.length);
  /** @type {!Array} code lengths table. */
  var codeLengthsTable;

  this.status = Zlib$2.RawInflateStream.Status.BLOCK_BODY_START;

  this.save_();
  hlit = this.readBits(5) + 257;
  hdist = this.readBits(5) + 1;
  hclen = this.readBits(4) + 4;
  if (hlit < 0 || hdist < 0 || hclen < 0) {
    this.restore_();
    return -1;
  }

  try {
    parseDynamicHuffmanBlockImpl.call(this);
  } catch (e) {
    this.restore_();
    return -1;
  }

  function parseDynamicHuffmanBlockImpl() {
    /** @type {number} */
    var bits;
    var code;
    var prev = 0;
    var repeat;
    /** @type {!(Uint8Array|Array.<number>)} code length table. */
    var lengthTable;
    /** @type {number} loop counter. */
    var i;
    /** @type {number} loop limit. */
    var il;

    // decode code lengths
    for (i = 0; i < hclen; ++i) {
      if ((bits = this.readBits(3)) < 0) {
        throw new Error('not enough input');
      }
      codeLengths[Zlib$2.RawInflateStream.Order[i]] = bits;
    }

    // decode length table
    codeLengthsTable = buildHuffmanTable$2(codeLengths);
    lengthTable = new (Uint8Array)(hlit + hdist);
    for (i = 0, il = hlit + hdist; i < il;) {
      code = this.readCodeByTable(codeLengthsTable);
      if (code < 0) {
        throw new Error('not enough input');
      }
      switch (code) {
        case 16:
          if ((bits = this.readBits(2)) < 0) {
            throw new Error('not enough input');
          }
          repeat = 3 + bits;
          while (repeat--) { lengthTable[i++] = prev; }
          break;
        case 17:
          if ((bits = this.readBits(3)) < 0) {
            throw new Error('not enough input');
          }
          repeat = 3 + bits;
          while (repeat--) { lengthTable[i++] = 0; }
          prev = 0;
          break;
        case 18:
          if ((bits = this.readBits(7)) < 0) {
            throw new Error('not enough input');
          }
          repeat = 11 + bits;
          while (repeat--) { lengthTable[i++] = 0; }
          prev = 0;
          break;
        default:
          lengthTable[i++] = code;
          prev = code;
          break;
      }
    }

    this.litlenTable = buildHuffmanTable$2(lengthTable.subarray(0, hlit))
      ;
    this.distTable = buildHuffmanTable$2(lengthTable.subarray(hlit))
      ;
  }

  this.status = Zlib$2.RawInflateStream.Status.BLOCK_BODY_END;

  return 0;
};

/**
* decode huffman code (dynamic)
* @return {(number|undefined)} -1 is error.
*/
Zlib$2.RawInflateStream.prototype.decodeHuffman = function () {
  var output = this.output;
  var op = this.op;

  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  var litlen = this.litlenTable;
  var dist = this.distTable;

  var olength = output.length;
  var bits;

  this.status = Zlib$2.RawInflateStream.Status.DECODE_BLOCK_START;

  while (true) {
    this.save_();

    code = this.readCodeByTable(litlen);
    if (code < 0) {
      this.op = op;
      this.restore_();
      return -1;
    }

    if (code === 256) {
      break;
    }

    // literal
    if (code < 256) {
      if (op === olength) {
        output = this.expandBuffer();
        olength = output.length;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = Zlib$2.RawInflateStream.LengthCodeTable[ti];
    if (Zlib$2.RawInflateStream.LengthExtraTable[ti] > 0) {
      bits = this.readBits(Zlib$2.RawInflateStream.LengthExtraTable[ti]);
      if (bits < 0) {
        this.op = op;
        this.restore_();
        return -1;
      }
      codeLength += bits;
    }

    // dist code
    code = this.readCodeByTable(dist);
    if (code < 0) {
      this.op = op;
      this.restore_();
      return -1;
    }
    codeDist = Zlib$2.RawInflateStream.DistCodeTable[code];
    if (Zlib$2.RawInflateStream.DistExtraTable[code] > 0) {
      bits = this.readBits(Zlib$2.RawInflateStream.DistExtraTable[code]);
      if (bits < 0) {
        this.op = op;
        this.restore_();
        return -1;
      }
      codeDist += bits;
    }

    // lz77 decode
    if (op + codeLength >= olength) {
      output = this.expandBuffer();
      olength = output.length;
    }

    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }

    // break
    if (this.ip === this.input.length) {
      this.op = op;
      return -1;
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }

  this.op = op;
  this.status = Zlib$2.RawInflateStream.Status.DECODE_BLOCK_END;
};

/**
* expand output buffer. (dynamic)
* @param {Object=} opt_param option parameters.
* @return {!(Array|Uint8Array)} output buffer pointer.
*/
Zlib$2.RawInflateStream.prototype.expandBuffer = function (opt_param) {
  /** @type {!(Array|Uint8Array)} store buffer. */
  var buffer;
  /** @type {number} expantion ratio. */
  var ratio = (this.input.length / this.ip + 1) | 0;
  /** @type {number} maximum number of huffman code. */
  var maxHuffCode;
  /** @type {number} new output buffer size. */
  var newSize;
  /** @type {number} max inflate size. */
  var maxInflateSize;

  var input = this.input;
  var output = this.output;

  if (opt_param) {
    if (typeof opt_param.fixRatio === 'number') {
      ratio = opt_param.fixRatio;
    }
    if (typeof opt_param.addRatio === 'number') {
      ratio += opt_param.addRatio;
    }
  }

  // calculate new buffer size
  if (ratio < 2) {
    maxHuffCode =
      (input.length - this.ip) / this.litlenTable[2];
    maxInflateSize = (maxHuffCode / 2 * 258) | 0;
    newSize = maxInflateSize < output.length ?
      output.length + maxInflateSize :
      output.length << 1;
  } else {
    newSize = output.length * ratio;
  }

  // buffer expantion
  {
    buffer = new Uint8Array(newSize);
    buffer.set(output);
  }

  this.output = buffer;

  return this.output;
};

/**
* concat output buffer. (dynamic)
* @return {!(Array|Uint8Array)} output buffer.
*/
Zlib$2.RawInflateStream.prototype.concatBuffer = function () {
  /** @type {!(Array|Uint8Array)} output buffer. */
  var buffer;
  /** @type {number} */
  var op = this.op;
  /** @type {Uint8Array} */
  var tmp;

  if (this.resize) {
    {
      buffer = new Uint8Array(this.output.subarray(this.sp, op));
    }
  } else {
    buffer =
      this.output.subarray(this.sp, op);
  }

  this.sp = op;

  // compaction
  if (op > Zlib$2.RawInflateStream.MaxBackwardLength + this.bufferSize) {
    this.op = this.sp = Zlib$2.RawInflateStream.MaxBackwardLength;
    {
      tmp = /** @type {Uint8Array} */(this.output);
      this.output = new Uint8Array(this.bufferSize + Zlib$2.RawInflateStream.MaxBackwardLength);
      this.output.set(tmp.subarray(op - Zlib$2.RawInflateStream.MaxBackwardLength, op));
    }
  }

  return buffer;
};


/**
* @constructor
* @param {!(Uint8Array|Array)} input deflated buffer.
* @param {Object=} opt_params option parameters.
*
* opt_params は以下のプロパティを指定する事ができます。
*   - index: input buffer の deflate コンテナの開始位置.
*   - blockSize: バッファのブロックサイズ.
*   - verify: 伸張が終わった後 adler-32 checksum の検証を行うか.
*   - bufferType: Zlib.Inflate.BufferType の値によってバッファの管理方法を指定する.
*       Zlib.Inflate.BufferType は Zlib.RawInflate.BufferType のエイリアス.
*/
Zlib$2.Inflate = function (input, opt_params) {
  /** @type {number} */
  var cmf;
  /** @type {number} */
  var flg;

  /** @type {!(Uint8Array|Array)} */
  this.input = input;
  /** @type {number} */
  this.ip = 0;
  /** @type {Zlib.RawInflate} */
  this.rawinflate;
  /** @type {(boolean|undefined)} verify flag. */
  this.verify;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (opt_params['index']) {
      this.ip = opt_params['index'];
    }
    if (opt_params['verify']) {
      this.verify = opt_params['verify'];
    }
  }

  // Compression Method and Flags
  cmf = input[this.ip++];
  flg = input[this.ip++];

  // compression method
  switch (cmf & 0x0f) {
    case Zlib$2.CompressionMethod.DEFLATE:
      this.method = Zlib$2.CompressionMethod.DEFLATE;
      break;
    default:
      throw new Error('unsupported compression method');
  }

  // fcheck
  if (((cmf << 8) + flg) % 31 !== 0) {
    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
  }

  // fdict (not supported)
  if (flg & 0x20) {
    throw new Error('fdict flag is not supported');
  }

  // RawInflate
  this.rawinflate = new Zlib$2.RawInflate(input, {
    'index': this.ip,
    'bufferSize': opt_params['bufferSize'],
    'bufferType': opt_params['bufferType'],
    'resize': opt_params['resize']
  });
};

/**
* @enum {number}
*/
Zlib$2.Inflate.BufferType = Zlib$2.RawInflate.BufferType;

/**
* decompress.
* @return {!(Uint8Array|Array)} inflated buffer.
*/
Zlib$2.Inflate.prototype.decompress = function () {
  /** @type {!(Array|Uint8Array)} input buffer. */
  var input = this.input;
  /** @type {!(Uint8Array|Array)} inflated buffer. */
  var buffer;
  /** @type {number} adler-32 checksum */
  var adler32;

  buffer = this.rawinflate.decompress();
  this.ip = this.rawinflate.ip;

  // verify adler-32
  if (this.verify) {
    adler32 = (
      input[this.ip++] << 24 | input[this.ip++] << 16 |
      input[this.ip++] << 8 | input[this.ip++]
    ) >>> 0;

    if (adler32 !== Zlib$2.Adler32(buffer)) {
      throw new Error('invalid adler-32 checksum');
    }
  }

  return buffer;
};


/* vim:set expandtab ts=2 sw=2 tw=80: */


/**
* @param {!(Uint8Array|Array)} input deflated buffer.
* @constructor
*/
Zlib$2.InflateStream = function (input) {
  /** @type {!(Uint8Array|Array)} */
  this.input = input === void 0 ? new (Uint8Array)() : input;
  /** @type {number} */
  this.ip = 0;
  /** @type {Zlib.RawInflateStream} */
  this.rawinflate = new Zlib$2.RawInflateStream(this.input, this.ip);
  /** @type {Zlib.CompressionMethod} */
  this.method;
  /** @type {!(Array|Uint8Array)} */
  this.output = this.rawinflate.output;
};

/**
* decompress.
* @return {!(Uint8Array|Array)} inflated buffer.
*/
Zlib$2.InflateStream.prototype.decompress = function (input) {
  /** @type {!(Uint8Array|Array)} inflated buffer. */
  var buffer;

  // 新しい入力を入力バッファに結合する
  // XXX Array, Uint8Array のチェックを行うか確認する
  if (input !== void 0) {
    {
      var tmp = new Uint8Array(this.input.length + input.length);
      tmp.set(this.input, 0);
      tmp.set(input, this.input.length);
      this.input = tmp;
    }
  }

  if (this.method === void 0) {
    if (this.readHeader() < 0) {
      return new (Uint8Array)();
    }
  }

  buffer = this.rawinflate.decompress(this.input, this.ip);
  if (this.rawinflate.ip !== 0) {
    this.input = this.input.subarray(this.rawinflate.ip);
    this.ip = 0;
  }

  // verify adler-32
  /*
  if (this.verify) {
    adler32 =
      input[this.ip++] << 24 | input[this.ip++] << 16 |
      input[this.ip++] << 8 | input[this.ip++];
  
    if (adler32 !== Zlib.Adler32(buffer)) {
      throw new Error('invalid adler-32 checksum');
    }
  }
  */

  return buffer;
};

Zlib$2.InflateStream.prototype.readHeader = function () {
  var ip = this.ip;
  var input = this.input;

  // Compression Method and Flags
  var cmf = input[ip++];
  var flg = input[ip++];

  if (cmf === void 0 || flg === void 0) {
    return -1;
  }

  // compression method
  switch (cmf & 0x0f) {
    case Zlib$2.CompressionMethod.DEFLATE:
      this.method = Zlib$2.CompressionMethod.DEFLATE;
      break;
    default:
      throw new Error('unsupported compression method');
  }

  // fcheck
  if (((cmf << 8) + flg) % 31 !== 0) {
    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
  }

  // fdict (not supported)
  if (flg & 0x20) {
    throw new Error('fdict flag is not supported');
  }

  this.ip = ip;
};


/**
* @fileoverview GZIP (RFC1952) 展開コンテナ実装.
*/

/**
* @constructor
* @param {!(Array|Uint8Array)} input input buffer.
* @param {Object=} opt_params option parameters.
*/
Zlib$2.Gunzip = function (input, opt_params) {
  /** @type {!(Array.<number>|Uint8Array)} input buffer. */
  this.input = input;
  /** @type {number} input buffer pointer. */
  this.ip = 0;
  /** @type {Array.<Zlib.GunzipMember>} */
  this.member = [];
  /** @type {boolean} */
  this.decompressed = false;
};

/**
* @return {Array.<Zlib.GunzipMember>}
*/
Zlib$2.Gunzip.prototype.getMembers = function () {
  if (!this.decompressed) {
    this.decompress();
  }

  return this.member.slice();
};

/**
* inflate gzip data.
* @return {!(Array.<number>|Uint8Array)} inflated buffer.
*/
Zlib$2.Gunzip.prototype.decompress = function () {
  /** @type {number} input length. */
  var il = this.input.length;

  while (this.ip < il) {
    this.decodeMember();
  }

  this.decompressed = true;

  return this.concatMember();
};

/**
* decode gzip member.
*/
Zlib$2.Gunzip.prototype.decodeMember = function () {
  /** @type {Zlib.GunzipMember} */
  var member = new Zlib$2.GunzipMember();
  /** @type {number} */
  var isize;
  /** @type {Zlib.RawInflate} RawInflate implementation. */
  var rawinflate;
  /** @type {!(Array.<number>|Uint8Array)} inflated data. */
  var inflated;
  /** @type {number} inflate size */
  var inflen;
  /** @type {number} character code */
  var c;
  /** @type {number} character index in string. */
  var ci;
  /** @type {Array.<string>} character array. */
  var str;
  /** @type {number} modification time. */
  var mtime;
  /** @type {number} */
  var crc32;

  var input = this.input;
  var ip = this.ip;

  member.id1 = input[ip++];
  member.id2 = input[ip++];

  // check signature
  if (member.id1 !== 0x1f || member.id2 !== 0x8b) {
    throw new Error('invalid file signature:' + member.id1 + ',' + member.id2);
  }

  // check compression method
  member.cm = input[ip++];
  switch (member.cm) {
    case 8: /* XXX: use Zlib const */
      break;
    default:
      throw new Error('unknown compression method: ' + member.cm);
  }

  // flags
  member.flg = input[ip++];

  // modification time
  mtime = (input[ip++]) |
    (input[ip++] << 8) |
    (input[ip++] << 16) |
    (input[ip++] << 24);
  member.mtime = new Date(mtime * 1000);

  // extra flags
  member.xfl = input[ip++];

  // operating system
  member.os = input[ip++];

  // extra
  if ((member.flg & Zlib$2.Gzip.FlagsMask.FEXTRA) > 0) {
    member.xlen = input[ip++] | (input[ip++] << 8);
    ip = this.decodeSubField(ip, member.xlen);
  }

  // fname
  if ((member.flg & Zlib$2.Gzip.FlagsMask.FNAME) > 0) {
    for (str = [], ci = 0; (c = input[ip++]) > 0;) {
      str[ci++] = String.fromCharCode(c);
    }
    member.name = str.join('');
  }

  // fcomment
  if ((member.flg & Zlib$2.Gzip.FlagsMask.FCOMMENT) > 0) {
    for (str = [], ci = 0; (c = input[ip++]) > 0;) {
      str[ci++] = String.fromCharCode(c);
    }
    member.comment = str.join('');
  }

  // fhcrc
  if ((member.flg & Zlib$2.Gzip.FlagsMask.FHCRC) > 0) {
    member.crc16 = Zlib$2.CRC32.calc(input, 0, ip) & 0xffff;
    if (member.crc16 !== (input[ip++] | (input[ip++] << 8))) {
      throw new Error('invalid header crc16');
    }
  }

  // isize を事前に取得すると展開後のサイズが分かるため、
  // inflate処理のバッファサイズが事前に分かり、高速になる
  isize = (input[input.length - 4]) | (input[input.length - 3] << 8) |
    (input[input.length - 2] << 16) | (input[input.length - 1] << 24);

  // isize の妥当性チェック
  // ハフマン符号では最小 2-bit のため、最大で 1/4 になる
  // LZ77 符号では 長さと距離 2-Byte で最大 258-Byte を表現できるため、
  // 1/128 になるとする
  // ここから入力バッファの残りが isize の 512 倍以上だったら
  // サイズ指定のバッファ確保は行わない事とする
  if (input.length - ip - /* CRC-32 */4 - /* ISIZE */4 < isize * 512) {
    inflen = isize;
  }

  // compressed block
  rawinflate = new Zlib$2.RawInflate(input, { 'index': ip, 'bufferSize': inflen });
  member.data = inflated = rawinflate.decompress();
  ip = rawinflate.ip;

  // crc32
  member.crc32 = crc32 =
    ((input[ip++]) | (input[ip++] << 8) |
      (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;
  if (Zlib$2.CRC32.calc(inflated) !== crc32) {
    throw new Error('invalid CRC-32 checksum: 0x' +
      Zlib$2.CRC32.calc(inflated).toString(16) + ' / 0x' + crc32.toString(16));
  }

  // input size
  member.isize = isize =
    ((input[ip++]) | (input[ip++] << 8) |
      (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;
  if ((inflated.length & 0xffffffff) !== isize) {
    throw new Error('invalid input size: ' +
      (inflated.length & 0xffffffff) + ' / ' + isize);
  }

  this.member.push(member);
  this.ip = ip;
};

/**
* サブフィールドのデコード
* XXX: 現在は何もせずスキップする
*/
Zlib$2.Gunzip.prototype.decodeSubField = function (ip, length) {
  return ip + length;
};

/**
* @return {!(Array.<number>|Uint8Array)}
*/
Zlib$2.Gunzip.prototype.concatMember = function () {
  /** @type {Array.<Zlib.GunzipMember>} */
  var member = this.member;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;
  /** @type {number} */
  var p = 0;
  /** @type {number} */
  var size = 0;
  /** @type {!(Array.<number>|Uint8Array)} */
  var buffer;

  for (i = 0, il = member.length; i < il; ++i) {
    size += member[i].data.length;
  }

  {
    buffer = new Uint8Array(size);
    for (i = 0; i < il; ++i) {
      buffer.set(member[i].data, p);
      p += member[i].data.length;
    }
  }

  return buffer;
};



/**
* @constructor
*/
Zlib$2.GunzipMember = function () {
  /** @type {number} signature first byte. */
  this.id1;
  /** @type {number} signature second byte. */
  this.id2;
  /** @type {number} compression method. */
  this.cm;
  /** @type {number} flags. */
  this.flg;
  /** @type {Date} modification time. */
  this.mtime;
  /** @type {number} extra flags. */
  this.xfl;
  /** @type {number} operating system number. */
  this.os;
  /** @type {number} CRC-16 value for FHCRC flag. */
  this.crc16;
  /** @type {number} extra length. */
  this.xlen;
  /** @type {number} CRC-32 value for verification. */
  this.crc32;
  /** @type {number} input size modulo 32 value. */
  this.isize;
  /** @type {string} filename. */
  this.name;
  /** @type {string} comment. */
  this.comment;
  /** @type {!(Uint8Array|Array.<number>)} */
  this.data;
};

Zlib$2.GunzipMember.prototype.getName = function () {
  return this.name;
};

Zlib$2.GunzipMember.prototype.getData = function () {
  return this.data;
};

Zlib$2.GunzipMember.prototype.getMtime = function () {
  return this.mtime;
};

/**
* @fileoverview GZIP (RFC1952) 実装.
*/

/**
* @constructor
* @param {!(Array|Uint8Array)} input input buffer.
* @param {Object=} opt_params option parameters.
*/
Zlib$2.Gzip = function (input, opt_params) {
  /** @type {!(Array.<number>|Uint8Array)} input buffer. */
  this.input = input;
  /** @type {number} input buffer pointer. */
  this.ip = 0;
  /** @type {!(Array.<number>|Uint8Array)} output buffer. */
  this.output;
  /** @type {number} output buffer. */
  this.op = 0;
  /** @type {!Object} flags option flags. */
  this.flags = {};
  /** @type {!string} filename. */
  this.filename;
  /** @type {!string} comment. */
  this.comment;
  /** @type {!Object} deflate options. */
  this.deflateOptions;

  // option parameters
  if (opt_params) {
    if (opt_params['flags']) {
      this.flags = opt_params['flags'];
    }
    if (typeof opt_params['filename'] === 'string') {
      this.filename = opt_params['filename'];
    }
    if (typeof opt_params['comment'] === 'string') {
      this.comment = opt_params['comment'];
    }
    if (opt_params['deflateOptions']) {
      this.deflateOptions = opt_params['deflateOptions'];
    }
  }

  if (!this.deflateOptions) {
    this.deflateOptions = {};
  }
};

/**
* @type {number}
* @const
*/
Zlib$2.Gzip.DefaultBufferSize = 0x8000;

/**
* encode gzip members.
* @return {!(Array|Uint8Array)} gzip binary array.
*/
Zlib$2.Gzip.prototype.compress = function () {
  /** @type {number} flags. */
  var flg;
  /** @type {number} modification time. */
  var mtime;
  /** @type {number} CRC-16 value for FHCRC flag. */
  var crc16;
  /** @type {number} CRC-32 value for verification. */
  var crc32;
  /** @type {!Zlib.RawDeflate} raw deflate object. */
  var rawdeflate;
  /** @type {number} character code */
  var c;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limiter. */
  var il;
  /** @type {!(Array|Uint8Array)} output buffer. */
  var output =
    new (Uint8Array)(Zlib$2.Gzip.DefaultBufferSize);
  /** @type {number} output buffer pointer. */
  var op = 0;

  var input = this.input;
  var ip = this.ip;
  var filename = this.filename;
  var comment = this.comment;

  // check signature
  output[op++] = 0x1f;
  output[op++] = 0x8b;

  // check compression method
  output[op++] = 8; /* XXX: use Zlib const */

  // flags
  flg = 0;
  if (this.flags['fname']) flg |= Zlib$2.Gzip.FlagsMask.FNAME;
  if (this.flags['fcomment']) flg |= Zlib$2.Gzip.FlagsMask.FCOMMENT;
  if (this.flags['fhcrc']) flg |= Zlib$2.Gzip.FlagsMask.FHCRC;
  // XXX: FTEXT
  // XXX: FEXTRA
  output[op++] = flg;

  // modification time
  mtime = (Date.now ? Date.now() : +new Date()) / 1000 | 0;
  output[op++] = mtime & 0xff;
  output[op++] = mtime >>> 8 & 0xff;
  output[op++] = mtime >>> 16 & 0xff;
  output[op++] = mtime >>> 24 & 0xff;

  // extra flags
  output[op++] = 0;

  // operating system
  output[op++] = Zlib$2.Gzip.OperatingSystem.UNKNOWN;

  // extra
  /* NOP */

  // fname
  if (this.flags['fname'] !== void 0) {
    for (i = 0, il = filename.length; i < il; ++i) {
      c = filename.charCodeAt(i);
      if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }
      output[op++] = c & 0xff;
    }
    output[op++] = 0; // null termination
  }

  // fcomment
  if (this.flags['comment']) {
    for (i = 0, il = comment.length; i < il; ++i) {
      c = comment.charCodeAt(i);
      if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }
      output[op++] = c & 0xff;
    }
    output[op++] = 0; // null termination
  }

  // fhcrc
  if (this.flags['fhcrc']) {
    crc16 = Zlib$2.CRC32.calc(output, 0, op) & 0xffff;
    output[op++] = (crc16) & 0xff;
    output[op++] = (crc16 >>> 8) & 0xff;
  }

  // add compress option
  this.deflateOptions['outputBuffer'] = output;
  this.deflateOptions['outputIndex'] = op;

  // compress
  rawdeflate = new Zlib$2.RawDeflate(input, this.deflateOptions);
  output = rawdeflate.compress();
  op = rawdeflate.op;

  // expand buffer
  {
    if (op + 8 > output.buffer.byteLength) {
      this.output = new Uint8Array(op + 8);
      this.output.set(new Uint8Array(output.buffer));
      output = this.output;
    } else {
      output = new Uint8Array(output.buffer);
    }
  }

  // crc32
  crc32 = Zlib$2.CRC32.calc(input);
  output[op++] = (crc32) & 0xff;
  output[op++] = (crc32 >>> 8) & 0xff;
  output[op++] = (crc32 >>> 16) & 0xff;
  output[op++] = (crc32 >>> 24) & 0xff;

  // input size
  il = input.length;
  output[op++] = (il) & 0xff;
  output[op++] = (il >>> 8) & 0xff;
  output[op++] = (il >>> 16) & 0xff;
  output[op++] = (il >>> 24) & 0xff;

  this.ip = ip;

  if (op < output.length) {
    this.output = output = output.subarray(0, op);
  }

  return output;
};

/** @enum {number} */
Zlib$2.Gzip.OperatingSystem = {
  FAT: 0,
  AMIGA: 1,
  VMS: 2,
  UNIX: 3,
  VM_CMS: 4,
  ATARI_TOS: 5,
  HPFS: 6,
  MACINTOSH: 7,
  Z_SYSTEM: 8,
  CP_M: 9,
  TOPS_20: 10,
  NTFS: 11,
  QDOS: 12,
  ACORN_RISCOS: 13,
  UNKNOWN: 255
};

/** @enum {number} */
Zlib$2.Gzip.FlagsMask = {
  FTEXT: 0x01,
  FHCRC: 0x02,
  FEXTRA: 0x04,
  FNAME: 0x08,
  FCOMMENT: 0x10
};


/**
* @fileoverview Heap Sort 実装. ハフマン符号化で使用する.
*/

/**
* カスタムハフマン符号で使用するヒープ実装
* @param {number} length ヒープサイズ.
* @constructor
*/
Zlib$2.Heap = function (length) {
  this.buffer = new (Uint16Array)(length * 2);
  this.length = 0;
};

/**
* 親ノードの index 取得
* @param {number} index 子ノードの index.
* @return {number} 親ノードの index.
*
*/
Zlib$2.Heap.prototype.getParent = function (index) {
  return ((index - 2) / 4 | 0) * 2;
};

/**
* 子ノードの index 取得
* @param {number} index 親ノードの index.
* @return {number} 子ノードの index.
*/
Zlib$2.Heap.prototype.getChild = function (index) {
  return 2 * index + 2;
};

/**
* Heap に値を追加する
* @param {number} index キー index.
* @param {number} value 値.
* @return {number} 現在のヒープ長.
*/
Zlib$2.Heap.prototype.push = function (index, value) {
  var current, parent,
    heap = this.buffer,
    swap;

  current = this.length;
  heap[this.length++] = value;
  heap[this.length++] = index;

  // ルートノードにたどり着くまで入れ替えを試みる
  while (current > 0) {
    parent = this.getParent(current);

    // 親ノードと比較して親の方が小さければ入れ替える
    if (heap[current] > heap[parent]) {
      swap = heap[current];
      heap[current] = heap[parent];
      heap[parent] = swap;

      swap = heap[current + 1];
      heap[current + 1] = heap[parent + 1];
      heap[parent + 1] = swap;

      current = parent;
      // 入れ替えが必要なくなったらそこで抜ける
    } else {
      break;
    }
  }

  return this.length;
};

/**
* Heapから一番大きい値を返す
* @return {{index: number, value: number, length: number}} {index: キーindex,
*     value: 値, length: ヒープ長} の Object.
*/
Zlib$2.Heap.prototype.pop = function () {
  var index, value,
    heap = this.buffer, swap,
    current, parent;

  value = heap[0];
  index = heap[1];

  // 後ろから値を取る
  this.length -= 2;
  heap[0] = heap[this.length];
  heap[1] = heap[this.length + 1];

  parent = 0;
  // ルートノードから下がっていく
  while (true) {
    current = this.getChild(parent);

    // 範囲チェック
    if (current >= this.length) {
      break;
    }

    // 隣のノードと比較して、隣の方が値が大きければ隣を現在ノードとして選択
    if (current + 2 < this.length && heap[current + 2] > heap[current]) {
      current += 2;
    }

    // 親ノードと比較して親の方が小さい場合は入れ替える
    if (heap[current] > heap[parent]) {
      swap = heap[parent];
      heap[parent] = heap[current];
      heap[current] = swap;

      swap = heap[parent + 1];
      heap[parent + 1] = heap[current + 1];
      heap[current + 1] = swap;
    } else {
      break;
    }

    parent = current;
  }

  return { index: index, value: value, length: this.length };
};


/* vim:set expandtab ts=2 sw=2 tw=80: */

/**
* @fileoverview Deflate (RFC1951) 符号化アルゴリズム実装.
*/


/**
* Raw Deflate 実装
*
* @constructor
* @param {!(Array.<number>|Uint8Array)} input 符号化する対象のバッファ.
* @param {Object=} opt_params option parameters.
*
* typed array が使用可能なとき、outputBuffer が Array は自動的に Uint8Array に
* 変換されます.
* 別のオブジェクトになるため出力バッファを参照している変数などは
* 更新する必要があります.
*/
Zlib$2.RawDeflate = function (input, opt_params) {
  /** @type {Zlib.RawDeflate.CompressionType} */
  this.compressionType = Zlib$2.RawDeflate.CompressionType.DYNAMIC;
  /** @type {number} */
  this.lazy = 0;
  /** @type {!(Array.<number>|Uint32Array)} */
  this.freqsLitLen;
  /** @type {!(Array.<number>|Uint32Array)} */
  this.freqsDist;
  /** @type {!(Array.<number>|Uint8Array)} */
  this.input =
    (input instanceof Array) ? new Uint8Array(input) : input;
  /** @type {!(Array.<number>|Uint8Array)} output output buffer. */
  this.output;
  /** @type {number} pos output buffer position. */
  this.op = 0;

  // option parameters
  if (opt_params) {
    if (opt_params['lazy']) {
      this.lazy = opt_params['lazy'];
    }
    if (typeof opt_params['compressionType'] === 'number') {
      this.compressionType = opt_params['compressionType'];
    }
    if (opt_params['outputBuffer']) {
      this.output =
        (opt_params['outputBuffer'] instanceof Array) ?
          new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];
    }
    if (typeof opt_params['outputIndex'] === 'number') {
      this.op = opt_params['outputIndex'];
    }
  }

  if (!this.output) {
    this.output = new (Uint8Array)(0x8000);
  }
};

/**
* @enum {number}
*/
Zlib$2.RawDeflate.CompressionType = {
  NONE: 0,
  FIXED: 1,
  DYNAMIC: 2,
  RESERVED: 3
};


/**
* LZ77 の最小マッチ長
* @const
* @type {number}
*/
Zlib$2.RawDeflate.Lz77MinLength = 3;

/**
* LZ77 の最大マッチ長
* @const
* @type {number}
*/
Zlib$2.RawDeflate.Lz77MaxLength = 258;

/**
* LZ77 のウィンドウサイズ
* @const
* @type {number}
*/
Zlib$2.RawDeflate.WindowSize = 0x8000;

/**
* 最長の符号長
* @const
* @type {number}
*/
Zlib$2.RawDeflate.MaxCodeLength = 16;

/**
* ハフマン符号の最大数値
* @const
* @type {number}
*/
Zlib$2.RawDeflate.HUFMAX = 286;

/**
* 固定ハフマン符号の符号化テーブル
* @const
* @type {Array.<Array.<number, number>>}
*/
Zlib$2.RawDeflate.FixedHuffmanTable = (function () {
  var table = [], i;

  for (i = 0; i < 288; i++) {
    switch (true) {
      case (i <= 143): table.push([i + 0x030, 8]); break;
      case (i <= 255): table.push([i - 144 + 0x190, 9]); break;
      case (i <= 279): table.push([i - 256 + 0x000, 7]); break;
      case (i <= 287): table.push([i - 280 + 0x0C0, 8]); break;
      default:
        throw 'invalid literal: ' + i;
    }
  }

  return table;
})();

/**
* DEFLATE ブロックの作成
* @return {!(Array.<number>|Uint8Array)} 圧縮済み byte array.
*/
Zlib$2.RawDeflate.prototype.compress = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var blockArray;
  /** @type {number} */
  var position;
  /** @type {number} */
  var length;

  var input = this.input;

  // compression
  switch (this.compressionType) {
    case Zlib$2.RawDeflate.CompressionType.NONE:
      // each 65535-Byte (length header: 16-bit)
      for (position = 0, length = input.length; position < length;) {
        blockArray = input.subarray(position, position + 0xffff);
        position += blockArray.length;
        this.makeNocompressBlock(blockArray, (position === length));
      }
      break;
    case Zlib$2.RawDeflate.CompressionType.FIXED:
      this.output = this.makeFixedHuffmanBlock(input, true);
      this.op = this.output.length;
      break;
    case Zlib$2.RawDeflate.CompressionType.DYNAMIC:
      this.output = this.makeDynamicHuffmanBlock(input, true);
      this.op = this.output.length;
      break;
    default:
      throw 'invalid compression type';
  }

  return this.output;
};

/**
* 非圧縮ブロックの作成
* @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
* @param {!boolean} isFinalBlock 最後のブロックならばtrue.
* @return {!(Array.<number>|Uint8Array)} 非圧縮ブロック byte array.
*/
Zlib$2.RawDeflate.prototype.makeNocompressBlock =
  function (blockArray, isFinalBlock) {
    /** @type {number} */
    var bfinal;
    /** @type {Zlib.RawDeflate.CompressionType} */
    var btype;
    /** @type {number} */
    var len;
    /** @type {number} */
    var nlen;

    var output = this.output;
    var op = this.op;

    // expand buffer
    {
      output = new Uint8Array(this.output.buffer);
      while (output.length <= op + blockArray.length + 5) {
        output = new Uint8Array(output.length << 1);
      }
      output.set(this.output);
    }

    // header
    bfinal = isFinalBlock ? 1 : 0;
    btype = Zlib$2.RawDeflate.CompressionType.NONE;
    output[op++] = (bfinal) | (btype << 1);

    // length
    len = blockArray.length;
    nlen = (~len + 0x10000) & 0xffff;
    output[op++] = len & 0xff;
    output[op++] = (len >>> 8) & 0xff;
    output[op++] = nlen & 0xff;
    output[op++] = (nlen >>> 8) & 0xff;

    // copy buffer
    {
      output.set(blockArray, op);
      op += blockArray.length;
      output = output.subarray(0, op);
    }

    this.op = op;
    this.output = output;

    return output;
  };

/**
* 固定ハフマンブロックの作成
* @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
* @param {!boolean} isFinalBlock 最後のブロックならばtrue.
* @return {!(Array.<number>|Uint8Array)} 固定ハフマン符号化ブロック byte array.
*/
Zlib$2.RawDeflate.prototype.makeFixedHuffmanBlock =
  function (blockArray, isFinalBlock) {
    /** @type {Zlib.BitStream} */
    var stream = new Zlib$2.BitStream(new Uint8Array(this.output.buffer), this.op);
    /** @type {number} */
    var bfinal;
    /** @type {Zlib.RawDeflate.CompressionType} */
    var btype;
    /** @type {!(Array.<number>|Uint16Array)} */
    var data;

    // header
    bfinal = isFinalBlock ? 1 : 0;
    btype = Zlib$2.RawDeflate.CompressionType.FIXED;

    stream.writeBits(bfinal, 1, true);
    stream.writeBits(btype, 2, true);

    data = this.lz77(blockArray);
    this.fixedHuffman(data, stream);

    return stream.finish();
  };

/**
* 動的ハフマンブロックの作成
* @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
* @param {!boolean} isFinalBlock 最後のブロックならばtrue.
* @return {!(Array.<number>|Uint8Array)} 動的ハフマン符号ブロック byte array.
*/
Zlib$2.RawDeflate.prototype.makeDynamicHuffmanBlock =
  function (blockArray, isFinalBlock) {
    /** @type {Zlib.BitStream} */
    var stream = new Zlib$2.BitStream(new Uint8Array(this.output.buffer), this.op);
    /** @type {number} */
    var bfinal;
    /** @type {Zlib.RawDeflate.CompressionType} */
    var btype;
    /** @type {!(Array.<number>|Uint16Array)} */
    var data;
    /** @type {number} */
    var hlit;
    /** @type {number} */
    var hdist;
    /** @type {number} */
    var hclen;
    /** @const @type {Array.<number>} */
    var hclenOrder =
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    /** @type {!(Array.<number>|Uint8Array)} */
    var litLenLengths;
    /** @type {!(Array.<number>|Uint16Array)} */
    var litLenCodes;
    /** @type {!(Array.<number>|Uint8Array)} */
    var distLengths;
    /** @type {!(Array.<number>|Uint16Array)} */
    var distCodes;
    /** @type {{
     *   codes: !(Array.<number>|Uint32Array),
     *   freqs: !(Array.<number>|Uint8Array)
     * }} */
    var treeSymbols;
    /** @type {!(Array.<number>|Uint8Array)} */
    var treeLengths;
    /** @type {Array} */
    var transLengths = new Array(19);
    /** @type {!(Array.<number>|Uint16Array)} */
    var treeCodes;
    /** @type {number} */
    var code;
    /** @type {number} */
    var bitlen;
    /** @type {number} */
    var i;
    /** @type {number} */
    var il;

    // header
    bfinal = isFinalBlock ? 1 : 0;
    btype = Zlib$2.RawDeflate.CompressionType.DYNAMIC;

    stream.writeBits(bfinal, 1, true);
    stream.writeBits(btype, 2, true);

    data = this.lz77(blockArray);

    // リテラル・長さ, 距離のハフマン符号と符号長の算出
    litLenLengths = this.getLengths_(this.freqsLitLen, 15);
    litLenCodes = this.getCodesFromLengths_(litLenLengths);
    distLengths = this.getLengths_(this.freqsDist, 7);
    distCodes = this.getCodesFromLengths_(distLengths);

    // HLIT, HDIST の決定
    for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) { }
    for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) { }

    // HCLEN
    treeSymbols =
      this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);
    treeLengths = this.getLengths_(treeSymbols.freqs, 7);
    for (i = 0; i < 19; i++) {
      transLengths[i] = treeLengths[hclenOrder[i]];
    }
    for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) { }

    treeCodes = this.getCodesFromLengths_(treeLengths);

    // 出力
    stream.writeBits(hlit - 257, 5, true);
    stream.writeBits(hdist - 1, 5, true);
    stream.writeBits(hclen - 4, 4, true);
    for (i = 0; i < hclen; i++) {
      stream.writeBits(transLengths[i], 3, true);
    }

    // ツリーの出力
    for (i = 0, il = treeSymbols.codes.length; i < il; i++) {
      code = treeSymbols.codes[i];

      stream.writeBits(treeCodes[code], treeLengths[code], true);

      // extra bits
      if (code >= 16) {
        i++;
        switch (code) {
          case 16: bitlen = 2; break;
          case 17: bitlen = 3; break;
          case 18: bitlen = 7; break;
          default:
            throw 'invalid code: ' + code;
        }

        stream.writeBits(treeSymbols.codes[i], bitlen, true);
      }
    }

    this.dynamicHuffman(
      data,
      [litLenCodes, litLenLengths],
      [distCodes, distLengths],
      stream
    );

    return stream.finish();
  };


/**
* 動的ハフマン符号化(カスタムハフマンテーブル)
* @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
* @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
* @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
*/
Zlib$2.RawDeflate.prototype.dynamicHuffman =
  function (dataArray, litLen, dist, stream) {
    /** @type {number} */
    var index;
    /** @type {number} */
    var length;
    /** @type {number} */
    var literal;
    /** @type {number} */
    var code;
    /** @type {number} */
    var litLenCodes;
    /** @type {number} */
    var litLenLengths;
    /** @type {number} */
    var distCodes;
    /** @type {number} */
    var distLengths;

    litLenCodes = litLen[0];
    litLenLengths = litLen[1];
    distCodes = dist[0];
    distLengths = dist[1];

    // 符号を BitStream に書き込んでいく
    for (index = 0, length = dataArray.length; index < length; ++index) {
      literal = dataArray[index];

      // literal or length
      stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);

      // 長さ・距離符号
      if (literal > 256) {
        // length extra
        stream.writeBits(dataArray[++index], dataArray[++index], true);
        // distance
        code = dataArray[++index];
        stream.writeBits(distCodes[code], distLengths[code], true);
        // distance extra
        stream.writeBits(dataArray[++index], dataArray[++index], true);
        // 終端
      } else if (literal === 256) {
        break;
      }
    }

    return stream;
  };

/**
* 固定ハフマン符号化
* @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
* @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
* @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
*/
Zlib$2.RawDeflate.prototype.fixedHuffman = function (dataArray, stream) {
  /** @type {number} */
  var index;
  /** @type {number} */
  var length;
  /** @type {number} */
  var literal;

  // 符号を BitStream に書き込んでいく
  for (index = 0, length = dataArray.length; index < length; index++) {
    literal = dataArray[index];

    // 符号の書き込み
    Zlib$2.BitStream.prototype.writeBits.apply(
      stream,
      Zlib$2.RawDeflate.FixedHuffmanTable[literal]
    );

    // 長さ・距離符号
    if (literal > 0x100) {
      // length extra
      stream.writeBits(dataArray[++index], dataArray[++index], true);
      // distance
      stream.writeBits(dataArray[++index], 5);
      // distance extra
      stream.writeBits(dataArray[++index], dataArray[++index], true);
      // 終端
    } else if (literal === 0x100) {
      break;
    }
  }

  return stream;
};

/**
* マッチ情報
* @param {!number} length マッチした長さ.
* @param {!number} backwardDistance マッチ位置との距離.
* @constructor
*/
Zlib$2.RawDeflate.Lz77Match = function (length, backwardDistance) {
  /** @type {number} match length. */
  this.length = length;
  /** @type {number} backward distance. */
  this.backwardDistance = backwardDistance;
};

/**
* 長さ符号テーブル.
* [コード, 拡張ビット, 拡張ビット長] の配列となっている.
* @const
* @type {!(Array.<number>|Uint32Array)}
*/
Zlib$2.RawDeflate.Lz77Match.LengthCodeTable = (function (table) {
  return new Uint32Array(table);
})((function () {
  /** @type {!Array} */
  var table = [];
  /** @type {number} */
  var i;
  /** @type {!Array.<number>} */
  var c;

  for (i = 3; i <= 258; i++) {
    c = code(i);
    table[i] = (c[2] << 24) | (c[1] << 16) | c[0];
  }

  /**
   * @param {number} length lz77 length.
   * @return {!Array.<number>} lz77 codes.
   */
  function code(length) {
    switch (true) {
      case (length === 3): return [257, length - 3, 0]; case (length === 4): return [258, length - 4, 0]; case (length === 5): return [259, length - 5, 0]; case (length === 6): return [260, length - 6, 0]; case (length === 7): return [261, length - 7, 0]; case (length === 8): return [262, length - 8, 0]; case (length === 9): return [263, length - 9, 0]; case (length === 10): return [264, length - 10, 0]; case (length <= 12): return [265, length - 11, 1]; case (length <= 14): return [266, length - 13, 1]; case (length <= 16): return [267, length - 15, 1]; case (length <= 18): return [268, length - 17, 1]; case (length <= 22): return [269, length - 19, 2]; case (length <= 26): return [270, length - 23, 2]; case (length <= 30): return [271, length - 27, 2]; case (length <= 34): return [272, length - 31, 2]; case (length <= 42): return [273, length - 35, 3]; case (length <= 50): return [274, length - 43, 3]; case (length <= 58): return [275, length - 51, 3]; case (length <= 66): return [276, length - 59, 3]; case (length <= 82): return [277, length - 67, 4]; case (length <= 98): return [278, length - 83, 4]; case (length <= 114): return [279, length - 99, 4]; case (length <= 130): return [280, length - 115, 4]; case (length <= 162): return [281, length - 131, 5]; case (length <= 194): return [282, length - 163, 5]; case (length <= 226): return [283, length - 195, 5]; case (length <= 257): return [284, length - 227, 5]; case (length === 258): return [285, length - 258, 0]; default: throw 'invalid length: ' + length;
    }
  }

  return table;
})());

/**
* 距離符号テーブル
* @param {!number} dist 距離.
* @return {!Array.<number>} コード、拡張ビット、拡張ビット長の配列.
* @private
*/
Zlib$2.RawDeflate.Lz77Match.prototype.getDistanceCode_ = function (dist) {
  /** @type {!Array.<number>} distance code table. */
  var r;

  switch (true) {
    case (dist === 1): r = [0, dist - 1, 0]; break;
    case (dist === 2): r = [1, dist - 2, 0]; break;
    case (dist === 3): r = [2, dist - 3, 0]; break;
    case (dist === 4): r = [3, dist - 4, 0]; break;
    case (dist <= 6): r = [4, dist - 5, 1]; break;
    case (dist <= 8): r = [5, dist - 7, 1]; break;
    case (dist <= 12): r = [6, dist - 9, 2]; break;
    case (dist <= 16): r = [7, dist - 13, 2]; break;
    case (dist <= 24): r = [8, dist - 17, 3]; break;
    case (dist <= 32): r = [9, dist - 25, 3]; break;
    case (dist <= 48): r = [10, dist - 33, 4]; break;
    case (dist <= 64): r = [11, dist - 49, 4]; break;
    case (dist <= 96): r = [12, dist - 65, 5]; break;
    case (dist <= 128): r = [13, dist - 97, 5]; break;
    case (dist <= 192): r = [14, dist - 129, 6]; break;
    case (dist <= 256): r = [15, dist - 193, 6]; break;
    case (dist <= 384): r = [16, dist - 257, 7]; break;
    case (dist <= 512): r = [17, dist - 385, 7]; break;
    case (dist <= 768): r = [18, dist - 513, 8]; break;
    case (dist <= 1024): r = [19, dist - 769, 8]; break;
    case (dist <= 1536): r = [20, dist - 1025, 9]; break;
    case (dist <= 2048): r = [21, dist - 1537, 9]; break;
    case (dist <= 3072): r = [22, dist - 2049, 10]; break;
    case (dist <= 4096): r = [23, dist - 3073, 10]; break;
    case (dist <= 6144): r = [24, dist - 4097, 11]; break;
    case (dist <= 8192): r = [25, dist - 6145, 11]; break;
    case (dist <= 12288): r = [26, dist - 8193, 12]; break;
    case (dist <= 16384): r = [27, dist - 12289, 12]; break;
    case (dist <= 24576): r = [28, dist - 16385, 13]; break;
    case (dist <= 32768): r = [29, dist - 24577, 13]; break;
    default: throw 'invalid distance';
  }

  return r;
};

/**
* マッチ情報を LZ77 符号化配列で返す.
* なお、ここでは以下の内部仕様で符号化している
* [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]
* @return {!Array.<number>} LZ77 符号化 byte array.
*/
Zlib$2.RawDeflate.Lz77Match.prototype.toLz77Array = function () {
  /** @type {number} */
  var length = this.length;
  /** @type {number} */
  var dist = this.backwardDistance;
  /** @type {Array} */
  var codeArray = [];
  /** @type {number} */
  var pos = 0;
  /** @type {!Array.<number>} */
  var code;

  // length
  code = Zlib$2.RawDeflate.Lz77Match.LengthCodeTable[length];
  codeArray[pos++] = code & 0xffff;
  codeArray[pos++] = (code >> 16) & 0xff;
  codeArray[pos++] = code >> 24;

  // distance
  code = this.getDistanceCode_(dist);
  codeArray[pos++] = code[0];
  codeArray[pos++] = code[1];
  codeArray[pos++] = code[2];

  return codeArray;
};

/**
* LZ77 実装
* @param {!(Array.<number>|Uint8Array)} dataArray LZ77 符号化するバイト配列.
* @return {!(Array.<number>|Uint16Array)} LZ77 符号化した配列.
*/
Zlib$2.RawDeflate.prototype.lz77 = function (dataArray) {
  /** @type {number} input position */
  var position;
  /** @type {number} input length */
  var length;
  /** @type {number} loop counter */
  var i;
  /** @type {number} loop limiter */
  var il;
  /** @type {number} chained-hash-table key */
  var matchKey;
  /** @type {Object.<number, Array.<number>>} chained-hash-table */
  var table = {};
  /** @const @type {number} */
  var windowSize = Zlib$2.RawDeflate.WindowSize;
  /** @type {Array.<number>} match list */
  var matchList;
  /** @type {Zlib.RawDeflate.Lz77Match} longest match */
  var longestMatch;
  /** @type {Zlib.RawDeflate.Lz77Match} previous longest match */
  var prevMatch;
  /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */
  var lz77buf = new Uint16Array(dataArray.length * 2);
  /** @type {number} lz77 output buffer pointer */
  var pos = 0;
  /** @type {number} lz77 skip length */
  var skipLength = 0;
  /** @type {!(Array.<number>|Uint32Array)} */
  var freqsLitLen = new (Uint32Array)(286);
  /** @type {!(Array.<number>|Uint32Array)} */
  var freqsDist = new (Uint32Array)(30);
  /** @type {number} */
  var lazy = this.lazy;
  /** @type {*} temporary variable */
  var tmp;
  freqsLitLen[256] = 1; // EOB の最低出現回数は 1

  /**
   * マッチデータの書き込み
   * @param {Zlib.RawDeflate.Lz77Match} match LZ77 Match data.
   * @param {!number} offset スキップ開始位置(相対指定).
   * @private
   */
  function writeMatch(match, offset) {
    /** @type {Array.<number>} */
    var lz77Array = match.toLz77Array();
    /** @type {number} */
    var i;
    /** @type {number} */
    var il;

    for (i = 0, il = lz77Array.length; i < il; ++i) {
      lz77buf[pos++] = lz77Array[i];
    }
    freqsLitLen[lz77Array[0]]++;
    freqsDist[lz77Array[3]]++;
    skipLength = match.length + offset - 1;
    prevMatch = null;
  }

  // LZ77 符号化
  for (position = 0, length = dataArray.length; position < length; ++position) {
    // ハッシュキーの作成
    for (matchKey = 0, i = 0, il = Zlib$2.RawDeflate.Lz77MinLength; i < il; ++i) {
      if (position + i === length) {
        break;
      }
      matchKey = (matchKey << 8) | dataArray[position + i];
    }

    // テーブルが未定義だったら作成する
    if (table[matchKey] === void 0) { table[matchKey] = []; }
    matchList = table[matchKey];

    // skip
    if (skipLength-- > 0) {
      matchList.push(position);
      continue;
    }

    // マッチテーブルの更新 (最大戻り距離を超えているものを削除する)
    while (matchList.length > 0 && position - matchList[0] > windowSize) {
      matchList.shift();
    }

    // データ末尾でマッチしようがない場合はそのまま流しこむ
    if (position + Zlib$2.RawDeflate.Lz77MinLength >= length) {
      if (prevMatch) {
        writeMatch(prevMatch, -1);
      }

      for (i = 0, il = length - position; i < il; ++i) {
        tmp = dataArray[position + i];
        lz77buf[pos++] = tmp;
        ++freqsLitLen[tmp];
      }
      break;
    }

    // マッチ候補から最長のものを探す
    if (matchList.length > 0) {
      longestMatch = this.searchLongestMatch_(dataArray, position, matchList);

      if (prevMatch) {
        // 現在のマッチの方が前回のマッチよりも長い
        if (prevMatch.length < longestMatch.length) {
          // write previous literal
          tmp = dataArray[position - 1];
          lz77buf[pos++] = tmp;
          ++freqsLitLen[tmp];

          // write current match
          writeMatch(longestMatch, 0);
        } else {
          // write previous match
          writeMatch(prevMatch, -1);
        }
      } else if (longestMatch.length < lazy) {
        prevMatch = longestMatch;
      } else {
        writeMatch(longestMatch, 0);
      }
      // 前回マッチしていて今回マッチがなかったら前回のを採用
    } else if (prevMatch) {
      writeMatch(prevMatch, -1);
    } else {
      tmp = dataArray[position];
      lz77buf[pos++] = tmp;
      ++freqsLitLen[tmp];
    }

    matchList.push(position); // マッチテーブルに現在の位置を保存
  }

  // 終端処理
  lz77buf[pos++] = 256;
  freqsLitLen[256]++;
  this.freqsLitLen = freqsLitLen;
  this.freqsDist = freqsDist;

  return /** @type {!(Uint16Array|Array.<number>)} */ (
    lz77buf.subarray(0, pos)
  );
};

/**
* マッチした候補の中から最長一致を探す
* @param {!Object} data plain data byte array.
* @param {!number} position plain data byte array position.
* @param {!Array.<number>} matchList 候補となる位置の配列.
* @return {!Zlib.RawDeflate.Lz77Match} 最長かつ最短距離のマッチオブジェクト.
* @private
*/
Zlib$2.RawDeflate.prototype.searchLongestMatch_ =
  function (data, position, matchList) {
    var match,
      currentMatch,
      matchMax = 0, matchLength,
      i, j, l, dl = data.length;

    // 候補を後ろから 1 つずつ絞り込んでゆく
    permatch:
    for (i = 0, l = matchList.length; i < l; i++) {
      match = matchList[l - i - 1];
      matchLength = Zlib$2.RawDeflate.Lz77MinLength;

      // 前回までの最長一致を末尾から一致検索する
      if (matchMax > Zlib$2.RawDeflate.Lz77MinLength) {
        for (j = matchMax; j > Zlib$2.RawDeflate.Lz77MinLength; j--) {
          if (data[match + j - 1] !== data[position + j - 1]) {
            continue permatch;
          }
        }
        matchLength = matchMax;
      }

      // 最長一致探索
      while (matchLength < Zlib$2.RawDeflate.Lz77MaxLength &&
        position + matchLength < dl &&
        data[match + matchLength] === data[position + matchLength]) {
        ++matchLength;
      }

      // マッチ長が同じ場合は後方を優先
      if (matchLength > matchMax) {
        currentMatch = match;
        matchMax = matchLength;
      }

      // 最長が確定したら後の処理は省略
      if (matchLength === Zlib$2.RawDeflate.Lz77MaxLength) {
        break;
      }
    }

    return new Zlib$2.RawDeflate.Lz77Match(matchMax, position - currentMatch);
  };

/**
* Tree-Transmit Symbols の算出
* reference: PuTTY Deflate implementation
* @param {number} hlit HLIT.
* @param {!(Array.<number>|Uint8Array)} litlenLengths リテラルと長さ符号の符号長配列.
* @param {number} hdist HDIST.
* @param {!(Array.<number>|Uint8Array)} distLengths 距離符号の符号長配列.
* @return {{
*   codes: !(Array.<number>|Uint32Array),
*   freqs: !(Array.<number>|Uint8Array)
* }} Tree-Transmit Symbols.
*/
Zlib$2.RawDeflate.prototype.getTreeSymbols_ =
  function (hlit, litlenLengths, hdist, distLengths) {
    var src = new (Uint32Array)(hlit + hdist),
      i, j, runLength, l,
      result = new (Uint32Array)(286 + 30),
      nResult,
      rpt,
      freqs = new (Uint8Array)(19);

    j = 0;
    for (i = 0; i < hlit; i++) {
      src[j++] = litlenLengths[i];
    }
    for (i = 0; i < hdist; i++) {
      src[j++] = distLengths[i];
    }

    // 符号化
    nResult = 0;
    for (i = 0, l = src.length; i < l; i += j) {
      // Run Length Encoding
      for (j = 1; i + j < l && src[i + j] === src[i]; ++j) { }

      runLength = j;

      if (src[i] === 0) {
        // 0 の繰り返しが 3 回未満ならばそのまま
        if (runLength < 3) {
          while (runLength-- > 0) {
            result[nResult++] = 0;
            freqs[0]++;
          }
        } else {
          while (runLength > 0) {
            // 繰り返しは最大 138 までなので切り詰める
            rpt = (runLength < 138 ? runLength : 138);

            if (rpt > runLength - 3 && rpt < runLength) {
              rpt = runLength - 3;
            }

            // 3-10 回 -> 17
            if (rpt <= 10) {
              result[nResult++] = 17;
              result[nResult++] = rpt - 3;
              freqs[17]++;
              // 11-138 回 -> 18
            } else {
              result[nResult++] = 18;
              result[nResult++] = rpt - 11;
              freqs[18]++;
            }

            runLength -= rpt;
          }
        }
      } else {
        result[nResult++] = src[i];
        freqs[src[i]]++;
        runLength--;

        // 繰り返し回数が3回未満ならばランレングス符号は要らない
        if (runLength < 3) {
          while (runLength-- > 0) {
            result[nResult++] = src[i];
            freqs[src[i]]++;
          }
          // 3 回以上ならばランレングス符号化
        } else {
          while (runLength > 0) {
            // runLengthを 3-6 で分割
            rpt = (runLength < 6 ? runLength : 6);

            if (rpt > runLength - 3 && rpt < runLength) {
              rpt = runLength - 3;
            }

            result[nResult++] = 16;
            result[nResult++] = rpt - 3;
            freqs[16]++;

            runLength -= rpt;
          }
        }
      }
    }

    return {
      codes:
        result.subarray(0, nResult),
      freqs: freqs
    };
  };

/**
* ハフマン符号の長さを取得する
* @param {!(Array.<number>|Uint8Array|Uint32Array)} freqs 出現カウント.
* @param {number} limit 符号長の制限.
* @return {!(Array.<number>|Uint8Array)} 符号長配列.
* @private
*/
Zlib$2.RawDeflate.prototype.getLengths_ = function (freqs, limit) {
  /** @type {number} */
  var nSymbols = freqs.length;
  /** @type {Zlib.Heap} */
  var heap = new Zlib$2.Heap(2 * Zlib$2.RawDeflate.HUFMAX);
  /** @type {!(Array.<number>|Uint8Array)} */
  var length = new (Uint8Array)(nSymbols);
  /** @type {Array} */
  var nodes;
  /** @type {!(Array.<number>|Uint32Array)} */
  var values;
  /** @type {!(Array.<number>|Uint8Array)} */
  var codeLength;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  // ヒープの構築
  for (i = 0; i < nSymbols; ++i) {
    if (freqs[i] > 0) {
      heap.push(i, freqs[i]);
    }
  }
  nodes = new Array(heap.length / 2);
  values = new (Uint32Array)(heap.length / 2);

  // 非 0 の要素が一つだけだった場合は、そのシンボルに符号長 1 を割り当てて終了
  if (nodes.length === 1) {
    length[heap.pop().index] = 1;
    return length;
  }

  // Reverse Package Merge Algorithm による Canonical Huffman Code の符号長決定
  for (i = 0, il = heap.length / 2; i < il; ++i) {
    nodes[i] = heap.pop();
    values[i] = nodes[i].value;
  }
  codeLength = this.reversePackageMerge_(values, values.length, limit);

  for (i = 0, il = nodes.length; i < il; ++i) {
    length[nodes[i].index] = codeLength[i];
  }

  return length;
};

/**
* Reverse Package Merge Algorithm.
* @param {!(Array.<number>|Uint32Array)} freqs sorted probability.
* @param {number} symbols number of symbols.
* @param {number} limit code length limit.
* @return {!(Array.<number>|Uint8Array)} code lengths.
*/
Zlib$2.RawDeflate.prototype.reversePackageMerge_ = function (freqs, symbols, limit) {
  /** @type {!(Array.<number>|Uint16Array)} */
  var minimumCost = new (Uint16Array)(limit);
  /** @type {!(Array.<number>|Uint8Array)} */
  var flag = new (Uint8Array)(limit);
  /** @type {!(Array.<number>|Uint8Array)} */
  var codeLength = new (Uint8Array)(symbols);
  /** @type {Array} */
  var value = new Array(limit);
  /** @type {Array} */
  var type = new Array(limit);
  /** @type {Array.<number>} */
  var currentPosition = new Array(limit);
  /** @type {number} */
  var excess = (1 << limit) - symbols;
  /** @type {number} */
  var half = (1 << (limit - 1));
  /** @type {number} */
  var i;
  /** @type {number} */
  var j;
  /** @type {number} */
  var t;
  /** @type {number} */
  var weight;
  /** @type {number} */
  var next;

  /**
   * @param {number} j
   */
  function takePackage(j) {
    /** @type {number} */
    var x = type[j][currentPosition[j]];

    if (x === symbols) {
      takePackage(j + 1);
      takePackage(j + 1);
    } else {
      --codeLength[x];
    }

    ++currentPosition[j];
  }

  minimumCost[limit - 1] = symbols;

  for (j = 0; j < limit; ++j) {
    if (excess < half) {
      flag[j] = 0;
    } else {
      flag[j] = 1;
      excess -= half;
    }
    excess <<= 1;
    minimumCost[limit - 2 - j] = (minimumCost[limit - 1 - j] / 2 | 0) + symbols;
  }
  minimumCost[0] = flag[0];

  value[0] = new Array(minimumCost[0]);
  type[0] = new Array(minimumCost[0]);
  for (j = 1; j < limit; ++j) {
    if (minimumCost[j] > 2 * minimumCost[j - 1] + flag[j]) {
      minimumCost[j] = 2 * minimumCost[j - 1] + flag[j];
    }
    value[j] = new Array(minimumCost[j]);
    type[j] = new Array(minimumCost[j]);
  }

  for (i = 0; i < symbols; ++i) {
    codeLength[i] = limit;
  }

  for (t = 0; t < minimumCost[limit - 1]; ++t) {
    value[limit - 1][t] = freqs[t];
    type[limit - 1][t] = t;
  }

  for (i = 0; i < limit; ++i) {
    currentPosition[i] = 0;
  }
  if (flag[limit - 1] === 1) {
    --codeLength[0];
    ++currentPosition[limit - 1];
  }

  for (j = limit - 2; j >= 0; --j) {
    i = 0;
    weight = 0;
    next = currentPosition[j + 1];

    for (t = 0; t < minimumCost[j]; t++) {
      weight = value[j + 1][next] + value[j + 1][next + 1];

      if (weight > freqs[i]) {
        value[j][t] = weight;
        type[j][t] = symbols;
        next += 2;
      } else {
        value[j][t] = freqs[i];
        type[j][t] = i;
        ++i;
      }
    }

    currentPosition[j] = 0;
    if (flag[j] === 1) {
      takePackage(j);
    }
  }

  return codeLength;
};

/**
* 符号長配列からハフマン符号を取得する
* reference: PuTTY Deflate implementation
* @param {!(Array.<number>|Uint8Array)} lengths 符号長配列.
* @return {!(Array.<number>|Uint16Array)} ハフマン符号配列.
* @private
*/
Zlib$2.RawDeflate.prototype.getCodesFromLengths_ = function (lengths) {
  var codes = new (Uint16Array)(lengths.length),
    count = [],
    startCode = [],
    code = 0, i, il, j, m;

  // Count the codes of each length.
  for (i = 0, il = lengths.length; i < il; i++) {
    count[lengths[i]] = (count[lengths[i]] | 0) + 1;
  }

  // Determine the starting code for each length block.
  for (i = 1, il = Zlib$2.RawDeflate.MaxCodeLength; i <= il; i++) {
    startCode[i] = code;
    code += count[i] | 0;
    code <<= 1;
  }

  // Determine the code for each symbol. Mirrored, of course.
  for (i = 0, il = lengths.length; i < il; i++) {
    code = startCode[lengths[i]];
    startCode[lengths[i]] += 1;
    codes[i] = 0;

    for (j = 0, m = lengths[i]; j < m; j++) {
      codes[i] = (codes[i] << 1) | (code & 1);
      code >>>= 1;
    }
  }

  return codes;
};


/**
* @param {!(Array.<number>|Uint8Array)} input input buffer.
* @param {Object=} opt_params options.
* @constructor
*/
Zlib$2.Unzip = function (input, opt_params) {
  opt_params = opt_params || {};
  /** @type {!(Array.<number>|Uint8Array)} */
  this.input =
    ((input instanceof Array)) ?
      new Uint8Array(input) : input;
  /** @type {number} */
  this.ip = 0;
  /** @type {number} */
  this.eocdrOffset;
  /** @type {number} */
  this.numberOfThisDisk;
  /** @type {number} */
  this.startDisk;
  /** @type {number} */
  this.totalEntriesThisDisk;
  /** @type {number} */
  this.totalEntries;
  /** @type {number} */
  this.centralDirectorySize;
  /** @type {number} */
  this.centralDirectoryOffset;
  /** @type {number} */
  this.commentLength;
  /** @type {(Array.<number>|Uint8Array)} */
  this.comment;
  /** @type {Array.<Zlib.Unzip.FileHeader>} */
  this.fileHeaderList;
  /** @type {Object.<string, number>} */
  this.filenameToIndex;
  /** @type {boolean} */
  this.verify = opt_params['verify'] || false;
  /** @type {(Array.<number>|Uint8Array)} */
  this.password = opt_params['password'];
};

Zlib$2.Unzip.CompressionMethod = Zlib$2.Zip.CompressionMethod;

/**
* @type {Array.<number>}
* @const
*/
Zlib$2.Unzip.FileHeaderSignature = Zlib$2.Zip.FileHeaderSignature;

/**
* @type {Array.<number>}
* @const
*/
Zlib$2.Unzip.LocalFileHeaderSignature = Zlib$2.Zip.LocalFileHeaderSignature;

/**
* @type {Array.<number>}
* @const
*/
Zlib$2.Unzip.CentralDirectorySignature = Zlib$2.Zip.CentralDirectorySignature;

/**
* @param {!(Array.<number>|Uint8Array)} input input buffer.
* @param {number} ip input position.
* @constructor
*/
Zlib$2.Unzip.FileHeader = function (input, ip) {
  /** @type {!(Array.<number>|Uint8Array)} */
  this.input = input;
  /** @type {number} */
  this.offset = ip;
  /** @type {number} */
  this.length;
  /** @type {number} */
  this.version;
  /** @type {number} */
  this.os;
  /** @type {number} */
  this.needVersion;
  /** @type {number} */
  this.flags;
  /** @type {number} */
  this.compression;
  /** @type {number} */
  this.time;
  /** @type {number} */
  this.date;
  /** @type {number} */
  this.crc32;
  /** @type {number} */
  this.compressedSize;
  /** @type {number} */
  this.plainSize;
  /** @type {number} */
  this.fileNameLength;
  /** @type {number} */
  this.extraFieldLength;
  /** @type {number} */
  this.fileCommentLength;
  /** @type {number} */
  this.diskNumberStart;
  /** @type {number} */
  this.internalFileAttributes;
  /** @type {number} */
  this.externalFileAttributes;
  /** @type {number} */
  this.relativeOffset;
  /** @type {string} */
  this.filename;
  /** @type {!(Array.<number>|Uint8Array)} */
  this.extraField;
  /** @type {!(Array.<number>|Uint8Array)} */
  this.comment;
};

Zlib$2.Unzip.FileHeader.prototype.parse = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip = this.offset;

  // central file header signature
  if (input[ip++] !== Zlib$2.Unzip.FileHeaderSignature[0] ||
    input[ip++] !== Zlib$2.Unzip.FileHeaderSignature[1] ||
    input[ip++] !== Zlib$2.Unzip.FileHeaderSignature[2] ||
    input[ip++] !== Zlib$2.Unzip.FileHeaderSignature[3]) {
    throw new Error('invalid file header signature');
  }

  // version made by
  this.version = input[ip++];
  this.os = input[ip++];

  // version needed to extract
  this.needVersion = input[ip++] | (input[ip++] << 8);

  // general purpose bit flag
  this.flags = input[ip++] | (input[ip++] << 8);

  // compression method
  this.compression = input[ip++] | (input[ip++] << 8);

  // last mod file time
  this.time = input[ip++] | (input[ip++] << 8);

  //last mod file date
  this.date = input[ip++] | (input[ip++] << 8);

  // crc-32
  this.crc32 = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // compressed size
  this.compressedSize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // uncompressed size
  this.plainSize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // file name length
  this.fileNameLength = input[ip++] | (input[ip++] << 8);

  // extra field length
  this.extraFieldLength = input[ip++] | (input[ip++] << 8);

  // file comment length
  this.fileCommentLength = input[ip++] | (input[ip++] << 8);

  // disk number start
  this.diskNumberStart = input[ip++] | (input[ip++] << 8);

  // internal file attributes
  this.internalFileAttributes = input[ip++] | (input[ip++] << 8);

  // external file attributes
  this.externalFileAttributes =
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24);

  // relative offset of local header
  this.relativeOffset = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // file name
  this.filename = String.fromCharCode.apply(null, input.subarray(ip, ip += this.fileNameLength)
  );

  // extra field
  this.extraField = input.subarray(ip, ip += this.extraFieldLength);

  // file comment
  this.comment = input.subarray(ip, ip + this.fileCommentLength);

  this.length = ip - this.offset;
};

/**
* @param {!(Array.<number>|Uint8Array)} input input buffer.
* @param {number} ip input position.
* @constructor
*/
Zlib$2.Unzip.LocalFileHeader = function (input, ip) {
  /** @type {!(Array.<number>|Uint8Array)} */
  this.input = input;
  /** @type {number} */
  this.offset = ip;
  /** @type {number} */
  this.length;
  /** @type {number} */
  this.needVersion;
  /** @type {number} */
  this.flags;
  /** @type {number} */
  this.compression;
  /** @type {number} */
  this.time;
  /** @type {number} */
  this.date;
  /** @type {number} */
  this.crc32;
  /** @type {number} */
  this.compressedSize;
  /** @type {number} */
  this.plainSize;
  /** @type {number} */
  this.fileNameLength;
  /** @type {number} */
  this.extraFieldLength;
  /** @type {string} */
  this.filename;
  /** @type {!(Array.<number>|Uint8Array)} */
  this.extraField;
};

Zlib$2.Unzip.LocalFileHeader.Flags = Zlib$2.Zip.Flags;

Zlib$2.Unzip.LocalFileHeader.prototype.parse = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip = this.offset;

  // local file header signature
  if (input[ip++] !== Zlib$2.Unzip.LocalFileHeaderSignature[0] ||
    input[ip++] !== Zlib$2.Unzip.LocalFileHeaderSignature[1] ||
    input[ip++] !== Zlib$2.Unzip.LocalFileHeaderSignature[2] ||
    input[ip++] !== Zlib$2.Unzip.LocalFileHeaderSignature[3]) {
    throw new Error('invalid local file header signature');
  }

  // version needed to extract
  this.needVersion = input[ip++] | (input[ip++] << 8);

  // general purpose bit flag
  this.flags = input[ip++] | (input[ip++] << 8);

  // compression method
  this.compression = input[ip++] | (input[ip++] << 8);

  // last mod file time
  this.time = input[ip++] | (input[ip++] << 8);

  //last mod file date
  this.date = input[ip++] | (input[ip++] << 8);

  // crc-32
  this.crc32 = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // compressed size
  this.compressedSize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // uncompressed size
  this.plainSize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // file name length
  this.fileNameLength = input[ip++] | (input[ip++] << 8);

  // extra field length
  this.extraFieldLength = input[ip++] | (input[ip++] << 8);

  // file name
  this.filename = String.fromCharCode.apply(null, input.subarray(ip, ip += this.fileNameLength)
  );

  // extra field
  this.extraField = input.subarray(ip, ip += this.extraFieldLength);

  this.length = ip - this.offset;
};


Zlib$2.Unzip.prototype.searchEndOfCentralDirectoryRecord = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip;

  for (ip = input.length - 12; ip > 0; --ip) {
    if (input[ip] === Zlib$2.Unzip.CentralDirectorySignature[0] &&
      input[ip + 1] === Zlib$2.Unzip.CentralDirectorySignature[1] &&
      input[ip + 2] === Zlib$2.Unzip.CentralDirectorySignature[2] &&
      input[ip + 3] === Zlib$2.Unzip.CentralDirectorySignature[3]) {
      this.eocdrOffset = ip;
      return;
    }
  }

  throw new Error('End of Central Directory Record not found');
};

Zlib$2.Unzip.prototype.parseEndOfCentralDirectoryRecord = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip;

  if (!this.eocdrOffset) {
    this.searchEndOfCentralDirectoryRecord();
  }
  ip = this.eocdrOffset;

  // signature
  if (input[ip++] !== Zlib$2.Unzip.CentralDirectorySignature[0] ||
    input[ip++] !== Zlib$2.Unzip.CentralDirectorySignature[1] ||
    input[ip++] !== Zlib$2.Unzip.CentralDirectorySignature[2] ||
    input[ip++] !== Zlib$2.Unzip.CentralDirectorySignature[3]) {
    throw new Error('invalid signature');
  }

  // number of this disk
  this.numberOfThisDisk = input[ip++] | (input[ip++] << 8);

  // number of the disk with the start of the central directory
  this.startDisk = input[ip++] | (input[ip++] << 8);

  // total number of entries in the central directory on this disk
  this.totalEntriesThisDisk = input[ip++] | (input[ip++] << 8);

  // total number of entries in the central directory
  this.totalEntries = input[ip++] | (input[ip++] << 8);

  // size of the central directory
  this.centralDirectorySize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // offset of start of central directory with respect to the starting disk number
  this.centralDirectoryOffset = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // .ZIP file comment length
  this.commentLength = input[ip++] | (input[ip++] << 8);

  // .ZIP file comment
  this.comment = input.subarray(ip, ip + this.commentLength);
};

Zlib$2.Unzip.prototype.parseFileHeader = function () {
  /** @type {Array.<Zlib.Unzip.FileHeader>} */
  var filelist = [];
  /** @type {Object.<string, number>} */
  var filetable = {};
  /** @type {number} */
  var ip;
  /** @type {Zlib.Unzip.FileHeader} */
  var fileHeader;
  /*: @type {number} */
  var i;
  /*: @type {number} */
  var il;

  if (this.fileHeaderList) {
    return;
  }

  if (this.centralDirectoryOffset === void 0) {
    this.parseEndOfCentralDirectoryRecord();
  }
  ip = this.centralDirectoryOffset;

  for (i = 0, il = this.totalEntries; i < il; ++i) {
    fileHeader = new Zlib$2.Unzip.FileHeader(this.input, ip);
    fileHeader.parse();
    ip += fileHeader.length;
    filelist[i] = fileHeader;
    filetable[fileHeader.filename] = i;
  }

  if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {
    throw new Error('invalid file header size');
  }

  this.fileHeaderList = filelist;
  this.filenameToIndex = filetable;
};

/**
* @param {number} index file header index.
* @param {Object=} opt_params
* @return {!(Array.<number>|Uint8Array)} file data.
*/
Zlib$2.Unzip.prototype.getFileData = function (index, opt_params) {
  opt_params = opt_params || {};
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {Array.<Zlib.Unzip.FileHeader>} */
  var fileHeaderList = this.fileHeaderList;
  /** @type {Zlib.Unzip.LocalFileHeader} */
  var localFileHeader;
  /** @type {number} */
  var offset;
  /** @type {number} */
  var length;
  /** @type {!(Array.<number>|Uint8Array)} */
  var buffer;
  /** @type {number} */
  var crc32;
  /** @type {Array.<number>|Uint32Array|Object} */
  var key;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  if (!fileHeaderList) {
    this.parseFileHeader();
  }

  if (fileHeaderList[index] === void 0) {
    throw new Error('wrong index');
  }

  offset = fileHeaderList[index].relativeOffset;
  localFileHeader = new Zlib$2.Unzip.LocalFileHeader(this.input, offset);
  localFileHeader.parse();
  offset += localFileHeader.length;
  length = localFileHeader.compressedSize;

  // decryption
  if ((localFileHeader.flags & Zlib$2.Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {
    if (!(opt_params['password'] || this.password)) {
      throw new Error('please set password');
    }
    key = this.createDecryptionKey(opt_params['password'] || this.password);

    // encryption header
    for (i = offset, il = offset + 12; i < il; ++i) {
      this.decode(key, input[i]);
    }
    offset += 12;
    length -= 12;

    // decryption
    for (i = offset, il = offset + length; i < il; ++i) {
      input[i] = this.decode(key, input[i]);
    }
  }

  switch (localFileHeader.compression) {
    case Zlib$2.Unzip.CompressionMethod.STORE:
      buffer = this.input.subarray(offset, offset + length);
      break;
    case Zlib$2.Unzip.CompressionMethod.DEFLATE:
      buffer = new Zlib$2.RawInflate(this.input, {
        'index': offset,
        'bufferSize': localFileHeader.plainSize
      }).decompress();
      break;
    default:
      throw new Error('unknown compression type');
  }

  if (this.verify) {
    crc32 = Zlib$2.CRC32.calc(buffer);
    if (localFileHeader.crc32 !== crc32) {
      throw new Error(
        'wrong crc: file=0x' + localFileHeader.crc32.toString(16) +
        ', data=0x' + crc32.toString(16)
      );
    }
  }

  return buffer;
};

/**
* @return {Array.<string>}
*/
Zlib$2.Unzip.prototype.getFilenames = function () {
  /** @type {Array.<string>} */
  var filenameList = [];
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;
  /** @type {Array.<Zlib.Unzip.FileHeader>} */
  var fileHeaderList;

  if (!this.fileHeaderList) {
    this.parseFileHeader();
  }
  fileHeaderList = this.fileHeaderList;

  for (i = 0, il = fileHeaderList.length; i < il; ++i) {
    filenameList[i] = fileHeaderList[i].filename;
  }

  return filenameList;
};

/**
* @param {string} filename extract filename.
* @param {Object=} opt_params
* @return {!(Array.<number>|Uint8Array)} decompressed data.
*/
Zlib$2.Unzip.prototype.decompress = function (filename, opt_params) {
  /** @type {number} */
  var index;

  if (!this.filenameToIndex) {
    this.parseFileHeader();
  }
  index = this.filenameToIndex[filename];

  if (index === void 0) {
    throw new Error(filename + ' not found');
  }

  return this.getFileData(index, opt_params);
};

/**
* @param {(Array.<number>|Uint8Array)} password
*/
Zlib$2.Unzip.prototype.setPassword = function (password) {
  this.password = password;
};

/**
* @param {(Array.<number>|Uint32Array|Object)} key
* @param {number} n
* @return {number}
*/
Zlib$2.Unzip.prototype.decode = function (key, n) {
  n ^= this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));
  this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);

  return n;
};

// common method
Zlib$2.Unzip.prototype.updateKeys = Zlib$2.Zip.prototype.updateKeys;
Zlib$2.Unzip.prototype.createDecryptionKey = Zlib$2.Zip.prototype.createEncryptionKey;
Zlib$2.Unzip.prototype.getByte = Zlib$2.Zip.prototype.getByte;

/**
* @fileoverview 雑多な関数群をまとめたモジュール実装.
*/


/**
* Byte String から Byte Array に変換.
* @param {!string} str byte string.
* @return {!Array.<number>} byte array.
*/
Zlib$2.Util.stringToByteArray = function (str) {
  /** @type {!Array.<(string|number)>} */
  var tmp = str.split('');
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  for (i = 0, il = tmp.length; i < il; i++) {
    tmp[i] = (tmp[i].charCodeAt(0) & 0xff) >>> 0;
  }

  return tmp;
};


/**
* @fileoverview Adler32 checksum 実装.
*/


/**
* Adler32 ハッシュ値の作成
* @param {!(Array|Uint8Array|string)} array 算出に使用する byte array.
* @return {number} Adler32 ハッシュ値.
*/
Zlib$2.Adler32 = function (array) {
  if (typeof (array) === 'string') {
    array = Zlib$2.Util.stringToByteArray(array);
  }
  return Zlib$2.Adler32.update(1, array);
};

/**
* Adler32 ハッシュ値の更新
* @param {number} adler 現在のハッシュ値.
* @param {!(Array|Uint8Array)} array 更新に使用する byte array.
* @return {number} Adler32 ハッシュ値.
*/
Zlib$2.Adler32.update = function (adler, array) {
  /** @type {number} */
  var s1 = adler & 0xffff;
  /** @type {number} */
  var s2 = (adler >>> 16) & 0xffff;
  /** @type {number} array length */
  var len = array.length;
  /** @type {number} loop length (don't overflow) */
  var tlen;
  /** @type {number} array index */
  var i = 0;

  while (len > 0) {
    tlen = len > Zlib$2.Adler32.OptimizationParameter ?
      Zlib$2.Adler32.OptimizationParameter : len;
    len -= tlen;
    do {
      s1 += array[i++];
      s2 += s1;
    } while (--tlen);

    s1 %= 65521;
    s2 %= 65521;
  }

  return ((s2 << 16) | s1) >>> 0;
};

/**
* Adler32 最適化パラメータ
* 現状では 1024 程度が最適.
* @see http://jsperf.com/adler-32-simple-vs-optimized/3
* @define {number}
*/
Zlib$2.Adler32.OptimizationParameter = 1024;




/**
* ビットストリーム
* @constructor
* @param {!(Array|Uint8Array)=} buffer output buffer.
* @param {number=} bufferPosition start buffer pointer.
*/
Zlib$2.BitStream = function (buffer, bufferPosition) {
  /** @type {number} buffer index. */
  this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;
  /** @type {number} bit index. */
  this.bitindex = 0;
  /** @type {!(Array|Uint8Array)} bit-stream output buffer. */
  this.buffer = buffer instanceof (Uint8Array) ?
    buffer :
    new (Uint8Array)(Zlib$2.BitStream.DefaultBlockSize);

  // 入力された index が足りなかったら拡張するが、倍にしてもダメなら不正とする
  if (this.buffer.length * 2 <= this.index) {
    throw new Error("invalid index");
  } else if (this.buffer.length <= this.index) {
    this.expandBuffer();
  }
};

/**
* デフォルトブロックサイズ.
* @const
* @type {number}
*/
Zlib$2.BitStream.DefaultBlockSize = 0x8000;

/**
* expand buffer.
* @return {!(Array|Uint8Array)} new buffer.
*/
Zlib$2.BitStream.prototype.expandBuffer = function () {
  /** @type {!(Array|Uint8Array)} old buffer. */
  var oldbuf = this.buffer;
  /** @type {number} loop limiter. */
  var il = oldbuf.length;
  /** @type {!(Array|Uint8Array)} new buffer. */
  var buffer =
    new (Uint8Array)(il << 1);

  // copy buffer
  {
    buffer.set(oldbuf);
  }

  return (this.buffer = buffer);
};


/**
* 数値をビットで指定した数だけ書き込む.
* @param {number} number 書き込む数値.
* @param {number} n 書き込むビット数.
* @param {boolean=} reverse 逆順に書き込むならば true.
*/
Zlib$2.BitStream.prototype.writeBits = function (number, n, reverse) {
  var buffer = this.buffer;
  var index = this.index;
  var bitindex = this.bitindex;

  /** @type {number} current octet. */
  var current = buffer[index];
  /** @type {number} loop counter. */
  var i;

  /**
   * 32-bit 整数のビット順を逆にする
   * @param {number} n 32-bit integer.
   * @return {number} reversed 32-bit integer.
   * @private
   */
  function rev32_(n) {
    return (Zlib$2.BitStream.ReverseTable[n & 0xFF] << 24) |
      (Zlib$2.BitStream.ReverseTable[n >>> 8 & 0xFF] << 16) |
      (Zlib$2.BitStream.ReverseTable[n >>> 16 & 0xFF] << 8) |
      Zlib$2.BitStream.ReverseTable[n >>> 24 & 0xFF];
  }

  if (reverse && n > 1) {
    number = n > 8 ?
      rev32_(number) >> (32 - n) :
      Zlib$2.BitStream.ReverseTable[number] >> (8 - n);
  }

  // Byte 境界を超えないとき
  if (n + bitindex < 8) {
    current = (current << n) | number;
    bitindex += n;
    // Byte 境界を超えるとき
  } else {
    for (i = 0; i < n; ++i) {
      current = (current << 1) | ((number >> n - i - 1) & 1);

      // next byte
      if (++bitindex === 8) {
        bitindex = 0;
        buffer[index++] = Zlib$2.BitStream.ReverseTable[current];
        current = 0;

        // expand
        if (index === buffer.length) {
          buffer = this.expandBuffer();
        }
      }
    }
  }
  buffer[index] = current;

  this.buffer = buffer;
  this.bitindex = bitindex;
  this.index = index;
};


/**
* ストリームの終端処理を行う
* @return {!(Array|Uint8Array)} 終端処理後のバッファを byte array で返す.
*/
Zlib$2.BitStream.prototype.finish = function () {
  var buffer = this.buffer;
  var index = this.index;

  /** @type {!(Array|Uint8Array)} output buffer. */
  var output;

  // bitindex が 0 の時は余分に index が進んでいる状態
  if (this.bitindex > 0) {
    buffer[index] <<= 8 - this.bitindex;
    buffer[index] = Zlib$2.BitStream.ReverseTable[buffer[index]];
    index++;
  }

  // array truncation
  {
    output = buffer.subarray(0, index);
  }

  return output;
};

/**
* 0-255 のビット順を反転したテーブル
* @const
* @type {!(Uint8Array|Array.<number>)}
*/
Zlib$2.BitStream.ReverseTable = (function (table) {
  return table;
})((function () {
  /** @type {!(Array|Uint8Array)} reverse table. */
  var table = new (Uint8Array)(256);
  /** @type {number} loop counter. */
  var i;

  // generate
  for (i = 0; i < 256; ++i) {
    table[i] = (function (n) {
      var r = n;
      var s = 7;

      for (n >>>= 1; n; n >>>= 1) {
        r <<= 1;
        r |= n & 1;
        --s;
      }

      return (r << s & 0xff) >>> 0;
    })(i);
  }

  return table;
})());

/**
* CRC32 ハッシュ値を取得
* @param {!(Array.<number>|Uint8Array)} data data byte array.
* @param {number=} pos data position.
* @param {number=} length data length.
* @return {number} CRC32.
*/
Zlib$2.CRC32.calc = function (data, pos, length) {
  return Zlib$2.CRC32.update(data, 0, pos, length);
};

/**
* CRC32ハッシュ値を更新
* @param {!(Array.<number>|Uint8Array)} data data byte array.
* @param {number} crc CRC32.
* @param {number=} pos data position.
* @param {number=} length data length.
* @return {number} CRC32.
*/
Zlib$2.CRC32.update = function (data, crc, pos, length) {
  var table = Zlib$2.CRC32.Table;
  var i = (typeof pos === 'number') ? pos : (pos = 0);
  var il = (typeof length === 'number') ? length : data.length;

  crc ^= 0xffffffff;

  // loop unrolling for performance
  for (i = il & 7; i--; ++pos) {
    crc = (crc >>> 8) ^ table[(crc ^ data[pos]) & 0xff];
  }
  for (i = il >> 3; i--; pos += 8) {
    crc = (crc >>> 8) ^ table[(crc ^ data[pos]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 1]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 2]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 3]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 4]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 5]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 6]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 7]) & 0xff];
  }

  return (crc ^ 0xffffffff) >>> 0;
};

/**
* @param {number} num
* @param {number} crc
* @returns {number}
*/
Zlib$2.CRC32.single = function (num, crc) {
  return (Zlib$2.CRC32.Table[(num ^ crc) & 0xff] ^ (num >>> 8)) >>> 0;
};

/**
* @type {Array.<number>}
* @const
* @private
*/
Zlib$2.CRC32.Table_ = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
  0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
  0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
  0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
  0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
  0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
  0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
  0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
  0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
  0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
  0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
  0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
  0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
  0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
  0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
  0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
  0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
  0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
];

/**
* @type {!(Array.<number>|Uint32Array)} CRC-32 Table.
* @const
*/
Zlib$2.CRC32.Table = new Uint32Array(Zlib$2.CRC32.Table_);

/**
* @fileoverview Deflate (RFC1951) 実装.
* Deflateアルゴリズム本体は Zlib.RawDeflate で実装されている.
*/

/**
* Zlib Deflate
* @constructor
* @param {!(Array|Uint8Array)} input 符号化する対象の byte array.
* @param {Object=} opt_params option parameters.
*/
Zlib$2.Deflate = function (input, opt_params) {
  /** @type {!(Array|Uint8Array)} */
  this.input = input;
  /** @type {!(Array|Uint8Array)} */
  this.output =
    new (Uint8Array)(Zlib$2.Deflate.DefaultBufferSize);
  /** @type {Zlib.Deflate.CompressionType} */
  this.compressionType = Zlib$2.Deflate.CompressionType.DYNAMIC;
  /** @type {Zlib.RawDeflate} */
  this.rawDeflate;
  /** @type {Object} */
  var rawDeflateOption = {};
  /** @type {string} */
  var prop;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (typeof opt_params['compressionType'] === 'number') {
      this.compressionType = opt_params['compressionType'];
    }
  }

  // copy options
  for (prop in opt_params) {
    rawDeflateOption[prop] = opt_params[prop];
  }

  // set raw-deflate output buffer
  rawDeflateOption['outputBuffer'] = this.output;

  this.rawDeflate = new Zlib$2.RawDeflate(this.input, rawDeflateOption);
};

/**
* @const
* @type {number} デフォルトバッファサイズ.
*/
Zlib$2.Deflate.DefaultBufferSize = 0x8000;

/**
* @enum {number}
*/
Zlib$2.Deflate.CompressionType = Zlib$2.RawDeflate.CompressionType;

/**
* 直接圧縮に掛ける.
* @param {!(Array|Uint8Array)} input target buffer.
* @param {Object=} opt_params option parameters.
* @return {!(Array|Uint8Array)} compressed data byte array.
*/
Zlib$2.Deflate.compress = function (input, opt_params) {
  return (new Zlib$2.Deflate(input, opt_params)).compress();
};

/**
* Deflate Compression.
* @return {!(Array|Uint8Array)} compressed data byte array.
*/
Zlib$2.Deflate.prototype.compress = function () {
  /** @type {Zlib.CompressionMethod} */
  var cm;
  /** @type {number} */
  var cinfo;
  /** @type {number} */
  var cmf;
  /** @type {number} */
  var flg;
  /** @type {number} */
  var fcheck;
  /** @type {number} */
  var fdict;
  /** @type {number} */
  var flevel;
  /** @type {number} */
  var adler;
  /** @type {!(Array|Uint8Array)} */
  var output;
  /** @type {number} */
  var pos = 0;

  output = this.output;

  // Compression Method and Flags
  cm = Zlib$2.CompressionMethod.DEFLATE;
  switch (cm) {
    case Zlib$2.CompressionMethod.DEFLATE:
      cinfo = Math.LOG2E * Math.log(Zlib$2.RawDeflate.WindowSize) - 8;
      break;
    default:
      throw new Error('invalid compression method');
  }
  cmf = (cinfo << 4) | cm;
  output[pos++] = cmf;

  // Flags
  fdict = 0;
  switch (cm) {
    case Zlib$2.CompressionMethod.DEFLATE:
      switch (this.compressionType) {
        case Zlib$2.Deflate.CompressionType.NONE: flevel = 0; break;
        case Zlib$2.Deflate.CompressionType.FIXED: flevel = 1; break;
        case Zlib$2.Deflate.CompressionType.DYNAMIC: flevel = 2; break;
        default: throw new Error('unsupported compression type');
      }
      break;
    default:
      throw new Error('invalid compression method');
  }
  flg = (flevel << 6) | (fdict << 5);
  fcheck = 31 - (cmf * 256 + flg) % 31;
  flg |= fcheck;
  output[pos++] = flg;

  // Adler-32 checksum
  adler = Zlib$2.Adler32(this.input);

  this.rawDeflate.op = pos;
  output = this.rawDeflate.compress();
  pos = output.length;

  {
    // subarray 分を元にもどす
    output = new Uint8Array(output.buffer);
    // expand buffer
    if (output.length <= pos + 4) {
      this.output = new Uint8Array(output.length + 4);
      this.output.set(output);
      output = this.output;
    }
    output = output.subarray(0, pos + 4);
  }

  // adler32
  output[pos++] = (adler >> 24) & 0xff;
  output[pos++] = (adler >> 16) & 0xff;
  output[pos++] = (adler >> 8) & 0xff;
  output[pos++] = (adler) & 0xff;

  return output;
};

/**
* Covers string literals and String objects
* @param x
* @returns {boolean}
*/
function isString$2(x) {
  return typeof x === "string" || x instanceof String
}


// StackOverflow: http://stackoverflow.com/a/10810674/116169
function numberFormatter(rawNumber) {

  var dec = String(rawNumber).split(/[.,]/),
    sep = ',',
    decsep = '.';

  return dec[0].split('').reverse().reduce(function (prev, now, i) {
    return i % 3 === 0 ? prev + sep + now : prev + now;
  }).split('').reverse().join('') + (dec[1] ? decsep + dec[1] : '');
}

const numberUnFormatter = formatedNumber => formatedNumber.split(",").join().replace(",", "", "g");

const splitLines = function (string) {
  return string.split(/\n|\r\n|\r/g);
};


function splitStringRespectingQuotes(string, delim) {

  var tokens = [],
    len = string.length,
    i,
    n = 0,
    quote = false,
    c;

  if (len > 0) {

    tokens[n] = string.charAt(0);
    for (i = 1; i < len; i++) {
      c = string.charAt(i);
      if (c === '"') {
        quote = !quote;
      } else if (!quote && c === delim) {
        n++;
        tokens[n] = "";
      } else {
        tokens[n] += c;
      }
    }
  }
  return tokens;
}

function stripQuotes(str) {
  if (str === undefined) {
    return str;
  }
  if (str.startsWith("'") || str.startsWith('"')) {
    str = str.substring(1);
  }
  if (str.endsWith("'") || str.endsWith('"')) {
    str = str.substring(0, str.length - 1);
  }
  return str;
}

/**
* Compress string and encode in a url safe form
* @param s
*/
function compressString(str) {

  const bytes = [];
  for (var i = 0; i < str.length; i++) {
    bytes.push(str.charCodeAt(i));
  }
  const compressedBytes = new Zlib$2.RawDeflate(bytes).compress();            // UInt8Arry
  const compressedString = String.fromCharCode.apply(null, compressedBytes);      // Convert to string
  let enc = btoa(compressedString);
  return enc.replace(/\+/g, '.').replace(/\//g, '_').replace(/=/g, '-');   // URL safe
}

/**
* Uncompress the url-safe encoded compressed string, presumably created by compressString above
*
* @param enc
* @returns {string}
*/
function uncompressString(enc) {

  enc = enc.replace(/\./g, '+').replace(/_/g, '/').replace(/-/g, '=');

  const compressedString = atob(enc);
  const compressedBytes = [];
  for (let i = 0; i < compressedString.length; i++) {
    compressedBytes.push(compressedString.charCodeAt(i));
  }
  const bytes = new Zlib$2.RawInflate(compressedBytes).decompress();

  let str = '';
  for (let b of bytes) {
    str += String.fromCharCode(b);
  }
  return str;
}

function capitalize(str) {
  return str.length > 0 ? str.charAt(0).toUpperCase() + str.slice(1) : str;
}

const FileFormats = {

  gwascatalog: {
    fields: [
      'bin',
      'chr',
      'start',
      'end',
      'name',
      'pubMedID',
      'author',
      'pubDate',
      'journal',
      'title',
      'trait',
      'initSample',
      'replSample',
      'region',
      'genes',
      'riskAllele',
      'riskAlFreq',
      'pValue',
      'pValueDesc',
      'orOrBeta',
      'ci95',
      'platform',
      'cnv'
    ]
  },

  wgrna: {
    fields:
      [
        'bin',
        'chr',
        'start',
        'end',
        'name',
        'score',
        'strand',
        'thickStart',
        'thickEnd',
        'type'
      ]
  },

  cpgislandext: {
    fields:

      [
        'bin',
        'chr',
        'start',
        'end',
        'name',
        'length',
        'cpgNum',
        'gcNum',
        'perCpg',
        'perGc',
        'obsExp'
      ]
  },

  clinVarMain: {
    fields: [
      'chr1',
      'start',
      'end',
      'name',
      'score',
      'strand',
      'thickStart',
      'thickEnd',
      'reserved',
      'blockCount',  // Number of blocks
      'blockSizes',  // Comma separated list of block sizes
      'chromStarts', // Start positions relative to chromStart
      'origName',    // NM_198053.2(CD247):c.462C>T (p.Asp154=)	ClinVar Variation Report
      'clinSign',    // Likely benign	Clinical significance
      'reviewStatus', // 	based on: criteria provided,single submitter	Review Status
      'type',         // single nucleotide variant	Type of Variant
      'geneId', 	    // CD247	Gene Symbol
      'snpId',       //	181656780	dbSNP ID
      'nsvId',       //		dbVar ID
      'rcvAcc',      //	RCV000642347	ClinVar Allele Submission
      'testedInGtr', //	N	Genetic Testing Registry
      'phenotypeList', //	Immunodeficiency due to defect in cd3-zeta	Phenotypes
      'phenotype', //	MedGen:C1857798, OMIM:610163	Phenotype identifiers
      'origin', //	germline	Data origin
      'assembly', //	GRCh37	Genome assembly
      'cytogenetic', //	1q24.2	Cytogenetic status
      'hgvsCod', //	NM_198053.2:c.462C>T	Nucleotide HGVS
      'hgvsProt', //	NP_932170.1:p.Asp154=	Protein HGVS
      'numSubmit', //	1	Number of submitters
      'lastEval', //	Dec 19,2017	Last evaluation
      'guidelines', //		Guidelines
      'otherIds'
    ]
  }
};

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

const knownFileExtensions = new Set([

  "narrowpeak",
  "broadpeak",
  "regionpeak",
  "peaks",
  "bedgraph",
  "wig",
  "gff3",
  "gff",
  "gtf",
  "fusionjuncspan",
  "refflat",
  "seg",
  "aed",
  "bed",
  "vcf",
  "bb",
  "bigbed",
  "bw",
  "bigwig",
  "bam",
  "tdf",
  "refgene",
  "genepred",
  "genepredext",
  "bedpe",
  "bp",
  "snp",
  "rmsk",
  "cram",
  "gwas"
]);

/**
* Return a custom format object with the given name.
* @param name
* @returns {*}
*/
function getFormat(name) {

  if (FileFormats && FileFormats[name]) {
    return expandFormat(FileFormats[name]);
  } else {
    return undefined;
  }

  function expandFormat(format) {

    const fields = format.fields;
    const keys = ['chr', 'start', 'end'];

    for (let i = 0; i < fields.length; i++) {
      for (let key of keys) {
        if (key === fields[i]) {
          format[key] = i;
        }
      }
    }

    return format;
  }
}

function inferFileFormat(fn) {

  var idx, ext;

  fn = fn.toLowerCase();

  // Special case -- UCSC refgene files
  if (fn.endsWith("refgene.txt.gz") ||
    fn.endsWith("refgene.txt.bgz") ||
    fn.endsWith("refgene.txt") ||
    fn.endsWith("refgene.sorted.txt.gz") ||
    fn.endsWith("refgene.sorted.txt.bgz")) {
    return "refgene";
  }


  //Strip parameters -- handle local files later
  idx = fn.indexOf("?");
  if (idx > 0) {
    fn = fn.substr(0, idx);
  }

  //Strip aux extensions .gz, .tab, and .txt
  if (fn.endsWith(".gz")) {
    fn = fn.substr(0, fn.length - 3);
  }

  if (fn.endsWith(".txt") || fn.endsWith(".tab") || fn.endsWith(".bgz")) {
    fn = fn.substr(0, fn.length - 4);
  }


  idx = fn.lastIndexOf(".");
  ext = idx < 0 ? fn : fn.substr(idx + 1);

  switch (ext) {
    case "bw":
      return "bigwig";
    case "bb":
      return "bigbed";
    default:
      if (knownFileExtensions.has(ext)) {
        return ext;
      } else {
        return undefined;
      }

  }

}

function isGoogleURL(url) {
  return (url.includes("googleapis") && !url.includes("urlshortener")) ||
    isGoogleStorageURL(url) ||
    isGoogleDriveURL(url)
}

function isGoogleStorageURL(url) {
  return url.startsWith("gs://") ||
    url.startsWith("https://www.googleapis.com/storage") ||
    url.startsWith("https://storage.cloud.google.com") ||
    url.startsWith("https://storage.googleapis.com");
}

function isGoogleDriveURL(url) {
  return url.indexOf("drive.google.com") >= 0 || url.indexOf("www.googleapis.com/drive") > 0
}

/**
* Translate gs:// urls to https
* See https://cloud.google.com/storage/docs/json_api/v1
* @param gsUrl
* @returns {string|*}
*/
function translateGoogleCloudURL(gsUrl) {

  let { bucket, object } = parseBucketName(gsUrl);
  object = encode(object);

  const qIdx = gsUrl.indexOf('?');
  const paramString = (qIdx > 0) ? gsUrl.substring(qIdx) + "&alt=media" : "?alt=media";

  return `https://storage.googleapis.com/storage/v1/b/${bucket}/o/${object}${paramString}`
}

/**
* Parse a google bucket and object name from a google storage URL.  Known forms include
*
* gs://BUCKET_NAME/OBJECT_NAME
* https://storage.googleapis.com/BUCKET_NAME/OBJECT_NAME
* https://storage.googleapis.com/storage/v1/b/BUCKET_NAME/o/OBJECT_NAME
* https://www.googleapis.com/storage/v1/b/BUCKET_NAME/o/OBJECT_NAME"
* https://storage.googleapis.com/download/storage/v1/b/BUCKET_NAME/o/OBJECT_NAME
*
* @param url
*/
function parseBucketName(url) {

  let bucket;
  let object;

  if (url.startsWith("gs://")) {
    const i = url.indexOf('/', 5);
    if (i >= 0) {
      bucket = url.substring(5, i);
      const qIdx = url.indexOf('?');
      object = (qIdx < 0) ? url.substring(i + 1) : url.substring(i + 1, qIdx);
    }

  } else if (url.startsWith("https://storage.googleapis.com") || url.startsWith("https://storage.cloud.google.com")) {
    const bucketIdx = url.indexOf("/v1/b/", 8);
    if (bucketIdx > 0) {
      const objIdx = url.indexOf("/o/", bucketIdx);
      if (objIdx > 0) {
        const queryIdx = url.indexOf("?", objIdx);
        bucket = url.substring(bucketIdx + 6, objIdx);
        object = queryIdx > 0 ? url.substring(objIdx + 3, queryIdx) : url.substring(objIdx + 3);
      }

    } else {
      const idx1 = url.indexOf("/", 8);
      const idx2 = url.indexOf("/", idx1 + 1);
      const idx3 = url.indexOf("?", idx2);
      if (idx2 > 0) {
        bucket = url.substring(idx1 + 1, idx2);
        object = idx3 < 0 ? url.substring(idx2 + 1) : url.substring(idx2 + 1, idx3);
      }
    }

  } else if (url.startsWith("https://www.googleapis.com/storage/v1/b")) {
    const bucketIdx = url.indexOf("/v1/b/", 8);
    const objIdx = url.indexOf("/o/", bucketIdx);
    if (objIdx > 0) {
      const queryIdx = url.indexOf("?", objIdx);
      bucket = url.substring(bucketIdx + 6, objIdx);
      object = queryIdx > 0 ? url.substring(objIdx + 3, queryIdx) : url.substring(objIdx + 3);
    }
  }

  if (bucket && object) {
    return {
      bucket, object
    }
  } else {
    throw Error(`Unrecognized Google Storage URI: ${url}`)
  }

}

function driveDownloadURL(link) {
  // Return a google drive download url for the sharable link
  //https://drive.google.com/open?id=0B-lleX9c2pZFbDJ4VVRxakJzVGM
  //https://drive.google.com/file/d/1_FC4kCeO8E3V4dJ1yIW7A0sn1yURKIX-/view?usp=sharing
  var id = getGoogleDriveFileID(link);
  return id ? "https://www.googleapis.com/drive/v3/files/" + id + "?alt=media&supportsTeamDrives=true" : link;
}

function getGoogleDriveFileID(link) {

  //https://drive.google.com/file/d/1_FC4kCeO8E3V4dJ1yIW7A0sn1yURKIX-/view?usp=sharing
  //https://www.googleapis.com/drive/v3/files/1w-tvo6p1SH4p1OaQSVxpkV_EJgGIstWF?alt=media&supportsTeamDrives=true"

  if (link.includes("/open?id=")) {
    const i1 = link.indexOf("/open?id=") + 9;
    const i2 = link.indexOf("&");
    if (i1 > 0 && i2 > i1) {
      return link.substring(i1, i2)
    } else if (i1 > 0) {
      return link.substring(i1);
    }

  } else if (link.includes("/file/d/")) {
    const i1 = link.indexOf("/file/d/") + 8;
    const i2 = link.lastIndexOf("/");
    return link.substring(i1, i2);

  } else if (link.startsWith("https://www.googleapis.com/drive")) {
    let i1 = link.indexOf("/files/");
    const i2 = link.indexOf("?");
    if (i1 > 0) {
      i1 += 7;
      return i2 > 0 ?
        link.substring(i1, i2) :
        link.substring(i1)
    }
  }

  throw Error("Unknown Google Drive url format: " + link);


}


/**
* Percent a GCS object name.  See https://cloud.google.com/storage/docs/request-endpoints
* Specific characters to encode:
*   !, #, $, &, ', (, ), *, +, ,, /, :, ;, =, ?, @, [, ], and space characters.
* @param obj
*/

function encode(objectName) {

  let result = '';
  objectName.split('').forEach(function (letter) {
    if (encodings.has(letter)) {
      result += encodings.get(letter);
    } else {
      result += letter;
    }
  });
  return result;
}

//	%23	%24	%25	%26	%27	%28	%29	%2A	%2B	%2C	%2F	%3A	%3B	%3D	%3F	%40	%5B	%5D
const encodings = new Map();
encodings.set("!", "%21");
encodings.set("#", "%23");
encodings.set("$", "%24");
encodings.set("%", "%25");
encodings.set("&", "%26");
encodings.set("'", "%27");
encodings.set("(", "%28");
encodings.set(")", "%29");
encodings.set("*", "%2A");
encodings.set("+", "%2B");
encodings.set(",", "%2C");
encodings.set("/", "%2F");
encodings.set(":", "%3A");
encodings.set(";", "%3B");
encodings.set("=", "%3D");
encodings.set("?", "%3F");
encodings.set("@", "%40");
encodings.set("[", "%5B");
encodings.set("]", "%5D");
encodings.set(" ", "%20");

// Convenience functions for the gapi oAuth library.

const FIVE_MINUTES = 5 * 60 * 1000;

function isInitialized() {
  return typeof gapi !== "undefined" && gapi.auth2 && gapi.auth2.getAuthInstance();
}

let inProgress = false;

async function getAccessToken(scope) {

  if (typeof gapi === "undefined") {
    throw Error("Google authentication requires the 'gapi' library")
  }
  if (!gapi.auth2) {
    throw Error("Google 'auth2' has not been initialized")
  }

  if (inProgress) {
    return new Promise(function (resolve, reject) {
      let intervalID;
      const checkForToken = () => {    // Wait for inProgress to equal "false"
        try {
          if (inProgress === false) {
            //console.log("Delayed resolution for " + scope);
            resolve(getAccessToken(scope));
            clearInterval(intervalID);
          }
        } catch (e) {
          clearInterval(intervalID);
          reject(e);
        }
      };
      intervalID = setInterval(checkForToken, 100);
    })
  } else {
    inProgress = true;
    try {
      let currentUser = gapi.auth2.getAuthInstance().currentUser.get();
      let token;
      if (currentUser.isSignedIn()) {
        if (!currentUser.hasGrantedScopes(scope)) {
          await currentUser.grant({ scope });
        }
        const { access_token, expires_at } = currentUser.getAuthResponse();
        if (Date.now() < (expires_at - FIVE_MINUTES)) {
          token = { access_token, expires_at };
        } else {
          const { access_token, expires_at } = currentUser.reloadAuthResponse();
          token = { access_token, expires_at };
        }
      } else {
        currentUser = await signIn(scope);
        const { access_token, expires_at } = currentUser.getAuthResponse();
        token = { access_token, expires_at };
      }
      return token;
    } finally {
      inProgress = false;
    }
  }
}

/**
* Return the current access token if the user is signed in, or undefined otherwise.  This function does not
* attempt a signIn or request any specfic scopes.
*
* @returns access_token || undefined
*/
function getCurrentAccessToken() {

  let currentUser = gapi.auth2.getAuthInstance().currentUser.get();
  if (currentUser && currentUser.isSignedIn()) {
    const { access_token, expires_at } = currentUser.getAuthResponse();
    return { access_token, expires_at };
  } else {
    return undefined;
  }

}

async function signIn(scope) {

  const options = new gapi.auth2.SigninOptionsBuilder();
  options.setPrompt('select_account');
  options.setScope(scope);
  return gapi.auth2.getAuthInstance().signIn(options)
}

function getScopeForURL(url) {
  if (isGoogleDriveURL(url)) {
    return "https://www.googleapis.com/auth/drive.file";
  } else if (isGoogleStorageURL(url)) {
    return "https://www.googleapis.com/auth/devstorage.read_only";
  } else {
    return 'https://www.googleapis.com/auth/userinfo.profile';
  }
}

function getApiKey() {
  return gapi.apiKey;
}

async function getDriveFileInfo(googleDriveURL) {

  const id = getGoogleDriveFileID(googleDriveURL);
  let endPoint = "https://www.googleapis.com/drive/v3/files/" + id + "?supportsTeamDrives=true";
  const apiKey = getApiKey();
  if (apiKey) {
    endPoint += "&key=" + apiKey;
  }
  const response = await fetch(endPoint);
  let json = await response.json();
  if (json.error && json.error.code === 404) {
    const { access_token } = await getAccessToken("https://www.googleapis.com/auth/drive.readonly");
    if (access_token) {
      const response = await fetch(endPoint, {
        headers: {
          'Authorization': `Bearer ${access_token}`
        }
      });
      json = await response.json();
      if (json.error) {
        throw Error(json.error);
      }
    } else {
      throw Error(json.error);
    }
  }
  return json;
}

if (typeof process === 'object' && typeof window === 'undefined') {
  global.atob = function (str) {
    return Buffer.from(str, 'base64').toString('binary');
  };
}

/**
* @param dataURI
* @returns {Array<number>|Uint8Array}
*/
function decodeDataURI(dataURI) {

  const split = dataURI.split(',');
  const info = split[0].split(':')[1];
  let dataString = split[1];

  if (info.indexOf('base64') >= 0) {
    dataString = atob(dataString);
  } else {
    dataString = decodeURI(dataString);      // URL encoded string -- not currently used of tested
  }
  const bytes = new Uint8Array(dataString.length);
  for (let i = 0; i < dataString.length; i++) {
    bytes[i] = dataString.charCodeAt(i);
  }

  let plain;
  if (info.indexOf('gzip') > 0) {
    const inflate = new Zlib$2.Gunzip(bytes);
    plain = inflate.decompress();
  } else {
    plain = bytes;
  }
  return plain
}

function parseUri(str) {

  var o = options,
    m = o.parser["loose"].exec(str),
    uri = {},
    i = 14;

  while (i--) uri[o.key[i]] = m[i] || "";

  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
    if ($1) uri[o.q.name][$1] = $2;
  });

  return uri;
}

const options = {
  strictMode: false,
  key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
  q: {
    name: "queryKey",
    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
  },
  parser: {
    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
    loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
};

/**
* Resolve a url, which might be a string, function (that returns a string or Promse), or Promise (that resolves to a string)
*
* @param url
* @returns {Promise<*>}
*/
async function resolveURL(url) {
  return (typeof url === 'function') ? url() : url;
}

/**
* Return the filename from the path.   Example
*   https://foo.com/bar.bed?param=2   => bar.bed
* @param urlOrFile
*/

function getFilename$2(urlOrFile) {

  if (urlOrFile.name !== undefined) {
    return urlOrFile.name
  } else if (isString$2(urlOrFile)) {

    let index = urlOrFile.lastIndexOf("/");
    let filename = index < 0 ? urlOrFile : urlOrFile.substr(index + 1);

    //Strip parameters -- handle local files later
    index = filename.indexOf("?");
    if (index > 0) {
      filename = filename.substr(0, index);
    }
    return filename;
  } else {
    throw Error(`Expected File or string, got ${typeof urlOrFile}`);
  }
}

async function getFilenameExtended(path) {

  if (isFile$1(path)) {
    return path.name
  } else if (isGoogleDriveURL(path)) {
    if (typeof gapi === "undefined") {
      throw Error(`Google initialization with API key is required to load Google urls (${path})`)
    }
    const info = await getDriveFileInfo(path);
    return info.name || info.originalFileName
  } else {
    const result = parseUri(path);
    return result.file;
  }

}

/**
* Test if object is a File or File-like object.
*
* @param object
*/
function isFile$1(object) {
  if (!object) {
    return false;
  }
  return typeof object !== 'function' &&
    (object instanceof File ||
      (object.hasOwnProperty("name") && typeof object.slice === 'function' && typeof object.arrayBuffer === 'function'))
}

// Uncompress data,  assumed to be series of bgzipped blocks
function unbgzf(data, lim) {

  const oBlockList = [];
  let ptr = 0;
  let totalSize = 0;

  lim = lim || data.byteLength - 18;

  while (ptr < lim) {
    try {
      const ba = new Uint8Array(data, ptr, 18);
      const xlen = (ba[11] << 8) | (ba[10]);
      const si1 = ba[12];
      const si2 = ba[13];
      const slen = (ba[15] << 8) | (ba[14]);
      const bsize = ((ba[17] << 8) | (ba[16])) + 1;
      const start = 12 + xlen + ptr;    // Start of CDATA
      const bytesLeft = data.byteLength - start;
      const cDataSize = bsize - xlen - 19;
      if (bytesLeft < cDataSize || cDataSize <= 0) break;

      const a = new Uint8Array(data, start, cDataSize);
      const inflate = new Zlib$2.RawInflate(a);
      const unc = inflate.decompress();

      ptr += inflate.ip + 26;
      totalSize += unc.byteLength;
      oBlockList.push(unc);
    } catch (e) {
      console.error(e);
      break;
    }
  }

  // Concatenate decompressed blocks
  if (oBlockList.length === 1) {
    return oBlockList[0];
  } else {
    const out = new Uint8Array(totalSize);
    let cursor = 0;
    for (let i = 0; i < oBlockList.length; ++i) {
      var b = new Uint8Array(oBlockList[i]);
      arrayCopy(b, 0, out, cursor, b.length);
      cursor += b.length;
    }
    return out;
  }
}

function bgzBlockSize(data) {
  const ba = new Uint8Array(data);
  const bsize = (ba[17] << 8 | ba[16]) + 1;
  return bsize;
}

// From Thomas Down's zlib implementation

const testArray = new Uint8Array(1);
const hasSubarray = (typeof testArray.subarray === 'function');

function arrayCopy(src, srcOffset, dest, destOffset, count) {
  if (count === 0) {
    return;
  }
  if (!src) {
    throw "Undef src";
  } else if (!dest) {
    throw "Undef dest";
  }
  if (srcOffset === 0 && count === src.length) {
    arrayCopy_fast(src, dest, destOffset);
  } else if (hasSubarray) {
    arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset);
  } else if (src.BYTES_PER_ELEMENT === 1 && count > 100) {
    arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);
  } else {
    arrayCopy_slow(src, srcOffset, dest, destOffset, count);
  }
}

function arrayCopy_slow(src, srcOffset, dest, destOffset, count) {
  for (let i = 0; i < count; ++i) {
    dest[destOffset + i] = src[srcOffset + i];
  }
}

function arrayCopy_fast(src, dest, destOffset) {
  dest.set(src, destOffset);
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
* Author: Jim Robinson
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/
const IGVMath = {

  lerp: (v0, v1, t) => {
    return (1 - t) * v0 + t * v1;
  },

  mean: function (array) {

    var t = 0, n = 0,
      i;
    for (i = 0; i < array.length; i++) {
      if (!isNaN(array[i])) {
        t += array[i];
        n++;
      }
    }
    return n > 0 ? t / n : 0;
  },

  meanAndStdev: function (array) {

    var v, t = 0, t2 = 0, n = 0, i;

    for (i = 0; i < array.length; i++) {

      v = array[i];

      if (!isNaN(v)) {
        t += v;
        t2 += v * v;
        n++;
      }
    }
    return n > 0 ? { mean: t / n, stdev: Math.sqrt(t2 - t * t / n) } : { mean: 0, stdev: 0 };
  },

  median: function (numbers) {
    // median of [3, 5, 4, 4, 1, 1, 2, 3] = 3
    var median = 0, numsLen = numbers.length;
    numbers.sort();

    if (
      numsLen % 2 === 0 // is even
    ) {
      // average of two middle numbers
      median = (numbers[numsLen / 2 - 1] + numbers[numsLen / 2]) / 2;
    } else { // is odd
      // middle number only
      median = numbers[(numsLen - 1) / 2];
    }

    return median;
  },

  // Fast percentile function for "p" near edges.  This needs profiled for p in middle (e.g. median)
  percentile: function (array, p) {

    if (array.length === 0) return undefined;

    var k = Math.floor(array.length * ((100 - p) / 100));
    if (k === 0) {
      array.sort(function (a, b) {
        return b - a
      });
      return array[k];
    } else {
      return selectElement(array, k);
    }

  },


  clamp: function (value, min, max) {
    return Math.min(Math.max(value, min), max);
  },

  log2: function (x) {
    return Math.log(x) / Math.LN2;
  }

};

function selectElement(array, k) {

  // Credit Steve Hanov http://stevehanov.ca/blog/index.php?id=122
  var heap = new BinaryHeap(),
    i;

  for (i = 0; i < array.length; i++) {

    var item = array[i];

    // If we have not yet found k items, or the current item is larger than
    // the smallest item on the heap, add current item
    if (heap.content.length < k || item > heap.content[0]) {
      // If the heap is full, remove the smallest element on the heap.
      if (heap.content.length === k) {
        heap.pop();
      }
      heap.push(item);
    }
  }

  return heap.content[0];
}


function BinaryHeap() {
  this.content = [];
}

BinaryHeap.prototype = {
  push: function (element) {
    // Add the new element to the end of the array.
    this.content.push(element);
    // Allow it to bubble up.
    this.bubbleUp(this.content.length - 1);
  },

  pop: function () {
    // Store the first element so we can return it later.
    var result = this.content[0];
    // Get the element at the end of the array.
    var end = this.content.pop();
    // If there are any elements left, put the end element at the
    // start, and let it sink down.
    if (this.content.length > 0) {
      this.content[0] = end;
      this.sinkDown(0);
    }
    return result;
  },

  remove: function (node) {
    var length = this.content.length;
    // To remove a value, we must search through the array to find
    // it.
    for (var i = 0; i < length; i++) {
      if (this.content[i] !== node) continue;
      // When it is found, the process seen in 'pop' is repeated
      // to fill up the hole.
      var end = this.content.pop();
      // If the element we popped was the one we needed to remove,
      // we're done.
      if (i === length - 1) break;
      // Otherwise, we replace the removed element with the popped
      // one, and allow it to float up or sink down as appropriate.
      this.content[i] = end;
      this.bubbleUp(i);
      this.sinkDown(i);
      break;
    }
  },

  size: function () {
    return this.content.length;
  },

  bubbleUp: function (n) {
    // Fetch the element that has to be moved.
    var element = this.content[n], score = element;
    // When at 0, an element can not go up any further.
    while (n > 0) {
      // Compute the parent element's index, and fetch it.
      var parentN = Math.floor((n + 1) / 2) - 1,
        parent = this.content[parentN];
      // If the parent has a lesser score, things are in order and we
      // are done.
      if (score >= parent)
        break;

      // Otherwise, swap the parent with the current element and
      // continue.
      this.content[parentN] = element;
      this.content[n] = parent;
      n = parentN;
    }
  },

  sinkDown: function (n) {
    // Look up the target element and its score.
    var length = this.content.length,
      element = this.content[n],
      elemScore = element;

    while (true) {
      // Compute the indices of the child elements.
      var child2N = (n + 1) * 2, child1N = child2N - 1;
      // This is used to store the new position of the element,
      // if any.
      var swap = null;
      // If the first child exists (is inside the array)...
      if (child1N < length) {
        // Look it up and compute its score.
        var child1 = this.content[child1N],
          child1Score = child1;
        // If the score is less than our element's, we need to swap.
        if (child1Score < elemScore)
          swap = child1N;
      }
      // Do the same checks for the other child.
      if (child2N < length) {
        var child2 = this.content[child2N],
          child2Score = child2;
        if (child2Score < (swap == null ? elemScore : child1Score))
          swap = child2N;
      }

      // No need to swap further, we are done.
      if (swap == null) break;

      // Otherwise, swap and continue.
      this.content[n] = this.content[swap];
      this.content[swap] = element;
      n = swap;
    }
  }
};

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

function _random(min, max) {
  return Math.random() * (max - min) + min;
}

const IGVColor = {

  rgbListFromHSV: () => {

    let s = 1;
    let accumulation = [];
    for (let v = 1; v >= 0.5; v -= .1) {
      for (let h = 0; h < 1; h += 1 / 28) {
        const r = "rgb(" + IGVColor.hsvToRgb(h, s, v).join(",") + ")";
        accumulation.push(r);
      }
    }

    // add black
    accumulation.pop();
    accumulation.push(IGVColor.rgbColor(16, 16, 16));

    return accumulation;
  },

  rgbToHex: function (rgb) {
    rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
    return (rgb && rgb.length === 4) ? "#" +
      ("0" + parseInt(rgb[1], 10).toString(16)).slice(-2) +
      ("0" + parseInt(rgb[2], 10).toString(16)).slice(-2) +
      ("0" + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';
  },

  hexToRgb: function (hex) {

    var cooked = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

    if (null === cooked) {
      return undefined;
    }

    return "rgb(" + parseInt(cooked[1], 16) + "," + parseInt(cooked[2], 16) + "," + parseInt(cooked[3], 16) + ")";
  },

  /**
   * Converts an HSV color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
   * Assumes h, s, and v are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * Credit: https://gist.githubusercontent.com/mjackson/5311256
   *
   * @param   h       The hue
   * @param   s       The saturation
   * @param   v       The value
   * @return  Array   The RGB representation
   */
  hsvToRgb: function (h, s, v) {
    var r, g, b;

    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0:
        r = v, g = t, b = p;
        break;
      case 1:
        r = q, g = v, b = p;
        break;
      case 2:
        r = p, g = v, b = t;
        break;
      case 3:
        r = p, g = q, b = v;
        break;
      case 4:
        r = t, g = p, b = v;
        break;
      case 5:
        r = v, g = p, b = q;
        break;
    }

    return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
  },

  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h, s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * Credit: https://gist.githubusercontent.com/mjackson/5311256
   *
   * @param   h       The hue
   * @param   s       The saturation
   * @param   l       The lightness
   * @return  Array   The RGB representation
   */
  hslToRgb: function (h, s, l) {
    var r, g, b;

    if (s === 0) {
      r = g = b = l; // achromatic
    } else {


      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;

      r = IGVColor.hue2rgb(p, q, h + 1 / 3);
      g = IGVColor.hue2rgb(p, q, h);
      b = IGVColor.hue2rgb(p, q, h - 1 / 3);
    }

    return [r * 255, g * 255, b * 255];
  },

  hue2rgb: (p, q, t) => {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  },

  rgbaColor: function (r, g, b, a) {

    r = IGVMath.clamp(r, 0, 255);
    g = IGVMath.clamp(g, 0, 255);
    b = IGVMath.clamp(b, 0, 255);
    a = IGVMath.clamp(a, 0.0, 1.0);

    return "rgba(" + r + "," + g + "," + b + "," + a + ")";
  },

  rgbColor: function (r, g, b) {

    r = IGVMath.clamp(r, 0, 255);
    g = IGVMath.clamp(g, 0, 255);
    b = IGVMath.clamp(b, 0, 255);

    return "rgb(" + r + "," + g + "," + b + ")";
  },

  greyScale: function (value) {

    var grey = IGVMath.clamp(value, 0, 255);

    return "rgb(" + grey + "," + grey + "," + grey + ")";
  },

  randomGrey: function (min, max) {

    min = IGVMath.clamp(min, 0, 255);
    max = IGVMath.clamp(max, 0, 255);

    var g = Math.round(_random(min, max)).toString(10);

    return "rgb(" + g + "," + g + "," + g + ")";
  },

  randomRGB: function (min, max) {

    min = IGVMath.clamp(min, 0, 255);
    max = IGVMath.clamp(max, 0, 255);

    var r = Math.round(_random(min, max)).toString(10);
    var g = Math.round(_random(min, max)).toString(10);
    var b = Math.round(_random(min, max)).toString(10);

    return "rgb(" + r + "," + g + "," + b + ")";
  },

  randomRGBConstantAlpha: function (min, max, alpha) {

    min = IGVMath.clamp(min, 0, 255);
    max = IGVMath.clamp(max, 0, 255);

    var r = Math.round(_random(min, max)).toString(10);
    var g = Math.round(_random(min, max)).toString(10);
    var b = Math.round(_random(min, max)).toString(10);

    return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
  },

  addAlpha: function (color, alpha) {

    if (color === "0" || color === ".") {
      color = "rgb(0,0,0)";
    } else {
      const c = this.colorNameToHex(color);
      if (c) {
        color = c;
      }
    }

    var isHex = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);

    if (color.startsWith("rgba")) {
      const idx = color.lastIndexOf(",");
      return color.substring(0, idx + 1) + alpha.toString() + ")";
    }

    if (isHex) {
      color = IGVColor.hexToRgb(color);
    }

    if (color.startsWith("rgb")) {
      return color.replace("rgb", "rgba").replace(")", ", " + alpha + ")");
    } else {
      console.log(color + " is not an rgb style string");
      return color;
    }
  },

  rgbComponents: function (color) {

    if (color === "0" || color === ".") {
      return [0, 0, 0];
    }
    const isHex = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
    if (isHex) {
      color = IGVColor.hexToRgb(color);
    } else {
      if (!color.startsWith("rgb")) {
        const hex = this.colorNameToHex(color);
        color = this.hexToRgb(hex);
      }
    }

    if (color.startsWith("rgb(")) {
      return color.substring(4, color.length - 1).split(",").map(s => Number.parseInt(s.trim()));
    } else if (color.startsWith("rgba(")) {
      return color.substring(5, color.length - 1).split(",").map((s, i) => {
        s = s.trim();
        return i === 3 ? Number.parseFloat(s) : Number.parseInt(s)
      });
    }
    else {
      throw Error("Unrecognized color string: color");
    }
  },

  /**
   *
   * @param dest  RGB components as an array
   * @param src  RGB components as an array
   * @param alpha   alpha transparancy in the range 0-1
   * @returns {}
   */
  getCompositeColor: function (dest, src, alpha) {

    var r = Math.floor(alpha * src[0] + (1 - alpha) * dest[0]),
      g = Math.floor(alpha * src[1] + (1 - alpha) * dest[1]),
      b = Math.floor(alpha * src[2] + (1 - alpha) * dest[2]);

    return "rgb(" + r + "," + g + "," + b + ")";

  },


  createColorString: function (str) {
    // Excel will quote color strings, strip all quotes
    str = stripQuotes(str);

    if (str.includes(",")) {
      return str.startsWith("rgb") ? str : "rgb(" + str + ")";
    } else {
      return str;
    }
  },

  darkenLighten: function (color, amt) {

    let src;
    let hexColor = this.colorNameToHex(color);
    if (hexColor) {
      src = IGVColor.hexToRgb(hexColor);
    } else {
      src = color.startsWith('rgb(') ? color : IGVColor.hexToRgb(color);
    }

    const components = src.replace(")", "").substring(4).split(",");

    const r = Math.max(0, Math.min(255, Number.parseInt(components[0].trim()) + amt));
    const g = Math.max(0, Math.min(255, Number.parseInt(components[1].trim()) + amt));
    const b = Math.max(0, Math.min(255, Number.parseInt(components[2].trim()) + amt));

    return 'rgb(' + r.toString() + ',' + g.toString() + ',' + b.toString() + ')';

  },

  /**
   * Convert html/css color name to hex value.  Adapted from https://gist.github.com/mxfh/4719348
   * @param colorName
   * @returns {*}
   */
  colorNameToHex: function (colorName) { // color list from http://stackoverflow.com/q/1573053/731179  with added gray/gray
    const definedColorNames = {
      "aliceblue": "#f0f8ff",
      "antiquewhite": "#faebd7",
      "aqua": "#00ffff",
      "aquamarine": "#7fffd4",
      "azure": "#f0ffff",
      "beige": "#f5f5dc",
      "bisque": "#ffe4c4",
      "black": "#000000",
      "blanchedalmond": "#ffebcd",
      "blue": "#0000ff",
      "blueviolet": "#8a2be2",
      "brown": "#a52a2a",
      "burlywood": "#deb887",
      "cadetblue": "#5f9ea0",
      "chartreuse": "#7fff00",
      "chocolate": "#d2691e",
      "coral": "#ff7f50",
      "cornflowerblue": "#6495ed",
      "cornsilk": "#fff8dc",
      "crimson": "#dc143c",
      "cyan": "#00ffff",
      "darkblue": "#00008b",
      "darkcyan": "#008b8b",
      "darkgoldenrod": "#b8860b",
      "darkgray": "#a9a9a9",
      "darkgreen": "#006400",
      "darkkhaki": "#bdb76b",
      "darkmagenta": "#8b008b",
      "darkolivegreen": "#556b2f",
      "darkorange": "#ff8c00",
      "darkorchid": "#9932cc",
      "darkred": "#8b0000",
      "darksalmon": "#e9967a",
      "darkseagreen": "#8fbc8f",
      "darkslateblue": "#483d8b",
      "darkslategray": "#2f4f4f",
      "darkturquoise": "#00ced1",
      "darkviolet": "#9400d3",
      "deeppink": "#ff1493",
      "deepskyblue": "#00bfff",
      "dimgray": "#696969",
      "dodgerblue": "#1e90ff",
      "firebrick": "#b22222",
      "floralwhite": "#fffaf0",
      "forestgreen": "#228b22",
      "fuchsia": "#ff00ff",
      "gainsboro": "#dcdcdc",
      "ghostwhite": "#f8f8ff",
      "gold": "#ffd700",
      "goldenrod": "#daa520",
      "gray": "#808080",
      "green": "#008000",
      "greenyellow": "#adff2f",
      "honeydew": "#f0fff0",
      "hotpink": "#ff69b4",
      "indianred ": "#cd5c5c",
      "indigo ": "#4b0082",
      "ivory": "#fffff0",
      "khaki": "#f0e68c",
      "lavender": "#e6e6fa",
      "lavenderblush": "#fff0f5",
      "lawngreen": "#7cfc00",
      "lemonchiffon": "#fffacd",
      "lightblue": "#add8e6",
      "lightcoral": "#f08080",
      "lightcyan": "#e0ffff",
      "lightgoldenrodyellow": "#fafad2",
      "lightgrey": "#d3d3d3",
      "lightgreen": "#90ee90",
      "lightpink": "#ffb6c1",
      "lightsalmon": "#ffa07a",
      "lightseagreen": "#20b2aa",
      "lightskyblue": "#87cefa",
      "lightslategray": "#778899",
      "lightsteelblue": "#b0c4de",
      "lightyellow": "#ffffe0",
      "lime": "#00ff00",
      "limegreen": "#32cd32",
      "linen": "#faf0e6",
      "magenta": "#ff00ff",
      "maroon": "#800000",
      "mediumaquamarine": "#66cdaa",
      "mediumblue": "#0000cd",
      "mediumorchid": "#ba55d3",
      "mediumpurple": "#9370d8",
      "mediumseagreen": "#3cb371",
      "mediumslateblue": "#7b68ee",
      "mediumspringgreen": "#00fa9a",
      "mediumturquoise": "#48d1cc",
      "mediumvioletred": "#c71585",
      "midnightblue": "#191970",
      "mintcream": "#f5fffa",
      "mistyrose": "#ffe4e1",
      "moccasin": "#ffe4b5",
      "navajowhite": "#ffdead",
      "navy": "#000080",
      "oldlace": "#fdf5e6",
      "olive": "#808000",
      "olivedrab": "#6b8e23",
      "orange": "#ffa500",
      "orangered": "#ff4500",
      "orchid": "#da70d6",
      "palegoldenrod": "#eee8aa",
      "palegreen": "#98fb98",
      "paleturquoise": "#afeeee",
      "palevioletred": "#d87093",
      "papayawhip": "#ffefd5",
      "peachpuff": "#ffdab9",
      "peru": "#cd853f",
      "pink": "#ffc0cb",
      "plum": "#dda0dd",
      "powderblue": "#b0e0e6",
      "purple": "#800080",
      "red": "#ff0000",
      "rosybrown": "#bc8f8f",
      "royalblue": "#4169e1",
      "saddlebrown": "#8b4513",
      "salmon": "#fa8072",
      "sandybrown": "#f4a460",
      "seagreen": "#2e8b57",
      "seashell": "#fff5ee",
      "sienna": "#a0522d",
      "silver": "#c0c0c0",
      "skyblue": "#87ceeb",
      "slateblue": "#6a5acd",
      "slategray": "#708090",
      "snow": "#fffafa",
      "springgreen": "#00ff7f",
      "steelblue": "#4682b4",
      "tan": "#d2b48c",
      "teal": "#008080",
      "thistle": "#d8bfd8",
      "tomato": "#ff6347",
      "turquoise": "#40e0d0",
      "violet": "#ee82ee",
      "wheat": "#f5deb3",
      "white": "#ffffff",
      "whitesmoke": "#f5f5f5",
      "yellow": "#ffff00",
      "yellowgreen": "#9acd32",
      "darkgrey": "#a9a9a9",
      "darkslategrey": "#2f4f4f",
      "dimgrey": "#696969",
      "grey": "#808080",
      "lightgray": "#d3d3d3",
      "lightslategrey": "#778899",
      "slategrey": "#708090"
    };
    return definedColorNames[colorName];
  }
};

/**
* Make the target element movable by clicking and dragging on the handle.  This is not a general purprose function,
* it makes several options specific to igv dialogs, the primary one being that the
* target is absolutely positioned in pixel coordinates

*/

let dragData$1;   // Its assumed we are only dragging one element at a time.


function makeDraggable$1(target, handle) {
  handle.addEventListener('mousedown', dragStart$1.bind(target));
}


function dragStart$1(event) {

  event.stopPropagation();
  event.preventDefault();

  offset$1(this);
  const dragFunction = drag$1.bind(this);
  const dragEndFunction = dragEnd$1.bind(this);
  const computedStyle = getComputedStyle(this);
  const top = parseInt(computedStyle.top.replace("px", ""));
  const left = parseInt(computedStyle.left.replace("px", ""));

  dragData$1 =
  {
    dragFunction: dragFunction,
    dragEndFunction: dragEndFunction,
    screenX: event.screenX,
    screenY: event.screenY,
    top: top,
    left: left
  };

  document.addEventListener('mousemove', dragFunction);
  document.addEventListener('mouseup', dragEndFunction);
  document.addEventListener('mouseleave', dragEndFunction);
  document.addEventListener('mouseexit', dragEndFunction);
}

function drag$1(event) {

  if (!dragData$1) {
    console.log("No drag data!");
    return;
  }
  event.stopPropagation();
  event.preventDefault();
  const dx = event.screenX - dragData$1.screenX;
  const dy = event.screenY - dragData$1.screenY;
  this.style.left = `${dragData$1.left + dx}px`;
  this.style.top = `${dragData$1.top + dy}px`;
}

function dragEnd$1(event) {

  if (!dragData$1) {
    console.log("No drag data!");
    return;
  }
  event.stopPropagation();
  event.preventDefault();

  const dragFunction = dragData$1.dragFunction;
  const dragEndFunction = dragData$1.dragEndFunction;
  document.removeEventListener('mousemove', dragFunction);
  document.removeEventListener('mouseup', dragEndFunction);
  document.removeEventListener('mouseleave', dragEndFunction);
  document.removeEventListener('mouseexit', dragEndFunction);
  dragData$1 = undefined;
}

const colorPalettes = {

  Set1:
    [
      "rgb(228,26,28)",
      "rgb(55,126,184)",
      "rgb(77,175,74)",
      "rgb(166,86,40)",
      "rgb(152,78,163)",
      "rgb(255,127,0)",
      "rgb(247,129,191)",
      "rgb(153,153,153)",
      "rgb(255,255,51)"
    ],

  Dark2:
    [
      "rgb(27,158,119)",
      "rgb(217,95,2)",
      "rgb(117,112,179)",
      "rgb(231,41,138)",
      "rgb(102,166,30)",
      "rgb(230,171,2)",
      "rgb(166,118,29)",
      "rgb(102,102,102)"
    ],

  Set2:
    [
      "rgb(102, 194,165)",
      "rgb(252,141,98)",
      "rgb(141,160,203)",
      "rgb(231,138,195)",
      "rgb(166,216,84)",
      "rgb(255,217,47)",
      "rgb(229,196,148)",
      "rgb(179,179,179)"
    ],

  Set3:
    [
      "rgb(141,211,199)",
      "rgb(255,255,179)",
      "rgb(190,186,218)",
      "rgb(251,128,114)",
      "rgb(128,177,211)",
      "rgb(253,180,98)",
      "rgb(179,222,105)",
      "rgb(252,205,229)",
      "rgb(217,217,217)",
      "rgb(188,128,189)",
      "rgb(204,235,197)",
      "rgb(255,237,111)"
    ],

  Pastel1:
    [
      "rgb(251,180,174)",
      "rgb(179,205,227)",
      "rgb(204,235,197)",
      "rgb(222,203,228)",
      "rgb(254,217,166)",
      "rgb(255,255,204)",
      "rgb(229,216,189)",
      "rgb(253,218,236)"
    ],

  Pastel2:
    [
      "rgb(173,226,207)",
      "rgb(253,205,172)",
      "rgb(203,213,232)",
      "rgb(244,202,228)",
      "rgb(230,245,201)",
      "rgb(255,242,174)",
      "rgb(243,225,206)"
    ],

  Accent:
    [
      "rgb(127,201,127)",
      "rgb(190,174,212)",
      "rgb(253,192,134)",
      "rgb(255,255,153)",
      "rgb(56,108,176)",
      "rgb(240,2,127)",
      "rgb(191,91,23)"
    ]
};

function PaletteColorTable(palette) {

  this.colors = colorPalettes[palette];

  if (!Array.isArray(this.colors)) this.colors = [];
  this.colorTable = {};
  this.nextIdx = 0;
  this.colorGenerator = new RandomColorGenerator();

}

PaletteColorTable.prototype.getColor = function (key) {

  if (!this.colorTable.hasOwnProperty(key)) {
    if (this.nextIdx < this.colors.length) {
      this.colorTable[key] = this.colors[this.nextIdx];
    } else {
      this.colorTable[key] = this.colorGenerator.get();
    }
    this.nextIdx++;
  }
  return this.colorTable[key];
};

// Random color generator from https://github.com/sterlingwes/RandomColor/blob/master/rcolor.js
// Free to use & distribute under the MIT license
// Wes Johnson (@SterlingWes)
//
// inspired by http://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/
function RandomColorGenerator() {
  this.hue = Math.random();
  this.goldenRatio = 0.618033988749895;
  this.hexwidth = 2;
}

RandomColorGenerator.prototype.hsvToRgb = function (h, s, v) {
  var h_i = Math.floor(h * 6),
    f = h * 6 - h_i,
    p = v * (1 - s),
    q = v * (1 - f * s),
    t = v * (1 - (1 - f) * s),
    r = 255,
    g = 255,
    b = 255;
  switch (h_i) {
    case 0:
      r = v, g = t, b = p;
      break;
    case 1:
      r = q, g = v, b = p;
      break;
    case 2:
      r = p, g = v, b = t;
      break;
    case 3:
      r = p, g = q, b = v;
      break;
    case 4:
      r = t, g = p, b = v;
      break;
    case 5:
      r = v, g = p, b = q;
      break;
  }
  return [Math.floor(r * 256), Math.floor(g * 256), Math.floor(b * 256)];
};

RandomColorGenerator.prototype.padHex = function (str) {
  if (str.length > this.hexwidth) return str;
  return new Array(this.hexwidth - str.length + 1).join('0') + str;
};

RandomColorGenerator.prototype.get = function (saturation, value) {
  this.hue += this.goldenRatio;
  this.hue %= 1;
  if (typeof saturation !== "number") saturation = 0.5;
  if (typeof value !== "number") value = 0.95;
  var rgb = this.hsvToRgb(this.hue, saturation, value);

  return "#" + this.padHex(rgb[0].toString(16))
    + this.padHex(rgb[1].toString(16))
    + this.padHex(rgb[2].toString(16));

};

// Support for oauth token based authorization
// This class supports explicit setting of an oauth token either globally or for specific hosts.
//
// The variable oauth.google.access_token, which becomes igv.oauth.google.access_token on ES5 conversion is
// supported for backward compatibility

const DEFAULT_HOST = "googleapis";

const oauth = {

  oauthTokens: {},

  setToken: function (token, host) {
    host = host || DEFAULT_HOST;
    this.oauthTokens[host] = token;
    if (host === DEFAULT_HOST) {
      this.google.access_token = token;    // legacy support
    }
  },

  getToken: function (host) {
    host = host || DEFAULT_HOST;
    let token;
    for (let key of Object.keys(this.oauthTokens)) {
      const regex = wildcardToRegExp(key);
      if (regex.test(host)) {
        token = this.oauthTokens[key];
        break;
      }
    }
    return token;
  },

  removeToken: function (host) {
    host = host || DEFAULT_HOST;
    for (let key of Object.keys(this.oauthTokens)) {
      const regex = wildcardToRegExp(key);
      if (regex.test(host)) {
        this.oauthTokens[key] = undefined;
      }
    }
    if (host === DEFAULT_HOST) {
      this.google.access_token = undefined;    // legacy support
    }
  },

  // Special object for google -- legacy support
  google: {
    setToken: function (token) {
      oauth.setToken(token);
    }
  }
};


/**
* Creates a RegExp from the given string, converting asterisks to .* expressions,
* and escaping all other characters.
*
* credit https://gist.github.com/donmccurdy/6d073ce2c6f3951312dfa45da14a420f
*/
function wildcardToRegExp(s) {
  return new RegExp('^' + s.split(/\*+/).map(regExpEscape).join('.*') + '$');
}

/**
* RegExp-escapes all characters in the given string.
*
* credit https://gist.github.com/donmccurdy/6d073ce2c6f3951312dfa45da14a420f
*/
function regExpEscape(s) {
  return s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
}

// The MIT License (MIT)

/**
* @constructor
* @param {Object} options A set op options to pass to the throttle function
*        @param {number} requestsPerSecond The amount of requests per second
*                                          the library will limit to
*/
class Throttle$1 {
  constructor(options) {
    this.requestsPerSecond = options.requestsPerSecond || 10;
    this.lastStartTime = 0;
    this.queued = [];
  }

  /**
   * Adds a promise
   * @param {Function} async function to be executed
   * @param {Object} options A set of options.
   * @return {Promise} A promise
   */
  add(asyncFunction, options) {

    var self = this;
    return new Promise(function (resolve, reject) {
      self.queued.push({
        resolve: resolve,
        reject: reject,
        asyncFunction: asyncFunction,
      });
      self.dequeue();
    });
  }

  /**
   * Adds all the promises passed as parameters
   * @param {Function} promises An array of functions that return a promise
   * @param {Object} options A set of options.
   * @param {number} options.signal An AbortSignal object that can be used to abort the returned promise
   * @param {number} options.weight A "weight" of each operation resolving by array of promises
   * @return {Promise} A promise that succeeds when all the promises passed as options do
   */
  addAll(promises, options) {
    var addedPromises = promises.map(function (promise) {
      return this.add(promise, options);
    }.bind(this));

    return Promise.all(addedPromises);
  };

  /**
   * Dequeues a promise
   * @return {void}
   */
  dequeue() {
    if (this.queued.length > 0) {
      var now = new Date(),
        inc = (1000 / this.requestsPerSecond) + 1,
        elapsed = now - this.lastStartTime;

      if (elapsed >= inc) {
        this._execute();
      } else {
        // we have reached the limit, schedule a dequeue operation
        setTimeout(function () {
          this.dequeue();
        }.bind(this), inc - elapsed);
      }
    }
  }

  /**
   * Executes the promise
   * @private
   * @return {void}
   */
  async _execute() {
    this.lastStartTime = new Date();
    var candidate = this.queued.shift();
    const f = candidate.asyncFunction;
    try {
      const r = await f();
      candidate.resolve(r);
    } catch (e) {
      candidate.reject(e);
    }

  }


}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

var NONE = 0;
var GZIP = 1;
var BGZF = 2;
var UNKNOWN = 3;
let RANGE_WARNING_GIVEN = false;

const googleThrottle = new Throttle$1({
  requestsPerSecond: 8
});

const igvxhr = {

  apiKey: undefined,

  setApiKey: function (key) {
    this.apiKey = key;
  },

  load: load,

  loadArrayBuffer: async function (url, options) {
    options = options || {};
    if (!options.responseType) {
      options.responseType = "arraybuffer";
    }
    if (isFile$1(url)) {
      return loadFileSlice(url, options);
    } else {
      return load(url, options);
    }
  },

  loadJson: async function (url, options) {
    options = options || {};
    const method = options.method || (options.sendData ? "POST" : "GET");
    if (method === "POST") {
      options.contentType = "application/json";
    }
    const result = await this.loadString(url, options);
    if (result) {
      return JSON.parse(result);
    } else {
      return result;
    }
  },

  loadString: async function (path, options) {
    options = options || {};
    if (isFile$1(path)) {
      return loadStringFromFile(path, options);
    } else {
      return loadStringFromUrl(path, options);
    }
  }
};

async function load(url, options) {

  options = options || {};
  const urlType = typeof url;

  // Resolve functions, promises, and functions that return promises
  url = await (typeof url === 'function' ? url() : url);

  if (isFile$1(url)) {
    return loadFileSlice(url, options);
  } else if (typeof url.startsWith === 'function') {   // Test for string
    if (url.startsWith("data:")) {
      return decodeDataURI(url)
    } else {
      if (url.startsWith("https://drive.google.com")) {
        url = driveDownloadURL(url);
      }
      if (isGoogleDriveURL(url) || url.startsWith("https://www.dropbox.com")) {
        return googleThrottle.add(async function () {
          return loadURL(url, options)
        })
      } else {
        return loadURL(url, options);
      }
    }
  } else {
    throw Error(`url must be either a 'File', 'string', 'function', or 'Promise'.  Actual type: ${urlType}`);
  }
}

async function loadURL(url, options) {

  //console.log(`${Date.now()}   ${url}`)
  url = mapUrl$1(url);

  options = options || {};

  let oauthToken = options.oauthToken || getOauthToken(url);
  if (oauthToken) {
    oauthToken = await (typeof oauthToken === 'function' ? oauthToken() : oauthToken);
  }

  return new Promise(function (resolve, reject) {

    // Various Google tansformations
    if (isGoogleURL(url)) {
      if (isGoogleStorageURL(url)) {
        url = translateGoogleCloudURL(url);
      }
      url = addApiKey(url);

      if (isGoogleDriveURL(url)) {
        addTeamDrive(url);
      }

      // If we have an access token try it, but don't force a signIn or request for scopes yet
      if (!oauthToken) {
        oauthToken = getCurrentGoogleAccessToken();
      }
    }

    const headers = options.headers || {};
    if (oauthToken) {
      addOauthHeaders(headers, oauthToken);
    }
    const range = options.range;
    const isChrome = navigator.userAgent.indexOf('Chrome') > -1;
    navigator.vendor.indexOf("Apple") === 0 && /\sSafari\//.test(navigator.userAgent);

    if (range && isChrome && !isAmazonV4Signed(url)) {
      // Hack to prevent caching for byte-ranges. Attempt to fix net:err-cache errors in Chrome
      url += url.includes("?") ? "&" : "?";
      url += "someRandomSeed=" + Math.random().toString(36);
    }

    const xhr = new XMLHttpRequest();
    const sendData = options.sendData || options.body;
    const method = options.method || (sendData ? "POST" : "GET");
    const responseType = options.responseType;
    const contentType = options.contentType;
    const mimeType = options.mimeType;

    xhr.open(method, url);
    //xhr.setRequestHeader('Access-Control-Allow-Origin', '*');

    if (options.timeout) {
      xhr.timeout = options.timeout;
    }

    if (range) {
      var rangeEnd = range.size ? range.start + range.size - 1 : "";
      xhr.setRequestHeader("Range", "bytes=" + range.start + "-" + rangeEnd);
    }
    if (contentType) {
      xhr.setRequestHeader("Content-Type", contentType);
    }
    if (mimeType) {
      xhr.overrideMimeType(mimeType);
    }
    if (responseType) {
      xhr.responseType = responseType;
    }
    if (headers) {
      for (let key of Object.keys(headers)) {
        const value = headers[key];
        xhr.setRequestHeader(key, value);
      }
    }

    // NOTE: using withCredentials with servers that return "*" for access-allowed-origin will fail
    if (options.withCredentials === true) {
      xhr.withCredentials = true;
    }

    xhr.onload = async function (event) {
      // when the url points to a local file, the status is 0 but that is not an error
      if (xhr.status === 0 || (xhr.status >= 200 && xhr.status <= 300)) {
        if (range && xhr.status !== 206 && range.start !== 0) {
          // For small files a range starting at 0 can return the whole file => 200
          // Provide just the slice we asked for, throw out the rest quietly
          // If file is large warn user
          if (xhr.response.length > 100000 && !RANGE_WARNING_GIVEN) {
            alert(`Warning: Range header ignored for URL: ${url}.  This can have performance impacts.`);
          }
          resolve(xhr.response.slice(range.start, range.start + range.size));

        } else {
          resolve(xhr.response);
        }
      } else if ((typeof gapi !== "undefined") &&
        ((xhr.status === 404 || xhr.status === 401 || xhr.status === 403) &&
          isGoogleURL(url)) &&
        !options.retries) {
        tryGoogleAuth();

      } else {
        if (xhr.status === 403) {
          handleError("Access forbidden: " + url);
        } else if (xhr.status === 416) {
          //  Tried to read off the end of the file.   This shouldn't happen, but if it does return an
          handleError("Unsatisfiable range");
        } else {
          handleError(xhr.status);
        }
      }
    };

    xhr.onerror = function (event) {
      if (isGoogleURL(url) && !options.retries) {
        tryGoogleAuth();
      }
      handleError("Error accessing resource: " + url + " Status: " + xhr.status);
    };

    xhr.ontimeout = function (event) {
      handleError("Timed out");
    };

    xhr.onabort = function (event) {
      console.log("Aborted");
      reject(event);
    };

    try {
      xhr.send(sendData);
    } catch (e) {
      reject(e);
    }


    function handleError(error) {
      if (reject) {
        reject(error);
      } else {
        throw error;
      }
    }

    async function tryGoogleAuth() {
      try {
        const accessToken = await fetchGoogleAccessToken(url);
        options.retries = 1;
        options.oauthToken = accessToken;
        const response = await load(url, options);
        resolve(response);
      } catch (e) {
        if (e.error) {
          const msg = e.error.startsWith("popup_blocked") ?
            "Google login popup blocked by browser." :
            e.error;
          alert(msg);
        } else {
          handleError(e);
        }
      }
    }
  })

}

async function loadFileSlice(localfile, options) {

  let blob = (options && options.range) ?
    localfile.slice(options.range.start, options.range.start + options.range.size) :
    localfile;

  if ("arraybuffer" === options.responseType) {
    return blobToArrayBuffer(blob);
  } else {
    // binary string format, shouldn't be used anymore
    return new Promise(function (resolve, reject) {
      const fileReader = new FileReader();
      fileReader.onload = function (e) {
        resolve(fileReader.result);
      };
      fileReader.onerror = function (e) {
        console.error("reject uploading local file " + localfile.name);
        reject(null, fileReader);
      };
      fileReader.readAsBinaryString(blob);
      console.warn("Deprecated method used: readAsBinaryString");
    })
  }
}

async function loadStringFromFile(localfile, options) {

  const blob = options.range ? localfile.slice(options.range.start, options.range.start + options.range.size) : localfile;
  let compression = NONE;
  if (options && options.bgz || localfile.name.endsWith(".bgz")) {
    compression = BGZF;
  } else if (localfile.name.endsWith(".gz")) {
    compression = GZIP;
  }

  if (compression === NONE) {
    return blobToText(blob);
  } else {
    const arrayBuffer = await blobToArrayBuffer(blob);
    return arrayBufferToString(arrayBuffer, compression);
  }
}

async function blobToArrayBuffer(blob) {
  if (typeof blob.arrayBuffer === 'function') {
    return blob.arrayBuffer();
  }
  return new Promise(function (resolve, reject) {
    const fileReader = new FileReader();
    fileReader.onload = function (e) {
      resolve(fileReader.result);
    };
    fileReader.onerror = function (e) {
      console.error("reject uploading local file " + localfile.name);
      reject(null, fileReader);
    };
    fileReader.readAsArrayBuffer(blob);
  })
}

async function blobToText(blob) {
  if (typeof blob.text === 'function') {
    return blob.text();
  }
  return new Promise(function (resolve, reject) {
    const fileReader = new FileReader();
    fileReader.onload = function (e) {
      resolve(fileReader.result);
    };
    fileReader.onerror = function (e) {
      console.error("reject uploading local file " + localfile.name);
      reject(null, fileReader);
    };
    fileReader.readAsText(blob);
  })
}

async function loadStringFromUrl(url, options) {

  options = options || {};

  const fn = options.filename || await getFilename$1(url);
  let compression = UNKNOWN;
  if (options.bgz) {
    compression = BGZF;
  } else if (fn.endsWith(".gz")) {
    compression = GZIP;
  }

  options.responseType = "arraybuffer";
  const data = await igvxhr.load(url, options);
  return arrayBufferToString(data, compression);
}


function isAmazonV4Signed(url) {
  return url.indexOf("X-Amz-Signature") > -1;
}

function getOauthToken(url) {

  // Google is the default provider, don't try to parse host for google URLs
  const host = isGoogleURL(url) ?
    undefined :
    parseUri(url).host;
  let token = oauth.getToken(host);
  if (token) {
    return token;
  } else if (host === undefined) {
    const googleToken = getCurrentGoogleAccessToken();
    if (googleToken && googleToken.expires_at > Date.now()) {
      return googleToken.access_token;
    }
  }
}

/**
* Return a Google oAuth token, triggering a sign in if required.   This method should not be called until we know
* a token is required, that is until we've tried the url and received a 401, 403, or 404.
*
* @param url
* @returns the oauth token
*/
async function fetchGoogleAccessToken(url) {
  console.log("Fetch token for " + url);
  if (isInitialized()) {
    const scope = getScopeForURL(url);
    const googleToken = await getAccessToken(scope);
    return googleToken ? googleToken.access_token : undefined;
  } else {
    throw Error(
      `Authorization is required, but Google oAuth has not been initalized. Contact your site administrator for assistance.`)
  }
}

/**
* Return the current google access token, if one exists.  Do not triger signOn or request additional scopes.
* @returns {undefined|access_token}
*/
function getCurrentGoogleAccessToken() {
  if (isInitialized()) {
    const googleToken = getCurrentAccessToken();
    return googleToken ? googleToken.access_token : undefined;
  } else {
    return undefined;
  }
}

function addOauthHeaders(headers, acToken) {
  if (acToken) {
    headers["Cache-Control"] = "no-cache";
    headers["Authorization"] = "Bearer " + acToken;
  }
  return headers;
}


function addApiKey(url) {
  let apiKey = igvxhr.apiKey;
  if (!apiKey && typeof gapi !== "undefined") {
    apiKey = gapi.apiKey;
  }
  if (apiKey !== undefined && !url.includes("key=")) {
    const paramSeparator = url.includes("?") ? "&" : "?";
    url = url + paramSeparator + "key=" + apiKey;
  }
  return url;
}

function addTeamDrive(url) {
  if (url.includes("supportsTeamDrive")) {
    return url;
  } else {
    const paramSeparator = url.includes("?") ? "&" : "?";
    url = url + paramSeparator + "supportsTeamDrive=true";
  }
}

/**
* Perform some well-known url mappings.
* @param url
*/
function mapUrl$1(url) {

  if (url.includes("//www.dropbox.com")) {
    return url.replace("//www.dropbox.com", "//dl.dropboxusercontent.com");
  } else if (url.includes("//drive.google.com")) {
    return driveDownloadURL(url);
  } else if (url.includes("//www.broadinstitute.org/igvdata")) {
    return url.replace("//www.broadinstitute.org/igvdata", "//data.broadinstitute.org/igvdata");
  } else if (url.includes("//igvdata.broadinstitute.org")) {
    return url.replace("//igvdata.broadinstitute.org", "https://dn7ywbm9isq8j.cloudfront.net")
  } else if (url.startsWith("ftp://ftp.ncbi.nlm.nih.gov/geo")) {
    return url.replace("ftp://", "https://")
  } else {
    return url;
  }
}


function arrayBufferToString(arraybuffer, compression) {

  if (compression === UNKNOWN && arraybuffer.byteLength > 2) {
    const m = new Uint8Array(arraybuffer, 0, 2);
    if (m[0] === 31 && m[1] === 139) {
      compression = GZIP;
    }
  }

  let plain;
  if (compression === GZIP) {
    const inflate = new Zlib$2.Gunzip(new Uint8Array(arraybuffer));
    plain = inflate.decompress();
  } else if (compression === BGZF) {
    plain = unbgzf(arraybuffer);
  } else {
    plain = new Uint8Array(arraybuffer);
  }

  if ('TextDecoder' in getGlobalObject()) {
    return new TextDecoder().decode(plain);
  } else {
    return decodeUTF8(plain);
  }
}

/**
* Use when TextDecoder is not available (primarily IE).
*
* From: https://gist.github.com/Yaffle/5458286
*
* @param octets
* @returns {string}
*/
function decodeUTF8(octets) {
  var string = "";
  var i = 0;
  while (i < octets.length) {
    var octet = octets[i];
    var bytesNeeded = 0;
    var codePoint = 0;
    if (octet <= 0x7F) {
      bytesNeeded = 0;
      codePoint = octet & 0xFF;
    } else if (octet <= 0xDF) {
      bytesNeeded = 1;
      codePoint = octet & 0x1F;
    } else if (octet <= 0xEF) {
      bytesNeeded = 2;
      codePoint = octet & 0x0F;
    } else if (octet <= 0xF4) {
      bytesNeeded = 3;
      codePoint = octet & 0x07;
    }
    if (octets.length - i - bytesNeeded > 0) {
      var k = 0;
      while (k < bytesNeeded) {
        octet = octets[i + k + 1];
        codePoint = (codePoint << 6) | (octet & 0x3F);
        k += 1;
      }
    } else {
      codePoint = 0xFFFD;
      bytesNeeded = octets.length - i;
    }
    string += String.fromCodePoint(codePoint);
    i += bytesNeeded + 1;
  }
  return string
}


function getGlobalObject() {
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof global !== 'undefined') {
    return global;
  } else {
    return window;
  }
}

async function getFilename$1(url) {
  if (isString$2(url) && url.startsWith("https://drive.google.com")) {
    // This will fail if Google API key is not defined
    if (getApiKey() === undefined) {
      throw Error("Google drive is referenced, but API key is not defined.  An API key is required for Google Drive access");
    }
    const json = await getDriveFileInfo(url);
    return json.originalFileName || json.name;
  } else {
    return getFilename$2(url);
  }
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

/** An implementation of an interval tree, following the explanation.
* from CLR.
*
* Public interface:
*   Constructor  IntervalTree
*   Insertion    insert
*   Search       findOverlapping
*/

var BLACK = 1;
var RED = 2;

var NIL = {};
NIL.color = BLACK;
NIL.parent = NIL;
NIL.left = NIL;
NIL.right = NIL;


class IntervalTree {

  constructor() {
    this.root = NIL;
  }

  insert(start, end, value) {

    var interval = new Interval(start, end, value);
    var x = new Node$1(interval);
    this.treeInsert(x);
    x.color = RED;
    while (x !== this.root && x.parent.color === RED) {
      if (x.parent === x.parent.parent.left) {
        let y = x.parent.parent.right;
        if (y.color === RED) {
          x.parent.color = BLACK;
          y.color = BLACK;
          x.parent.parent.color = RED;
          x = x.parent.parent;
        } else {
          if (x === x.parent.right) {
            x = x.parent;
            leftRotate.call(this, x);
          }
          x.parent.color = BLACK;
          x.parent.parent.color = RED;
          rightRotate.call(this, x.parent.parent);
        }
      } else {
        let y = x.parent.parent.left;
        if (y.color === RED) {
          x.parent.color = BLACK;
          y.color = BLACK;
          x.parent.parent.color = RED;
          x = x.parent.parent;
        } else {
          if (x === x.parent.left) {
            x = x.parent;
            rightRotate.call(this, x);
          }
          x.parent.color = BLACK;
          x.parent.parent.color = RED;
          leftRotate.call(this, x.parent.parent);
        }
      }
    }
    this.root.color = BLACK;
  }

  /**
   *
   * @param start - query interval
   * @param end - query interval
   * @returns Array of all intervals overlapping the query region
   */
  findOverlapping(start, end) {


    var searchInterval = new Interval(start, end, 0);

    if (this.root === NIL) return [];

    var intervals = searchAll.call(this, searchInterval, this.root, []);

    if (intervals.length > 1) {
      intervals.sort(function (i1, i2) {
        return i1.low - i2.low;
      });
    }

    return intervals;
  }

  /**
   * Dump info on intervals to console.  For debugging.
   */
  logIntervals() {

    logNode(this.root, 0);

    function logNode(node, indent) {

      var space = "";
      for (var i = 0; i < indent; i++) space += " ";
      console.log(space + node.interval.low + " " + node.interval.high); // + " " + (node.interval.value ? node.interval.value : " null"));

      indent += 5;

      if (node.left !== NIL) logNode(node.left, indent);
      if (node.right !== NIL) logNode(node.right, indent);
    }

  }

  mapIntervals(func) {

    applyInterval(this.root);

    function applyInterval(node) {

      func(node.interval);

      if (node.left !== NIL) applyInterval(node.left);
      if (node.right !== NIL) applyInterval(node.right);
    }
  }


  /**
   * Note:  Does not maintain RB constraints,  this is done post insert
   *
   * @param x  a Node
   */
  treeInsert(x) {
    var node = this.root;
    var y = NIL;
    while (node !== NIL) {
      y = node;
      if (x.interval.low <= node.interval.low) {
        node = node.left;
      } else {
        node = node.right;
      }
    }
    x.parent = y;

    if (y === NIL) {
      this.root = x;
      x.left = x.right = NIL;
    } else {
      if (x.interval.low <= y.interval.low) {
        y.left = x;
      } else {
        y.right = x;
      }
    }

    applyUpdate.call(this, x);
  }
}

function searchAll(interval, node, results) {

  if (node.interval.overlaps(interval)) {
    results.push(node.interval);
  }

  if (node.left !== NIL && node.left.max >= interval.low) {
    searchAll.call(this, interval, node.left, results);
  }

  if (node.right !== NIL && node.right.min <= interval.high) {
    searchAll.call(this, interval, node.right, results);
  }

  return results;
}

function leftRotate(x) {
  var y = x.right;
  x.right = y.left;
  if (y.left !== NIL) {
    y.left.parent = x;
  }
  y.parent = x.parent;
  if (x.parent === NIL) {
    this.root = y;
  } else {
    if (x.parent.left === x) {
      x.parent.left = y;
    } else {
      x.parent.right = y;
    }
  }
  y.left = x;
  x.parent = y;

  applyUpdate.call(this, x);
  // no need to apply update on y, since it'll y is an ancestor
  // of x, and will be touched by applyUpdate().
}


function rightRotate(x) {
  var y = x.left;
  x.left = y.right;
  if (y.right !== NIL) {
    y.right.parent = x;
  }
  y.parent = x.parent;
  if (x.parent === NIL) {
    this.root = y;
  } else {
    if (x.parent.right === x) {
      x.parent.right = y;
    } else {
      x.parent.left = y;
    }
  }
  y.right = x;
  x.parent = y;


  applyUpdate.call(this, x);
  // no need to apply update on y, since it'll y is an ancestor
  // of x, and will be touched by applyUpdate().
}


// Applies the statistic update on the node and its ancestors.
function applyUpdate(node) {
  while (node !== NIL) {
    var nodeMax = node.left.max > node.right.max ? node.left.max : node.right.max;
    var intervalHigh = node.interval.high;
    node.max = nodeMax > intervalHigh ? nodeMax : intervalHigh;

    var nodeMin = node.left.min < node.right.min ? node.left.min : node.right.min;
    var intervalLow = node.interval.low;
    node.min = nodeMin < intervalLow ? nodeMin : intervalLow;

    node = node.parent;
  }
}


class Interval {
  constructor(low, high, value) {
    this.low = low;
    this.high = high;
    this.value = value;
  }

  equals(other) {
    if (!other) {
      return false;
    }
    if (this === other) {
      return true;
    }
    return (this.low === other.low &&
      this.high === other.high);

  }

  compareTo(other) {
    if (this.low < other.low)
      return -1;
    if (this.low > other.low)
      return 1;

    if (this.high < other.high)
      return -1;
    if (this.high > other.high)
      return 1;

    return 0;
  }

  /**
   * Returns true if this interval overlaps the other.
   */
  overlaps(other) {
    return (this.low <= other.high && other.low <= this.high);
  }
}

function Node$1(interval) {
  this.parent = NIL;
  this.left = NIL;
  this.right = NIL;
  this.interval = interval;
  this.color = RED;
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

/**
* Object for caching lists of features.  Supports effecient queries for sub-range  (chr, start, end)
*
* @param featureList
* @param The genomic range spanned by featureList (optional)
* @constructor
*/

class FeatureCache {

  constructor(featureList, genome, range) {

    featureList = featureList || [];
    this.treeMap = this.buildTreeMap(featureList, genome);
    this.range = range;
    this.count = featureList.length;
  }

  containsRange(genomicRange) {
    // No range means cache contains all features
    return (this.range === undefined || this.range.contains(genomicRange.chr, genomicRange.start, genomicRange.end));
  }

  queryFeatures(chr, start, end) {

    const tree = this.treeMap[chr];

    if (!tree) return [];

    const intervals = tree.findOverlapping(start, end);

    if (intervals.length === 0) {
      return [];
    } else {
      // Trim the list of features in the intervals to those
      // overlapping the requested range.
      // Assumption: features are sorted by start position

      const featureList = [];
      const all = this.allFeatures[chr];
      if (all) {
        for (let interval of intervals) {
          const indexRange = interval.value;
          for (let i = indexRange.start; i < indexRange.end; i++) {
            let feature = all[i];
            if (feature.start > end) break;
            else if (feature.end >= start) {
              featureList.push(feature);
            }
          }
        }
        featureList.sort(function (a, b) {
          return a.start - b.start;
        });
      }
      return featureList;
    }
  };

  /**
   * Returns all features, unsorted.
   *
   * @returns {Array}
   */
  getAllFeatures() {
    return this.allFeatures;
  }

  buildTreeMap(featureList, genome) {

    const treeMap = {};
    const chromosomes = [];
    this.allFeatures = {};

    if (featureList) {
      for (let feature of featureList) {

        let chr = feature.chr;
        // Translate to "official" name
        if (genome) {
          chr = genome.getChromosomeName(chr);
        }

        let geneList = this.allFeatures[chr];
        if (!geneList) {
          chromosomes.push(chr);
          geneList = [];
          this.allFeatures[chr] = geneList;
        }
        geneList.push(feature);
      }


      // Now build interval tree for each chromosome
      for (let chr of chromosomes) {
        const chrFeatures = this.allFeatures[chr];
        chrFeatures.sort(function (f1, f2) {
          return (f1.start === f2.start ? 0 : (f1.start > f2.start ? 1 : -1));
        });
        treeMap[chr] = buildIntervalTree$1(chrFeatures);
      }
    }

    return treeMap;
  }
}

/**
* Build an interval tree from the feature list for fast interval based queries.   We lump features in groups
* of 10, or total size / 100,   to reduce size of the tree.
*
* @param featureList
*/
function buildIntervalTree$1(featureList) {

  const tree = new IntervalTree();
  const len = featureList.length;
  const chunkSize = Math.max(10, Math.round(len / 10));

  for (let i = 0; i < len; i += chunkSize) {
    const e = Math.min(len, i + chunkSize);
    const subArray = new IndexRange(i, e); //featureList.slice(i, e);
    const iStart = featureList[i].start;
    //
    let iEnd = iStart;
    for (let j = i; j < e; j++) {
      iEnd = Math.max(iEnd, featureList[j].end);
    }
    tree.insert(iStart, iEnd, subArray);
  }

  return tree;
}


class IndexRange {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
* Author: Jim Robinson
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

const FeatureUtils = {

  packFeatures: function (features, maxRows, sorted) {

    var start;
    var end;

    if (!features) return;

    maxRows = maxRows || 10000;

    if (!sorted) {
      features.sort(function (a, b) {
        return a.start - b.start;
      });
    }


    if (features.length === 0) {
      return [];

    } else {

      var bucketList = [],
        allocatedCount = 0,
        lastAllocatedCount = 0,
        nextStart,
        row,
        index,
        bucket,
        feature,
        gap = 2,
        bucketStart;

      start = features[0].start;
      end = features[features.length - 1].start;

      bucketStart = Math.max(start, features[0].start);
      nextStart = bucketStart;

      features.forEach(function (alignment) {

        var buckListIndex = Math.max(0, alignment.start - bucketStart);
        if (bucketList[buckListIndex] === undefined) {
          bucketList[buckListIndex] = [];
        }
        bucketList[buckListIndex].push(alignment);
      });


      row = 0;


      while (allocatedCount < features.length && row <= maxRows) {


        while (nextStart <= end) {

          bucket = undefined;

          while (!bucket && nextStart <= end) {

            index = nextStart - bucketStart;
            if (bucketList[index] === undefined) {
              ++nextStart;                     // No buckets at this index
            } else {
              bucket = bucketList[index];
            }

          } // while (bucket)

          if (!bucket) {
            break;
          }
          feature = bucket.pop();
          if (0 === bucket.length) {
            bucketList[index] = undefined;
          }

          feature.row = row;

          nextStart = feature.end + gap;
          ++allocatedCount;

        } // while (nextStart)

        row++;
        nextStart = bucketStart;

        if (allocatedCount === lastAllocatedCount) break;   // Protect from infinite loops

        lastAllocatedCount = allocatedCount;

      } // while (allocatedCount)

    }
  },


  /**
   * Find features overlapping the given interval.  It is assumed that all features share the same chromosome.
   *
   * TODO -- significant overlap with FeatureCache, refactor to combine
   *
   * @param featureList
   * @param start
   * @param end
   */
  findOverlapping: function (featureList, start, end) {

    if (!featureList || featureList.length === 0) {
      return [];
    } else {
      const tree = buildIntervalTree(featureList);
      const intervals = tree.findOverlapping(start, end);

      if (intervals.length === 0) {
        return [];
      } else {
        // Trim the list of features in the intervals to those
        // overlapping the requested range.
        // Assumption: features are sorted by start position

        featureList = [];

        intervals.forEach(function (interval) {
          const intervalFeatures = interval.value;
          const len = intervalFeatures.length;
          for (let i = 0; i < len; i++) {
            const feature = intervalFeatures[i];
            if (feature.start > end) break;
            else if (feature.end > start) {
              featureList.push(feature);
            }
          }
        });

        featureList.sort(function (a, b) {
          return a.start - b.start;
        });

        return featureList;
      }
    }

  }
};


/**
* Build an interval tree from the feature list for fast interval based queries.   We lump features in groups
* of 10, or total size / 100,   to reduce size of the tree.
*
* @param featureList
*/
function buildIntervalTree(featureList) {

  const tree = new IntervalTree();
  const len = featureList.length;
  const chunkSize = Math.max(10, Math.round(len / 100));

  featureList.sort(function (f1, f2) {
    return (f1.start === f2.start ? 0 : (f1.start > f2.start ? 1 : -1));
  });

  for (let i = 0; i < len; i += chunkSize) {
    const e = Math.min(len, i + chunkSize);
    const subArray = featureList.slice(i, e);
    const iStart = subArray[0].start;
    let iEnd = iStart;
    subArray.forEach(function (feature) {
      iEnd = Math.max(iEnd, feature.end);
    });
    tree.insert(iStart, iEnd, subArray);
  }

  return tree;
}

/*!
* jQuery JavaScript Library v3.3.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/parseXML,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-event/ajax,-effects,-effects/Tween,-effects/animatedSelector
* https://jquery.com/
*
* Includes Sizzle.js
* https://sizzlejs.com/
*
* Copyright JS Foundation and other contributors
* Released under the MIT license
* https://jquery.org/license
*
* Date: 2018-01-20T17:24Z
*/

var arr = [];

var document$1 = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call(Object);

var support = {};

var isFunction = function isFunction(obj) {

  // Support: Chrome <=57, Firefox <=52
  // In some browsers, typeof returns "function" for HTML <object> elements
  // (i.e., `typeof document.createElement( "object" ) === "function"`).
  // We don't want to classify *any* DOM node as a function.
  return typeof obj === "function" && typeof obj.nodeType !== "number";
};


var isWindow = function isWindow(obj) {
  return obj != null && obj === obj.window;
};


var preservedScriptAttributes = {
  type: true,
  src: true,
  noModule: true
};

function DOMEval(code, doc, node) {
  doc = doc || document$1;

  var i,
    script = doc.createElement("script");

  script.text = code;
  if (node) {
    for (i in preservedScriptAttributes) {
      if (node[i]) {
        script[i] = node[i];
      }
    }
  }
  doc.head.appendChild(script).parentNode.removeChild(script);
}


function toType(obj) {
  if (obj == null) {
    return obj + "";
  }

  // Support: Android <=2.3 only (functionish RegExp)
  return typeof obj === "object" || typeof obj === "function" ?
    class2type[toString.call(obj)] || "object" :
    typeof obj;
}

// global Symbol
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module


var
  version$1 = "3.3.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/parseXML,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-event/ajax,-effects,-effects/Tween,-effects/animatedSelector",

  // Define a local copy of jQuery
  jQuery = function (selector, context) {

    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init(selector, context);
  },

  // Support: Android <=4.0 only
  // Make sure we trim BOM and NBSP
  rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

  // The current version of jQuery being used
  jquery: version$1,

  constructor: jQuery,

  // The default length of a jQuery object is 0
  length: 0,

  toArray: function () {
    return slice.call(this);
  },

  // Get the Nth element in the matched element set OR
  // Get the whole matched element set as a clean array
  get: function (num) {

    // Return all the elements in a clean array
    if (num == null) {
      return slice.call(this);
    }

    // Return just the one element from the set
    return num < 0 ? this[num + this.length] : this[num];
  },

  // Take an array of elements and push it onto the stack
  // (returning the new matched element set)
  pushStack: function (elems) {

    // Build a new jQuery matched element set
    var ret = jQuery.merge(this.constructor(), elems);

    // Add the old object onto the stack (as a reference)
    ret.prevObject = this;

    // Return the newly-formed element set
    return ret;
  },

  // Execute a callback for every element in the matched set.
  each: function (callback) {
    return jQuery.each(this, callback);
  },

  map: function (callback) {
    return this.pushStack(jQuery.map(this, function (elem, i) {
      return callback.call(elem, i, elem);
    }));
  },

  slice: function () {
    return this.pushStack(slice.apply(this, arguments));
  },

  first: function () {
    return this.eq(0);
  },

  last: function () {
    return this.eq(-1);
  },

  eq: function (i) {
    var len = this.length,
      j = +i + (i < 0 ? len : 0);
    return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
  },

  end: function () {
    return this.prevObject || this.constructor();
  },

  // For internal use only.
  // Behaves like an Array's method, not like a jQuery method.
  push: push,
  sort: arr.sort,
  splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function () {
  var options, name, src, copy, copyIsArray, clone,
    target = arguments[0] || {},
    i = 1,
    length = arguments.length,
    deep = false;

  // Handle a deep copy situation
  if (typeof target === "boolean") {
    deep = target;

    // Skip the boolean and the target
    target = arguments[i] || {};
    i++;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if (typeof target !== "object" && !isFunction(target)) {
    target = {};
  }

  // Extend jQuery itself if only one argument is passed
  if (i === length) {
    target = this;
    i--;
  }

  for (; i < length; i++) {

    // Only deal with non-null/undefined values
    if ((options = arguments[i]) != null) {

      // Extend the base object
      for (name in options) {
        src = target[name];
        copy = options[name];

        // Prevent never-ending loop
        if (target === copy) {
          continue;
        }

        // Recurse if we're merging plain objects or arrays
        if (deep && copy && (jQuery.isPlainObject(copy) ||
          (copyIsArray = Array.isArray(copy)))) {

          if (copyIsArray) {
            copyIsArray = false;
            clone = src && Array.isArray(src) ? src : [];

          } else {
            clone = src && jQuery.isPlainObject(src) ? src : {};
          }

          // Never move original objects, clone them
          target[name] = jQuery.extend(deep, clone, copy);

          // Don't bring in undefined values
        } else if (copy !== undefined) {
          target[name] = copy;
        }
      }
    }
  }

  // Return the modified object
  return target;
};

jQuery.extend({

  // Unique for each copy of jQuery on the page
  expando: "jQuery" + (version$1 + Math.random()).replace(/\D/g, ""),

  // Assume jQuery is ready without the ready module
  isReady: true,

  error: function (msg) {
    throw new Error(msg);
  },

  noop: function () {
  },

  isPlainObject: function (obj) {
    var proto, Ctor;

    // Detect obvious negatives
    // Use toString instead of jQuery.type to catch host objects
    if (!obj || toString.call(obj) !== "[object Object]") {
      return false;
    }

    proto = getProto(obj);

    // Objects with no prototype (e.g., `Object.create( null )`) are plain
    if (!proto) {
      return true;
    }

    // Objects with prototype are plain iff they were constructed by a global Object function
    Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
  },

  isEmptyObject: function (obj) {

    /* eslint-disable no-unused-vars */
    // See https://github.com/eslint/eslint/issues/6125
    var name;

    for (name in obj) {
      return false;
    }
    return true;
  },

  // Evaluates a script in a global context
  globalEval: function (code) {
    DOMEval(code);
  },

  each: function (obj, callback) {
    var length, i = 0;

    if (isArrayLike(obj)) {
      length = obj.length;
      for (; i < length; i++) {
        if (callback.call(obj[i], i, obj[i]) === false) {
          break;
        }
      }
    } else {
      for (i in obj) {
        if (callback.call(obj[i], i, obj[i]) === false) {
          break;
        }
      }
    }

    return obj;
  },

  // Support: Android <=4.0 only
  trim: function (text) {
    return text == null ?
      "" :
      (text + "").replace(rtrim, "");
  },

  // results is for internal usage only
  makeArray: function (arr, results) {
    var ret = results || [];

    if (arr != null) {
      if (isArrayLike(Object(arr))) {
        jQuery.merge(ret,
          typeof arr === "string" ?
            [arr] : arr
        );
      } else {
        push.call(ret, arr);
      }
    }

    return ret;
  },

  inArray: function (elem, arr, i) {
    return arr == null ? -1 : indexOf.call(arr, elem, i);
  },

  // Support: Android <=4.0 only, PhantomJS 1 only
  // push.apply(_, arraylike) throws on ancient WebKit
  merge: function (first, second) {
    var len = +second.length,
      j = 0,
      i = first.length;

    for (; j < len; j++) {
      first[i++] = second[j];
    }

    first.length = i;

    return first;
  },

  grep: function (elems, callback, invert) {
    var callbackInverse,
      matches = [],
      i = 0,
      length = elems.length,
      callbackExpect = !invert;

    // Go through the array, only saving the items
    // that pass the validator function
    for (; i < length; i++) {
      callbackInverse = !callback(elems[i], i);
      if (callbackInverse !== callbackExpect) {
        matches.push(elems[i]);
      }
    }

    return matches;
  },

  // arg is for internal usage only
  map: function (elems, callback, arg) {
    var length, value,
      i = 0,
      ret = [];

    // Go through the array, translating each of the items to their new values
    if (isArrayLike(elems)) {
      length = elems.length;
      for (; i < length; i++) {
        value = callback(elems[i], i, arg);

        if (value != null) {
          ret.push(value);
        }
      }

      // Go through every key on the object,
    } else {
      for (i in elems) {
        value = callback(elems[i], i, arg);

        if (value != null) {
          ret.push(value);
        }
      }
    }

    // Flatten any nested arrays
    return concat.apply([], ret);
  },

  // A global GUID counter for objects
  guid: 1,

  // jQuery.support is not used in Core but other projects attach their
  // properties to it so it needs to exist.
  support: support
});

if (typeof Symbol === "function") {
  jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
}

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
  function (i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

function isArrayLike(obj) {

  // Support: real iOS 8.2 only (not reproducible in simulator)
  // `in` check used to prevent JIT error (gh-2145)
  // hasOwn isn't used here due to false negatives
  // regarding Nodelist length in IE
  var length = !!obj && "length" in obj && obj.length,
    type = toType(obj);

  if (isFunction(obj) || isWindow(obj)) {
    return false;
  }

  return type === "array" || length === 0 ||
    typeof length === "number" && length > 0 && (length - 1) in obj;
}

var Sizzle =
  /*!
* Sizzle CSS Selector Engine v2.3.3
* https://sizzlejs.com/
*
* Copyright jQuery Foundation and other contributors
* Released under the MIT license
* http://jquery.org/license
*
* Date: 2016-08-08
*/
  (function (window) {

    var i,
      support,
      Expr,
      getText,
      isXML,
      tokenize,
      compile,
      select,
      outermostContext,
      sortInput,
      hasDuplicate,

      // Local document vars
      setDocument,
      document,
      docElem,
      documentIsHTML,
      rbuggyQSA,
      rbuggyMatches,
      matches,
      contains,

      // Instance-specific data
      expando = "sizzle" + 1 * new Date(),
      preferredDoc = window.document,
      dirruns = 0,
      done = 0,
      classCache = createCache(),
      tokenCache = createCache(),
      compilerCache = createCache(),
      sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
        }
        return 0;
      },

      // Instance methods
      hasOwn = ({}).hasOwnProperty,
      arr = [],
      pop = arr.pop,
      push_native = arr.push,
      push = arr.push,
      slice = arr.slice,
      // Use a stripped-down indexOf as it's faster than native
      // https://jsperf.com/thor-indexof-vs-for/5
      indexOf = function (list, elem) {
        var i = 0,
          len = list.length;
        for (; i < len; i++) {
          if (list[i] === elem) {
            return i;
          }
        }
        return -1;
      },

      booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

      // Regular expressions

      // http://www.w3.org/TR/css3-selectors/#whitespace
      whitespace = "[\\x20\\t\\r\\n\\f]",

      // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
      identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

      // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
      attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
        // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace +
        // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
        "*\\]",

      pseudos = ":(" + identifier + ")(?:\\((" +
        // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
        // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
        // 3. anything else (capture 2)
        ".*" +
        ")\\)|)",

      // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
      rwhitespace = new RegExp(whitespace + "+", "g"),
      rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

      rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
      rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),

      rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),

      rpseudo = new RegExp(pseudos),
      ridentifier = new RegExp("^" + identifier + "$"),

      matchExpr = {
        "ID": new RegExp("^#(" + identifier + ")"),
        "CLASS": new RegExp("^\\.(" + identifier + ")"),
        "TAG": new RegExp("^(" + identifier + "|[*])"),
        "ATTR": new RegExp("^" + attributes),
        "PSEUDO": new RegExp("^" + pseudos),
        "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
          "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
          "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
        "bool": new RegExp("^(?:" + booleans + ")$", "i"),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
          whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
      },

      rinputs = /^(?:input|select|textarea|button)$/i,
      rheader = /^h\d$/i,

      rnative = /^[^{]+\{\s*\[native \w/,

      // Easily-parseable/retrievable ID or TAG or CLASS selectors
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

      rsibling = /[+~]/,

      // CSS escapes
      // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
      runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
      funescape = function (_, escaped, escapedWhitespace) {
        var high = "0x" + escaped - 0x10000;
        // NaN means non-codepoint
        // Support: Firefox<24
        // Workaround erroneous numeric interpretation of +"0x"
        return high !== high || escapedWhitespace ?
          escaped :
          high < 0 ?
            // BMP codepoint
            String.fromCharCode(high + 0x10000) :
            // Supplemental Plane codepoint (surrogate pair)
            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
      },

      // CSS string/identifier serialization
      // https://drafts.csswg.org/cssom/#common-serializing-idioms
      // eslint-disable-next-line no-control-regex
      rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
      fcssescape = function (ch, asCodePoint) {
        if (asCodePoint) {

          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
          if (ch === "\0") {
            return "\uFFFD";
          }

          // Control characters and (dependent upon position) numbers get escaped as code points
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }

        // Other potentially-special ASCII characters get backslash-escaped
        return "\\" + ch;
      },

      // Used for iframes
      // See setDocument()
      // Removing the function wrapper causes a "Permission Denied"
      // error in IE
      unloadHandler = function () {
        setDocument();
      },

      disabledAncestor = addCombinator(
        function (elem) {
          return elem.disabled === true && ("form" in elem || "label" in elem);
        },
        { dir: "parentNode", next: "legend" }
      );

    // Optimize for push.apply( _, NodeList )
    try {
      push.apply(
        (arr = slice.call(preferredDoc.childNodes)),
        preferredDoc.childNodes
      );
      // Support: Android<4.0
      // Detect silently failing push.apply
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ?

          // Leverage slice if possible
          function (target, els) {
            push_native.apply(target, slice.call(els));
          } :

          // Support: IE<9
          // Otherwise append directly
          function (target, els) {
            var j = target.length,
              i = 0;
            // Can't trust NodeList.length
            while ((target[j++] = els[i++])) {
            }
            target.length = j - 1;
          }
      };
    }

    function Sizzle(selector, context, results, seed) {
      var m, i, elem, nid, match, groups, newSelector,
        newContext = context && context.ownerDocument,

        // nodeType defaults to 9, since context defaults to document
        nodeType = context ? context.nodeType : 9;

      results = results || [];

      // Return early from calls with invalid selector or context
      if (typeof selector !== "string" || !selector ||
        nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

        return results;
      }

      // Try to shortcut find operations (as opposed to filters) in HTML documents
      if (!seed) {

        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;

        if (documentIsHTML) {

          // If the selector is sufficiently simple, try using a "get*By*" DOM method
          // (excepting DocumentFragment context, where the methods don't exist)
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

            // ID selector
            if ((m = match[1])) {

              // Document context
              if (nodeType === 9) {
                if ((elem = context.getElementById(m))) {

                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }

                // Element context
              } else {

                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if (newContext && (elem = newContext.getElementById(m)) &&
                  contains(context, elem) &&
                  elem.id === m) {

                  results.push(elem);
                  return results;
                }
              }

              // Type selector
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;

              // Class selector
            } else if ((m = match[3]) && support.getElementsByClassName &&
              context.getElementsByClassName) {

              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }

          // Take advantage of querySelectorAll
          if (support.qsa &&
            !compilerCache[selector + " "] &&
            (!rbuggyQSA || !rbuggyQSA.test(selector))) {

            if (nodeType !== 1) {
              newContext = context;
              newSelector = selector;

              // qSA looks outside Element context, which is not what we want
              // Thanks to Andrew Dupont for this workaround technique
              // Support: IE <=8
              // Exclude object elements
            } else if (context.nodeName.toLowerCase() !== "object") {

              // Capture the context ID, setting it first if necessary
              if ((nid = context.getAttribute("id"))) {
                nid = nid.replace(rcssescape, fcssescape);
              } else {
                context.setAttribute("id", (nid = expando));
              }

              // Prefix every selector in the list
              groups = tokenize(selector);
              i = groups.length;
              while (i--) {
                groups[i] = "#" + nid + " " + toSelector(groups[i]);
              }
              newSelector = groups.join(",");

              // Expand context for sibling selectors
              newContext = rsibling.test(selector) && testContext(context.parentNode) ||
                context;
            }

            if (newSelector) {
              try {
                push.apply(results,
                  newContext.querySelectorAll(newSelector)
                );
                return results;
              } catch (qsaError) {
              } finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
      }

      // All others
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }

    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *    property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *    deleting the oldest entry
     */
    function createCache() {
      var keys = [];

      function cache(key, value) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key + " ") > Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }

      return cache;
    }

    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }

    /**
     * Support testing using an element
     * @param {Function} fn Passed the created element and returns a boolean result
     */
    function assert(fn) {

      // When unit testing from Node document will be undefined.  We don't care about assertions in that case.
      if (!document) return true;

      var el = document.createElement("fieldset");

      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
        // release memory in IE
        el = null;
      }
    }

    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
        i = arr.length;

      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }

    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */
    function siblingCheck(a, b) {
      var cur = b && a,
        diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
          a.sourceIndex - b.sourceIndex;

      // Use IE sourceIndex if available on both nodes
      if (diff) {
        return diff;
      }

      // Check if b follows a
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }

      return a ? 1 : -1;
    }

    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */
    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }

    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */
    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }

    /**
     * Returns a function to use in pseudos for :enabled/:disabled
     * @param {Boolean} disabled true for :disabled; false for :enabled
     */
    function createDisabledPseudo(disabled) {

      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
      return function (elem) {

        // Only certain elements can match :enabled or :disabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
        if ("form" in elem) {

          // Check for inherited disabledness on relevant non-disabled elements:
          // * listed form-associated elements in a disabled fieldset
          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
          // * option elements in a disabled optgroup
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
          // All such elements have a "form" property.
          if (elem.parentNode && elem.disabled === false) {

            // Option elements defer to a parent optgroup if present
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            }

            // Support: IE 6 - 11
            // Use the isDisabled shortcut property to check for disabled fieldset ancestors
            return elem.isDisabled === disabled ||

              // Where there is no isDisabled, check manually
              /* jshint -W018 */
              elem.isDisabled !== !disabled &&
              disabledAncestor(elem) === disabled;
          }

          return elem.disabled === disabled;

          // Try to winnow out elements that can't be disabled before trusting the disabled property.
          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
          // even exist on them, let alone have a boolean value.
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        }

        // Remaining elements are neither :enabled nor :disabled
        return false;
      };
    }

    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */
    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j,
            matchIndexes = fn([], seed.length, argument),
            i = matchIndexes.length;

          // Match elements found at the specified indexes
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }

    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }

    // Expose support vars for convenience
    support = Sizzle.support = {};

    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */
    isXML = Sizzle.isXML = function (elem) {
      // documentElement is verified for cases where it doesn't yet exist
      // (such as loading iframes in IE - #4833)
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };

    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */
    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare, subWindow,
        doc = node ? node.ownerDocument || node : preferredDoc;

      // Return early if doc is invalid or already selected
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }

      // Update global variables
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document);

      // Support: IE 9-11, Edge
      // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
      if (preferredDoc !== document &&
        (subWindow = document.defaultView) && subWindow.top !== subWindow) {

        // Support: IE 11, Edge
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false);

          // Support: IE 9 - 10 only
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      }

      /* Attributes
---------------------------------------------------------------------- */

      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties
      // (excepting IE8 booleans)
      support.attributes = assert(function (el) {
        el.className = "i";
        return !el.getAttribute("className");
      });

      /* getElement(s)By*
---------------------------------------------------------------------- */

      // Check if getElementsByTagName("*") returns only elements
      support.getElementsByTagName = assert(function (el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      });

      // Support: IE<9
      support.getElementsByClassName = rnative.test(document.getElementsByClassName);

      // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programmatically-set names,
      // so use a roundabout getElementsByName test
      support.getById = assert(function (el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      });

      // ID filter and find
      if (support.getById) {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== "undefined" &&
              elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };

        // Support: IE 6 - 7 only
        // getElementById is not reliable as a find shortcut
        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node, i, elems,
              elem = context.getElementById(id);

            if (elem) {

              // Verify the id attribute
              node = elem.getAttributeNode("id");
              if (node && node.value === id) {
                return [elem];
              }

              // Fall back on getElementsByName
              elems = context.getElementsByName(id);
              i = 0;
              while ((elem = elems[i++])) {
                node = elem.getAttributeNode("id");
                if (node && node.value === id) {
                  return [elem];
                }
              }
            }

            return [];
          }
        };
      }

      // Tag
      Expr.find["TAG"] = support.getElementsByTagName ?
        function (tag, context) {
          if (typeof context.getElementsByTagName !== "undefined") {
            return context.getElementsByTagName(tag);

            // DocumentFragment nodes don't have gEBTN
          } else if (support.qsa) {
            return context.querySelectorAll(tag);
          }
        } :

        function (tag, context) {
          var elem,
            tmp = [],
            i = 0,
            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
            results = context.getElementsByTagName(tag);

          // Filter out possible comments
          if (tag === "*") {
            while ((elem = results[i++])) {
              if (elem.nodeType === 1) {
                tmp.push(elem);
              }
            }

            return tmp;
          }
          return results;
        };

      // Class
      Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };

      /* QSA/matchesSelector
---------------------------------------------------------------------- */

      // QSA and matchesSelector support

      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
      rbuggyMatches = [];

      // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See https://bugs.jquery.com/ticket/13378
      rbuggyQSA = [];

      if ((support.qsa = rnative.test(document.querySelectorAll))) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (el) {
          // Select is set to empty string on purpose
          // This is to test IE's treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // https://bugs.jquery.com/ticket/12359
          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" +
            "<select id='" + expando + "-\r\\' msallowcapture=''>" +
            "<option selected=''></option></select>";

          // Support: IE8, Opera 11-12.16
          // Nothing should be selected when empty strings follow ^= or $= or *=
          // The test attribute must be unknown in Opera but "safe" for WinRT
          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }

          // Support: IE8
          // Boolean attributes and "value" are not treated correctly
          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }

          // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }

          // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests
          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }

          // Support: Safari 8+, iOS 8+
          // https://bugs.webkit.org/show_bug.cgi?id=136851
          // In-page `selector#id sibling-combinator selector` fails
          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });

        assert(function (el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" +
            "<select disabled='disabled'><option/></select>";

          // Support: Windows 8 Native Apps
          // The type and name attributes are restricted during .innerHTML assignment
          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D");

          // Support: IE8
          // Enforce case-sensitivity of name attribute
          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }

          // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests
          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }

          // Support: IE9-11+
          // IE's :disabled selector does not pick up the children of disabled fieldsets
          docElem.appendChild(el).disabled = true;
          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }

          // Opera 10-11 does not throw on post-comma invalid pseudos
          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }

      if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
        docElem.webkitMatchesSelector ||
        docElem.mozMatchesSelector ||
        docElem.oMatchesSelector ||
        docElem.msMatchesSelector)))) {

        assert(function (el) {
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(el, "*");

          // This should fail with an exception
          // Gecko does not error, returns false instead
          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }

      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

      /* Contains
---------------------------------------------------------------------- */
      hasCompare = rnative.test(docElem.compareDocumentPosition);

      // Element contains another
      // Purposefully self-exclusive
      // As in, an element does not contain itself
      contains = hasCompare || rnative.test(docElem.contains) ?
        function (a, b) {
          var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
          return a === bup || !!(bup && bup.nodeType === 1 && (
            adown.contains ?
              adown.contains(bup) :
              a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
          ));
        } :
        function (a, b) {
          if (b) {
            while ((b = b.parentNode)) {
              if (b === a) {
                return true;
              }
            }
          }
          return false;
        };

      /* Sorting
---------------------------------------------------------------------- */

      // Document order sorting
      sortOrder = hasCompare ?
        function (a, b) {

          // Flag for duplicate removal
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }

          // Sort on method existence if only one input has compareDocumentPosition
          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
          if (compare) {
            return compare;
          }

          // Calculate position if both inputs belong to the same document
          compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
            a.compareDocumentPosition(b) :

            // Otherwise we know they are disconnected
            1;

          // Disconnected nodes
          if (compare & 1 ||
            (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

            // Choose the first element that is related to our preferred document
            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
              return -1;
            }
            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
              return 1;
            }

            // Maintain original order
            return sortInput ?
              (indexOf(sortInput, a) - indexOf(sortInput, b)) :
              0;
          }

          return compare & 4 ? -1 : 1;
        } :
        function (a, b) {
          // Exit early if the nodes are identical
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }

          var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];

          // Parentless nodes are either documents or disconnected
          if (!aup || !bup) {
            return a === document ? -1 :
              b === document ? 1 :
                aup ? -1 :
                  bup ? 1 :
                    sortInput ?
                      (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                      0;

            // If the nodes are siblings, we can do a quick check
          } else if (aup === bup) {
            return siblingCheck(a, b);
          }

          // Otherwise we need full lists of their ancestors for comparison
          cur = a;
          while ((cur = cur.parentNode)) {
            ap.unshift(cur);
          }
          cur = b;
          while ((cur = cur.parentNode)) {
            bp.unshift(cur);
          }

          // Walk down the tree looking for a discrepancy
          while (ap[i] === bp[i]) {
            i++;
          }

          return i ?
            // Do a sibling check if the nodes have a common ancestor
            siblingCheck(ap[i], bp[i]) :

            // Otherwise nodes in our document sort first
            ap[i] === preferredDoc ? -1 :
              bp[i] === preferredDoc ? 1 :
                0;
        };

      return document;
    };

    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };

    Sizzle.matchesSelector = function (elem, expr) {
      // Set document vars if needed
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }

      // Make sure that attribute selectors are quoted
      expr = expr.replace(rattributeQuotes, "='$1']");

      if (support.matchesSelector && documentIsHTML &&
        !compilerCache[expr + " "] &&
        (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
        (!rbuggyQSA || !rbuggyQSA.test(expr))) {

        try {
          var ret = matches.call(elem, expr);

          // IE 9's matchesSelector returns false on disconnected nodes
          if (ret || support.disconnectedMatch ||
            // As well, disconnected nodes are said to be in a document
            // fragment in IE 9
            elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
        }
      }

      return Sizzle(expr, document, null, [elem]).length > 0;
    };

    Sizzle.contains = function (context, elem) {
      // Set document vars if needed
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };

    Sizzle.attr = function (elem, name) {
      // Set document vars if needed
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }

      var fn = Expr.attrHandle[name.toLowerCase()],
        // Don't get fooled by Object.prototype properties (jQuery #13807)
        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
          fn(elem, name, !documentIsHTML) :
          undefined;

      return val !== undefined ?
        val :
        support.attributes || !documentIsHTML ?
          elem.getAttribute(name) :
          (val = elem.getAttributeNode(name)) && val.specified ?
            val.value :
            null;
    };

    Sizzle.escape = function (sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };

    Sizzle.error = function (msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };

    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */
    Sizzle.uniqueSort = function (results) {
      var elem,
        duplicates = [],
        j = 0,
        i = 0;

      // Unless we *know* we can detect duplicates, assume their presence
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);

      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }

      // Clear input after sorting to release objects
      // See https://github.com/jquery/sizzle/pull/225
      sortInput = null;

      return results;
    };

    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */
    getText = Sizzle.getText = function (elem) {
      var node,
        ret = "",
        i = 0,
        nodeType = elem.nodeType;

      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        while ((node = elem[i++])) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      // Do not include comment or processing instruction nodes

      return ret;
    };

    Expr = Sizzle.selectors = {

      // Can be adjusted by the user
      cacheLength: 50,

      createPseudo: markFunction,

      match: matchExpr,

      attrHandle: {},

      find: {},

      relative: {
        ">": { dir: "parentNode", first: true },
        " ": { dir: "parentNode" },
        "+": { dir: "previousSibling", first: true },
        "~": { dir: "previousSibling" }
      },

      preFilter: {
        "ATTR": function (match) {
          match[1] = match[1].replace(runescape, funescape);

          // Move the given value to match[3] whether quoted or unquoted
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }

          return match.slice(0, 4);
        },

        "CHILD": function (match) {
          /* matches from matchExpr["CHILD"]
1 type (only|nth|...)
2 what (child|of-type)
3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
4 xn-component of xn+y argument ([+-]?\d*n|)
5 sign of xn-component
6 x of xn-component
7 sign of y-component
8 y of y-component
*/
          match[1] = match[1].toLowerCase();

          if (match[1].slice(0, 3) === "nth") {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            }

            // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");

            // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }

          return match;
        },

        "PSEUDO": function (match) {
          var excess,
            unquoted = !match[6] && match[2];

          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }

          // Accept quoted arguments as-is
          if (match[3]) {
            match[2] = match[4] || match[5] || "";

            // Strip excess characters from unquoted arguments
          } else if (unquoted && rpseudo.test(unquoted) &&
            // Get excess from tokenize (recursively)
            (excess = tokenize(unquoted, true)) &&
            // advance to the next closing parenthesis
            (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }

          // Return only captures needed by the pseudo filter method (type and argument)
          return match.slice(0, 3);
        }
      },

      filter: {

        "TAG": function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ?
            function () {
              return true;
            } :
            function (elem) {
              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
            };
        },

        "CLASS": function (className) {
          var pattern = classCache[className + " "];

          return pattern ||
            (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
            classCache(className, function (elem) {
              return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
            });
        },

        "ATTR": function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);

            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }

            result += "";

            return operator === "=" ? result === check :
              operator === "!=" ? result !== check :
                operator === "^=" ? check && result.indexOf(check) === 0 :
                  operator === "*=" ? check && result.indexOf(check) > -1 :
                    operator === "$=" ? check && result.slice(-check.length) === check :
                      operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
                        operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                          false;
          };
        },

        "CHILD": function (type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
            forward = type.slice(-4) !== "last",
            ofType = what === "of-type";

          return first === 1 && last === 0 ?

            // Shortcut for :nth-*(n)
            function (elem) {
              return !!elem.parentNode;
            } :

            function (elem, context, xml) {
              var cache, uniqueCache, outerCache, node, nodeIndex, start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;

              if (parent) {

                // :(first|last|only)-(child|of-type)
                if (simple) {
                  while (dir) {
                    node = elem;
                    while ((node = node[dir])) {
                      if (ofType ?
                        node.nodeName.toLowerCase() === name :
                        node.nodeType === 1) {

                        return false;
                      }
                    }
                    // Reverse direction for :only-* (if we haven't yet done so)
                    start = dir = type === "only" && !start && "nextSibling";
                  }
                  return true;
                }

                start = [forward ? parent.firstChild : parent.lastChild];

                // non-xml :nth-child(...) stores cache data on `parent`
                if (forward && useCache) {

                  // Seek `elem` from a previously-cached index

                  // ...in a gzip-friendly way
                  node = parent;
                  outerCache = node[expando] || (node[expando] = {});

                  // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)
                  uniqueCache = outerCache[node.uniqueID] ||
                    (outerCache[node.uniqueID] = {});

                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex && cache[2];
                  node = nodeIndex && parent.childNodes[nodeIndex];

                  while ((node = ++nodeIndex && node && node[dir] ||

                    // Fallback to seeking `elem` from the start
                    (diff = nodeIndex = 0) || start.pop())) {

                    // When found, cache indexes on `parent` and break
                    if (node.nodeType === 1 && ++diff && node === elem) {
                      uniqueCache[type] = [dirruns, nodeIndex, diff];
                      break;
                    }
                  }

                } else {
                  // Use previously-cached element index if available
                  if (useCache) {
                    // ...in a gzip-friendly way
                    node = elem;
                    outerCache = node[expando] || (node[expando] = {});

                    // Support: IE <9 only
                    // Defend against cloned attroperties (jQuery gh-1709)
                    uniqueCache = outerCache[node.uniqueID] ||
                      (outerCache[node.uniqueID] = {});

                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex;
                  }

                  // xml :nth-child(...)
                  // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                  if (diff === false) {
                    // Use the same loop as above to seek `elem` from the start
                    while ((node = ++nodeIndex && node && node[dir] ||
                      (diff = nodeIndex = 0) || start.pop())) {

                      if ((ofType ?
                        node.nodeName.toLowerCase() === name :
                        node.nodeType === 1) &&
                        ++diff) {

                        // Cache the index of each encountered element
                        if (useCache) {
                          outerCache = node[expando] || (node[expando] = {});

                          // Support: IE <9 only
                          // Defend against cloned attroperties (jQuery gh-1709)
                          uniqueCache = outerCache[node.uniqueID] ||
                            (outerCache[node.uniqueID] = {});

                          uniqueCache[type] = [dirruns, diff];
                        }

                        if (node === elem) {
                          break;
                        }
                      }
                    }
                  }
                }

                // Incorporate the offset, then check against cycle size
                diff -= last;
                return diff === first || (diff % first === 0 && diff / first >= 0);
              }
            };
        },

        "PSEUDO": function (pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args,
            fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
              Sizzle.error("unsupported pseudo: " + pseudo);

          // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does
          if (fn[expando]) {
            return fn(argument);
          }

          // But maintain support for old signatures
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
              markFunction(function (seed, matches) {
                var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
                while (i--) {
                  idx = indexOf(seed, matched[i]);
                  seed[idx] = !(matches[idx] = matched[i]);
                }
              }) :
              function (elem) {
                return fn(elem, 0, args);
              };
          }

          return fn;
        }
      },

      pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [],
            results = [],
            matcher = compile(selector.replace(rtrim, "$1"));

          return matcher[expando] ?
            markFunction(function (seed, matches, context, xml) {
              var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;

              // Match elements unmatched by `matcher`
              while (i--) {
                if ((elem = unmatched[i])) {
                  seed[i] = !(matches[i] = elem);
                }
              }
            }) :
            function (elem, context, xml) {
              input[0] = elem;
              matcher(input, null, xml, results);
              // Don't keep the element (issue #299)
              input[0] = null;
              return !results.pop();
            };
        }),

        "has": markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),

        "contains": markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),

        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction(function (lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ?
                elem.lang :
                elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),

        // Miscellaneous
        "target": function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },

        "root": function (elem) {
          return elem === docElem;
        },

        "focus": function (elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },

        // Boolean properties
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),

        "checked": function (elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },

        "selected": function (elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }

          return elem.selected === true;
        },

        // Contents
        "empty": function (elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
          //   but not by others (comment: 8; processing instruction: 7; etc.)
          // nodeType < 6 works because attributes (2) do not appear as children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },

        "parent": function (elem) {
          return !Expr.pseudos["empty"](elem);
        },

        // Element/input types
        "header": function (elem) {
          return rheader.test(elem.nodeName);
        },

        "input": function (elem) {
          return rinputs.test(elem.nodeName);
        },

        "button": function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },

        "text": function (elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" &&
            elem.type === "text" &&

            // Support: IE<8
            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
            ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },

        // Position-in-collection
        "first": createPositionalPseudo(function () {
          return [0];
        }),

        "last": createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),

        "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),

        "even": createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),

        "odd": createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),

        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),

        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };

    Expr.pseudos["nth"] = Expr.pseudos["eq"];

    // Add button/input type pseudos
    for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in { submit: true, reset: true }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }

    // Easy API for creating new setFilters
    function setFilters() {
    }

    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();

    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched, match, tokens, type,
        soFar, groups, preFilters,
        cached = tokenCache[selector + " "];

      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      while (soFar) {

        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }

        matched = false;

        // Combinators
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }

        // Filters
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
            (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }

        if (!matched) {
          break;
        }
      }

      // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens
      return parseOnly ?
        soFar.length :
        soFar ?
          Sizzle.error(selector) :
          // Cache the tokens
          tokenCache(selector, groups).slice(0);
    };

    function toSelector(tokens) {
      var i = 0,
        len = tokens.length,
        selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }

    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
        skip = combinator.next,
        key = skip || dir,
        checkNonElements = base && key === "parentNode",
        doneName = done++;

      return combinator.first ?
        // Check against closest ancestor/preceding element
        function (elem, context, xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context, xml);
            }
          }
          return false;
        } :

        // Check against all ancestor/preceding elements
        function (elem, context, xml) {
          var oldCache, uniqueCache, outerCache,
            newCache = [dirruns, doneName];

          // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
          if (xml) {
            while ((elem = elem[dir])) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          } else {
            while ((elem = elem[dir])) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {});

                // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)
                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                if (skip && skip === elem.nodeName.toLowerCase()) {
                  elem = elem[dir] || elem;
                } else if ((oldCache = uniqueCache[key]) &&
                  oldCache[0] === dirruns && oldCache[1] === doneName) {

                  // Assign to newCache so results back-propagate to previous elements
                  return (newCache[2] = oldCache[2]);
                } else {
                  // Reuse newcache so results back-propagate to previous elements
                  uniqueCache[key] = newCache;

                  // A match means we're done; a fail means we have to keep checking
                  if ((newCache[2] = matcher(elem, context, xml))) {
                    return true;
                  }
                }
              }
            }
          }
          return false;
        };
    }

    function elementMatcher(matchers) {
      return matchers.length > 1 ?
        function (elem, context, xml) {
          var i = matchers.length;
          while (i--) {
            if (!matchers[i](elem, context, xml)) {
              return false;
            }
          }
          return true;
        } :
        matchers[0];
    }

    function multipleContexts(selector, contexts, results) {
      var i = 0,
        len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }

    function condense(unmatched, map, filter, context, xml) {
      var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;

      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }

      return newUnmatched;
    }

    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function (seed, results, context, xml) {
        var temp, i, elem,
          preMap = [],
          postMap = [],
          preexisting = results.length,

          // Get initial elements from seed or context
          elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

          // Prefilter to get matcher input, preserving a map for seed-results synchronization
          matcherIn = preFilter && (seed || !selector) ?
            condense(elems, preMap, preFilter, context, xml) :
            elems,

          matcherOut = matcher ?
            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
            postFinder || (seed ? preFilter : preexisting || postFilter) ?

              // ...intermediate processing is necessary
              [] :

              // ...otherwise use results directly
              results :
            matcherIn;

        // Find primary matches
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }

        // Apply postFilter
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);

          // Un-match failing elements by moving them back to matcherIn
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }

            // Move matched elements from seed to results to keep them synchronized
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) &&
                (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                seed[temp] = !(results[temp] = elem);
              }
            }
          }

          // Add elements to results, through postFinder if defined
        } else {
          matcherOut = condense(
            matcherOut === results ?
              matcherOut.splice(preexisting, matcherOut.length) :
              matcherOut
          );
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    function matcherFromTokens(tokens) {
      var checkContext, matcher, j,
        len = tokens.length,
        leadingRelative = Expr.relative[tokens[0].type],
        implicitRelative = leadingRelative || Expr.relative[" "],
        i = leadingRelative ? 1 : 0,

        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true),
        matchAnyContext = addCombinator(function (elem) {
          return indexOf(checkContext, elem) > -1;
        }, implicitRelative, true),
        matchers = [function (elem, context, xml) {
          var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
            (checkContext = context).nodeType ?
              matchContext(elem, context, xml) :
              matchAnyContext(elem, context, xml));
          // Avoid hanging onto element (issue #299)
          checkContext = null;
          return ret;
        }];

      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

          // Return special upon seeing a positional matcher
          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(
              i > 1 && elementMatcher(matchers),
              i > 1 && toSelector(
                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })
              ).replace(rtrim, "$1"),
              matcher,
              i < j && matcherFromTokens(tokens.slice(i, j)),
              j < len && matcherFromTokens((tokens = tokens.slice(j))),
              j < len && toSelector(tokens)
            );
          }
          matchers.push(matcher);
        }
      }

      return elementMatcher(matchers);
    }

    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
        byElement = elementMatchers.length > 0,
        superMatcher = function (seed, context, xml, results, outermost) {
          var elem, j, matcher,
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            setMatched = [],
            contextBackup = outermostContext,
            // We must always have either seed elements or outermost context
            elems = seed || byElement && Expr.find["TAG"]("*", outermost),
            // Use integer dirruns iff this is the outermost matcher
            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
            len = elems.length;

          if (outermost) {
            outermostContext = context === document || context || outermost;
          }

          // Add elements passing elementMatchers directly to results
          // Support: IE<9, Safari
          // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
          for (; i !== len && (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              if (!context && elem.ownerDocument !== document) {
                setDocument(elem);
                xml = !documentIsHTML;
              }
              while ((matcher = elementMatchers[j++])) {
                if (matcher(elem, context || document, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
              }
            }

            // Track unmatched elements for set filters
            if (bySet) {
              // They will have gone through all possible matchers
              if ((elem = !matcher && elem)) {
                matchedCount--;
              }

              // Lengthen the array for every element, matched or not
              if (seed) {
                unmatched.push(elem);
              }
            }
          }

          // `i` is now the count of elements visited above, and adding it to `matchedCount`
          // makes the latter nonnegative.
          matchedCount += i;

          // Apply set filters to unmatched elements
          // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
          // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
          // no element matchers and no seed.
          // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
          // case, which will result in a "00" `matchedCount` that differs from `i` but is also
          // numerically zero.
          if (bySet && i !== matchedCount) {
            j = 0;
            while ((matcher = setMatchers[j++])) {
              matcher(unmatched, setMatched, context, xml);
            }

            if (seed) {
              // Reintegrate element matches to eliminate the need for sorting
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }

              // Discard index placeholder values to get only actual matches
              setMatched = condense(setMatched);
            }

            // Add matches to results
            push.apply(results, setMatched);

            // Seedless set matches succeeding multiple successful matchers stipulate sorting
            if (outermost && !seed && setMatched.length > 0 &&
              (matchedCount + setMatchers.length) > 1) {

              Sizzle.uniqueSort(results);
            }
          }

          // Override manipulation of globals by nested matchers
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }

          return unmatched;
        };

      return bySet ?
        markFunction(superMatcher) :
        superMatcher;
    }

    compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
      var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[selector + " "];

      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }

        // Cache the compiled function
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

        // Save selector and tokenization
        cached.selector = selector;
      }
      return cached;
    };

    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */
    select = Sizzle.select = function (selector, context, results, seed) {
      var i, tokens, token, type, find,
        compiled = typeof selector === "function" && selector,
        match = !seed && tokenize((selector = compiled.selector || selector));

      results = results || [];

      // Try to minimize operations if there is only one selector in the list and no seed
      // (the latter of which guarantees us context)
      if (match.length === 1) {

        // Reduce context if the leading compound selector is an ID
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
          context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;

            // Precompiled matchers will still verify ancestry, so step up a level
          } else if (compiled) {
            context = context.parentNode;
          }

          selector = selector.slice(tokens.shift().value.length);
        }

        // Fetch a seed set for right-to-left matching
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];

          // Abort if we hit a combinator
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            // Search, expanding context for leading sibling combinators
            if ((seed = find(
              token.matches[0].replace(runescape, funescape),
              rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
            ))) {

              // If seed is empty or no tokens remain, we can return early
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }

              break;
            }
          }
        }
      }

      // Compile and execute a filtering function if one is not provided
      // Provide `match` to avoid retokenization if we modified the selector above
      (compiled || compile(selector, match))(
        seed,
        context,
        !documentIsHTML,
        results,
        !context || rsibling.test(selector) && testContext(context.parentNode) || context
      );
      return results;
    };

    // One-time assignments

    // Sort stability
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

    // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function
    support.detectDuplicates = !!hasDuplicate;

    // Initialize against the default document
    setDocument();

    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*
    support.sortDetached = assert(function (el) {
      // Should return 1, but returns 4 (following)
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    });

    // Support: IE<8
    // Prevent attribute/property "interpolation"
    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    if (!assert(function (el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }

    // Support: IE<9
    // Use defaultValue in place of getAttribute("value")
    if (!support.attributes || !assert(function (el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function (elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }

    // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies
    if (!assert(function (el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() :
            (val = elem.getAttributeNode(name)) && val.specified ?
              val.value :
              null;
        }
      });
    }

    return Sizzle;

  })(window);


jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;


var dir = function (elem, dir, until) {
  var matched = [],
    truncate = until !== undefined;

  while ((elem = elem[dir]) && elem.nodeType !== 9) {
    if (elem.nodeType === 1) {
      if (truncate && jQuery(elem).is(until)) {
        break;
      }
      matched.push(elem);
    }
  }
  return matched;
};


var siblings = function (n, elem) {
  var matched = [];

  for (; n; n = n.nextSibling) {
    if (n.nodeType === 1 && n !== elem) {
      matched.push(n);
    }
  }

  return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;


function nodeName(elem, name) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);


// Implement the identical functionality for filter and not
function winnow(elements, qualifier, not) {
  if (isFunction(qualifier)) {
    return jQuery.grep(elements, function (elem, i) {
      return !!qualifier.call(elem, i, elem) !== not;
    });
  }

  // Single element
  if (qualifier.nodeType) {
    return jQuery.grep(elements, function (elem) {
      return (elem === qualifier) !== not;
    });
  }

  // Arraylike of elements (jQuery, arguments, Array)
  if (typeof qualifier !== "string") {
    return jQuery.grep(elements, function (elem) {
      return (indexOf.call(qualifier, elem) > -1) !== not;
    });
  }

  // Filtered directly for both simple and complex selectors
  return jQuery.filter(qualifier, elements, not);
}

jQuery.filter = function (expr, elems, not) {
  var elem = elems[0];

  if (not) {
    expr = ":not(" + expr + ")";
  }

  if (elems.length === 1 && elem.nodeType === 1) {
    return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
  }

  return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
    return elem.nodeType === 1;
  }));
};

jQuery.fn.extend({
  find: function (selector) {
    var i, ret,
      len = this.length,
      self = this;

    if (typeof selector !== "string") {
      return this.pushStack(jQuery(selector).filter(function () {
        for (i = 0; i < len; i++) {
          if (jQuery.contains(self[i], this)) {
            return true;
          }
        }
      }));
    }

    ret = this.pushStack([]);

    for (i = 0; i < len; i++) {
      jQuery.find(selector, self[i], ret);
    }

    return len > 1 ? jQuery.uniqueSort(ret) : ret;
  },
  filter: function (selector) {
    return this.pushStack(winnow(this, selector || [], false));
  },
  not: function (selector) {
    return this.pushStack(winnow(this, selector || [], true));
  },
  is: function (selector) {
    return !!winnow(
      this,

      // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test(selector) ?
        jQuery(selector) :
        selector || [],
      false
    ).length;
  }
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

  // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  // Strict HTML recognition (#11290: must start with <)
  // Shortcut simple #id case for speed
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

  init$1 = jQuery.fn.init = function (selector, context, root) {
    var match, elem;

    // HANDLE: $(""), $(null), $(undefined), $(false)
    if (!selector) {
      return this;
    }

    // Method init() accepts an alternate rootjQuery
    // so migrate can support jQuery.sub (gh-2101)
    root = root || rootjQuery;

    // Handle HTML strings
    if (typeof selector === "string") {
      if (selector[0] === "<" &&
        selector[selector.length - 1] === ">" &&
        selector.length >= 3) {

        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [null, selector, null];

      } else {
        match = rquickExpr.exec(selector);
      }

      // Match html or make sure no context is specified for #id
      if (match && (match[1] || !context)) {

        // HANDLE: $(html) -> $(array)
        if (match[1]) {
          context = context instanceof jQuery ? context[0] : context;

          // Option to run scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present
          jQuery.merge(this, jQuery.parseHTML(
            match[1],
            context && context.nodeType ? context.ownerDocument || context : document$1,
            true
          ));

          // HANDLE: $(html, props)
          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
            for (match in context) {

              // Properties of context are called as methods if possible
              if (isFunction(this[match])) {
                this[match](context[match]);

                // ...and otherwise set as attributes
              } else {
                this.attr(match, context[match]);
              }
            }
          }

          return this;

          // HANDLE: $(#id)
        } else {
          elem = document$1.getElementById(match[2]);

          if (elem) {

            // Inject the element directly into the jQuery object
            this[0] = elem;
            this.length = 1;
          }
          return this;
        }

        // HANDLE: $(expr, $(...))
      } else if (!context || context.jquery) {
        return (context || root).find(selector);

        // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor(context).find(selector);
      }

      // HANDLE: $(DOMElement)
    } else if (selector.nodeType) {
      this[0] = selector;
      this.length = 1;
      return this;

      // HANDLE: $(function)
      // Shortcut for document ready
    } else if (isFunction(selector)) {
      return root.ready !== undefined ?
        root.ready(selector) :

        // Execute immediately if ready is not present
        selector(jQuery);
    }

    return jQuery.makeArray(selector, this);
  };

// Give the init function the jQuery prototype for later instantiation
init$1.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery(document$1);


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

  // Methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };

jQuery.fn.extend({
  has: function (target) {
    var targets = jQuery(target, this),
      l = targets.length;

    return this.filter(function () {
      var i = 0;
      for (; i < l; i++) {
        if (jQuery.contains(this, targets[i])) {
          return true;
        }
      }
    });
  },

  closest: function (selectors, context) {
    var cur,
      i = 0,
      l = this.length,
      matched = [],
      targets = typeof selectors !== "string" && jQuery(selectors);

    // Positional selectors never match, since there's no _selection_ context
    if (!rneedsContext.test(selectors)) {
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

          // Always skip document fragments
          if (cur.nodeType < 11 && (targets ?
            targets.index(cur) > -1 :

            // Don't pass non-elements to Sizzle
            cur.nodeType === 1 &&
            jQuery.find.matchesSelector(cur, selectors))) {

            matched.push(cur);
            break;
          }
        }
      }
    }

    return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
  },

  // Determine the position of an element within the set
  index: function (elem) {

    // No argument, return index in parent
    if (!elem) {
      return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
    }

    // Index in selector
    if (typeof elem === "string") {
      return indexOf.call(jQuery(elem), this[0]);
    }

    // Locate the position of the desired element
    return indexOf.call(this,

      // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem
    );
  },

  add: function (selector, context) {
    return this.pushStack(
      jQuery.uniqueSort(
        jQuery.merge(this.get(), jQuery(selector, context))
      )
    );
  },

  addBack: function (selector) {
    return this.add(selector == null ?
      this.prevObject : this.prevObject.filter(selector)
    );
  }
});

function sibling(cur, dir) {
  while ((cur = cur[dir]) && cur.nodeType !== 1) {
  }
  return cur;
}

jQuery.each({
  parent: function (elem) {
    var parent = elem.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  },
  parents: function (elem) {
    return dir(elem, "parentNode");
  },
  parentsUntil: function (elem, i, until) {
    return dir(elem, "parentNode", until);
  },
  next: function (elem) {
    return sibling(elem, "nextSibling");
  },
  prev: function (elem) {
    return sibling(elem, "previousSibling");
  },
  nextAll: function (elem) {
    return dir(elem, "nextSibling");
  },
  prevAll: function (elem) {
    return dir(elem, "previousSibling");
  },
  nextUntil: function (elem, i, until) {
    return dir(elem, "nextSibling", until);
  },
  prevUntil: function (elem, i, until) {
    return dir(elem, "previousSibling", until);
  },
  siblings: function (elem) {
    return siblings((elem.parentNode || {}).firstChild, elem);
  },
  children: function (elem) {
    return siblings(elem.firstChild);
  },
  contents: function (elem) {
    if (nodeName(elem, "iframe")) {
      return elem.contentDocument;
    }

    // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
    // Treat the template element as a regular one in browsers that
    // don't support it.
    if (nodeName(elem, "template")) {
      elem = elem.content || elem;
    }

    return jQuery.merge([], elem.childNodes);
  }
}, function (name, fn) {
  jQuery.fn[name] = function (until, selector) {
    var matched = jQuery.map(this, fn, until);

    if (name.slice(-5) !== "Until") {
      selector = until;
    }

    if (selector && typeof selector === "string") {
      matched = jQuery.filter(selector, matched);
    }

    if (this.length > 1) {

      // Remove duplicates
      if (!guaranteedUnique[name]) {
        jQuery.uniqueSort(matched);
      }

      // Reverse order for parents* and prev-derivatives
      if (rparentsprev.test(name)) {
        matched.reverse();
      }
    }

    return this.pushStack(matched);
  };
});
var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);


// Convert String-formatted options into Object-formatted ones
function createOptions(options) {
  var object = {};
  jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
    object[flag] = true;
  });
  return object;
}

/*
* Create a callback list using the following parameters:
*
*	options: an optional list of space-separated options that will change how
*			the callback list behaves or a more traditional option object
*
* By default a callback list will act like an event callback list and can be
* "fired" multiple times.
*
* Possible options:
*
*	once:			will ensure the callback list can only be fired once (like a Deferred)
*
*	memory:			will keep track of previous values and will call any callback added
*					after the list has been fired right away with the latest "memorized"
*					values (like a Deferred)
*
*	unique:			will ensure a callback can only be added once (no duplicate in the list)
*
*	stopOnFalse:	interrupt callings when a callback returns false
*
*/
jQuery.Callbacks = function (options) {

  // Convert options from String-formatted to Object-formatted if needed
  // (we check in cache first)
  options = typeof options === "string" ?
    createOptions(options) :
    jQuery.extend({}, options);

  var // Flag to know if list is currently firing
    firing,

    // Last fire value for non-forgettable lists
    memory,

    // Flag to know if list was already fired
    fired,

    // Flag to prevent firing
    locked,

    // Actual callback list
    list = [],

    // Queue of execution data for repeatable lists
    queue = [],

    // Index of currently firing callback (modified by add/remove as needed)
    firingIndex = -1,

    // Fire callbacks
    fire = function () {

      // Enforce single-firing
      locked = locked || options.once;

      // Execute callbacks for all pending executions,
      // respecting firingIndex overrides and runtime changes
      fired = firing = true;
      for (; queue.length; firingIndex = -1) {
        memory = queue.shift();
        while (++firingIndex < list.length) {

          // Run callback and check for early termination
          if (list[firingIndex].apply(memory[0], memory[1]) === false &&
            options.stopOnFalse) {

            // Jump to end and forget the data so .add doesn't re-fire
            firingIndex = list.length;
            memory = false;
          }
        }
      }

      // Forget the data if we're done with it
      if (!options.memory) {
        memory = false;
      }

      firing = false;

      // Clean up if we're done firing for good
      if (locked) {

        // Keep an empty list if we have data for future add calls
        if (memory) {
          list = [];

          // Otherwise, this object is spent
        } else {
          list = "";
        }
      }
    },

    // Actual Callbacks object
    self = {

      // Add a callback or a collection of callbacks to the list
      add: function () {
        if (list) {

          // If we have memory from a past run, we should fire after adding
          if (memory && !firing) {
            firingIndex = list.length - 1;
            queue.push(memory);
          }

          (function add(args) {
            jQuery.each(args, function (_, arg) {
              if (isFunction(arg)) {
                if (!options.unique || !self.has(arg)) {
                  list.push(arg);
                }
              } else if (arg && arg.length && toType(arg) !== "string") {

                // Inspect recursively
                add(arg);
              }
            });
          })(arguments);

          if (memory && !firing) {
            fire();
          }
        }
        return this;
      },

      // Remove a callback from the list
      remove: function () {
        jQuery.each(arguments, function (_, arg) {
          var index;
          while ((index = jQuery.inArray(arg, list, index)) > -1) {
            list.splice(index, 1);

            // Handle firing indexes
            if (index <= firingIndex) {
              firingIndex--;
            }
          }
        });
        return this;
      },

      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function (fn) {
        return fn ?
          jQuery.inArray(fn, list) > -1 :
          list.length > 0;
      },

      // Remove all callbacks from the list
      empty: function () {
        if (list) {
          list = [];
        }
        return this;
      },

      // Disable .fire and .add
      // Abort any current/pending executions
      // Clear all callbacks and values
      disable: function () {
        locked = queue = [];
        list = memory = "";
        return this;
      },
      disabled: function () {
        return !list;
      },

      // Disable .fire
      // Also disable .add unless we have memory (since it would have no effect)
      // Abort any pending executions
      lock: function () {
        locked = queue = [];
        if (!memory && !firing) {
          list = memory = "";
        }
        return this;
      },
      locked: function () {
        return !!locked;
      },

      // Call all callbacks with the given context and arguments
      fireWith: function (context, args) {
        if (!locked) {
          args = args || [];
          args = [context, args.slice ? args.slice() : args];
          queue.push(args);
          if (!firing) {
            fire();
          }
        }
        return this;
      },

      // Call all the callbacks with the given arguments
      fire: function () {
        self.fireWith(this, arguments);
        return this;
      },

      // To know if the callbacks have already been called at least once
      fired: function () {
        return !!fired;
      }
    };

  return self;
};


function Identity(v) {
  return v;
}

function Thrower(ex) {
  throw ex;
}

function adoptValue(value, resolve, reject, noValue) {
  var method;

  try {

    // Check for promise aspect first to privilege synchronous behavior
    if (value && isFunction((method = value.promise))) {
      method.call(value).done(resolve).fail(reject);

      // Other thenables
    } else if (value && isFunction((method = value.then))) {
      method.call(value, resolve, reject);

      // Other non-thenables
    } else {

      // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
      // * false: [ value ].slice( 0 ) => resolve( value )
      // * true: [ value ].slice( 1 ) => resolve()
      resolve.apply(undefined, [value].slice(noValue));
    }

    // For Promises/A+, convert exceptions into rejections
    // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
    // Deferred#then to conditionally suppress rejection.
  } catch (value) {

    // Support: Android 4.0 only
    // Strict mode functions invoked without .call/.apply get global-object context
    reject.apply(undefined, [value]);
  }
}

jQuery.extend({

  Deferred: function (func) {
    var tuples = [

      // action, add listener, callbacks,
      // ... .then handlers, argument index, [final state]
      ["notify", "progress", jQuery.Callbacks("memory"),
        jQuery.Callbacks("memory"), 2],
      ["resolve", "done", jQuery.Callbacks("once memory"),
        jQuery.Callbacks("once memory"), 0, "resolved"],
      ["reject", "fail", jQuery.Callbacks("once memory"),
        jQuery.Callbacks("once memory"), 1, "rejected"]
    ],
      state = "pending",
      promise = {
        state: function () {
          return state;
        },
        always: function () {
          deferred.done(arguments).fail(arguments);
          return this;
        },
        "catch": function (fn) {
          return promise.then(null, fn);
        },

        // Keep pipe for back-compat
        pipe: function ( /* fnDone, fnFail, fnProgress */) {
          var fns = arguments;

          return jQuery.Deferred(function (newDefer) {
            jQuery.each(tuples, function (i, tuple) {

              // Map tuples (progress, done, fail) to arguments (done, fail, progress)
              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];

              // deferred.progress(function() { bind to newDefer or newDefer.notify })
              // deferred.done(function() { bind to newDefer or newDefer.resolve })
              // deferred.fail(function() { bind to newDefer or newDefer.reject })
              deferred[tuple[1]](function () {
                var returned = fn && fn.apply(this, arguments);
                if (returned && isFunction(returned.promise)) {
                  returned.promise()
                    .progress(newDefer.notify)
                    .done(newDefer.resolve)
                    .fail(newDefer.reject);
                } else {
                  newDefer[tuple[0] + "With"](
                    this,
                    fn ? [returned] : arguments
                  );
                }
              });
            });
            fns = null;
          }).promise();
        },
        then: function (onFulfilled, onRejected, onProgress) {
          var maxDepth = 0;

          function resolve(depth, deferred, handler, special) {
            return function () {
              var that = this,
                args = arguments,
                mightThrow = function () {
                  var returned, then;

                  // Support: Promises/A+ section 2.3.3.3.3
                  // https://promisesaplus.com/#point-59
                  // Ignore double-resolution attempts
                  if (depth < maxDepth) {
                    return;
                  }

                  returned = handler.apply(that, args);

                  // Support: Promises/A+ section 2.3.1
                  // https://promisesaplus.com/#point-48
                  if (returned === deferred.promise()) {
                    throw new TypeError("Thenable self-resolution");
                  }

                  // Support: Promises/A+ sections 2.3.3.1, 3.5
                  // https://promisesaplus.com/#point-54
                  // https://promisesaplus.com/#point-75
                  // Retrieve `then` only once
                  then = returned &&

                    // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    (typeof returned === "object" ||
                      typeof returned === "function") &&
                    returned.then;

                  // Handle a returned thenable
                  if (isFunction(then)) {

                    // Special processors (notify) just wait for resolution
                    if (special) {
                      then.call(
                        returned,
                        resolve(maxDepth, deferred, Identity, special),
                        resolve(maxDepth, deferred, Thrower, special)
                      );

                      // Normal processors (resolve) also hook into progress
                    } else {

                      // ...and disregard older resolution values
                      maxDepth++;

                      then.call(
                        returned,
                        resolve(maxDepth, deferred, Identity, special),
                        resolve(maxDepth, deferred, Thrower, special),
                        resolve(maxDepth, deferred, Identity,
                          deferred.notifyWith)
                      );
                    }

                    // Handle all other returned values
                  } else {

                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if (handler !== Identity) {
                      that = undefined;
                      args = [returned];
                    }

                    // Process the value(s)
                    // Default process is resolve
                    (special || deferred.resolveWith)(that, args);
                  }
                },

                // Only normal processors (resolve) catch and reject exceptions
                process = special ?
                  mightThrow :
                  function () {
                    try {
                      mightThrow();
                    } catch (e) {

                      if (jQuery.Deferred.exceptionHook) {
                        jQuery.Deferred.exceptionHook(e,
                          process.stackTrace);
                      }

                      // Support: Promises/A+ section 2.3.3.3.4.1
                      // https://promisesaplus.com/#point-61
                      // Ignore post-resolution exceptions
                      if (depth + 1 >= maxDepth) {

                        // Only substitute handlers pass on context
                        // and multiple values (non-spec behavior)
                        if (handler !== Thrower) {
                          that = undefined;
                          args = [e];
                        }

                        deferred.rejectWith(that, args);
                      }
                    }
                  };

              // Support: Promises/A+ section 2.3.3.3.1
              // https://promisesaplus.com/#point-57
              // Re-resolve promises immediately to dodge false rejection from
              // subsequent errors
              if (depth) {
                process();
              } else {

                // Call an optional hook to record the stack, in case of exception
                // since it's otherwise lost when execution goes async
                if (jQuery.Deferred.getStackHook) {
                  process.stackTrace = jQuery.Deferred.getStackHook();
                }
                window.setTimeout(process);
              }
            };
          }

          return jQuery.Deferred(function (newDefer) {

            // progress_handlers.add( ... )
            tuples[0][3].add(
              resolve(
                0,
                newDefer,
                isFunction(onProgress) ?
                  onProgress :
                  Identity,
                newDefer.notifyWith
              )
            );

            // fulfilled_handlers.add( ... )
            tuples[1][3].add(
              resolve(
                0,
                newDefer,
                isFunction(onFulfilled) ?
                  onFulfilled :
                  Identity
              )
            );

            // rejected_handlers.add( ... )
            tuples[2][3].add(
              resolve(
                0,
                newDefer,
                isFunction(onRejected) ?
                  onRejected :
                  Thrower
              )
            );
          }).promise();
        },

        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function (obj) {
          return obj != null ? jQuery.extend(obj, promise) : promise;
        }
      },
      deferred = {};

    // Add list-specific methods
    jQuery.each(tuples, function (i, tuple) {
      var list = tuple[2],
        stateString = tuple[5];

      // promise.progress = list.add
      // promise.done = list.add
      // promise.fail = list.add
      promise[tuple[1]] = list.add;

      // Handle state
      if (stateString) {
        list.add(
          function () {

            // state = "resolved" (i.e., fulfilled)
            // state = "rejected"
            state = stateString;
          },

          // rejected_callbacks.disable
          // fulfilled_callbacks.disable
          tuples[3 - i][2].disable,

          // rejected_handlers.disable
          // fulfilled_handlers.disable
          tuples[3 - i][3].disable,

          // progress_callbacks.lock
          tuples[0][2].lock,

          // progress_handlers.lock
          tuples[0][3].lock
        );
      }

      // progress_handlers.fire
      // fulfilled_handlers.fire
      // rejected_handlers.fire
      list.add(tuple[3].fire);

      // deferred.notify = function() { deferred.notifyWith(...) }
      // deferred.resolve = function() { deferred.resolveWith(...) }
      // deferred.reject = function() { deferred.rejectWith(...) }
      deferred[tuple[0]] = function () {
        deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
        return this;
      };

      // deferred.notifyWith = list.fireWith
      // deferred.resolveWith = list.fireWith
      // deferred.rejectWith = list.fireWith
      deferred[tuple[0] + "With"] = list.fireWith;
    });

    // Make the deferred a promise
    promise.promise(deferred);

    // Call given func if any
    if (func) {
      func.call(deferred, deferred);
    }

    // All done!
    return deferred;
  },

  // Deferred helper
  when: function (singleValue) {
    var

      // count of uncompleted subordinates
      remaining = arguments.length,

      // count of unprocessed arguments
      i = remaining,

      // subordinate fulfillment data
      resolveContexts = Array(i),
      resolveValues = slice.call(arguments),

      // the master Deferred
      master = jQuery.Deferred(),

      // subordinate callback factory
      updateFunc = function (i) {
        return function (value) {
          resolveContexts[i] = this;
          resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
          if (!(--remaining)) {
            master.resolveWith(resolveContexts, resolveValues);
          }
        };
      };

    // Single- and empty arguments are adopted like Promise.resolve
    if (remaining <= 1) {
      adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject,
        !remaining);

      // Use .then() to unwrap secondary thenables (cf. gh-3000)
      if (master.state() === "pending" ||
        isFunction(resolveValues[i] && resolveValues[i].then)) {

        return master.then();
      }
    }

    // Multiple arguments are aggregated like Promise.all array elements
    while (i--) {
      adoptValue(resolveValues[i], updateFunc(i), master.reject);
    }

    return master.promise();
  }
});


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function (error, stack) {

  // Support: IE 8 - 9 only
  // Console exists when dev tools are open, which can happen at any time
  if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
    window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
  }
};


jQuery.readyException = function (error) {
  window.setTimeout(function () {
    throw error;
  });
};


// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function (fn) {

  readyList
    .then(fn)

    // Wrap jQuery.readyException in a function so that the lookup
    // happens at the time of error handling instead of callback
    // registration.
    .catch(function (error) {
      jQuery.readyException(error);
    });

  return this;
};

jQuery.extend({

  // Is the DOM ready to be used? Set to true once it occurs.
  isReady: false,

  // A counter to track how many items to wait for before
  // the ready event fires. See #6781
  readyWait: 1,

  // Handle when the DOM is ready
  ready: function (wait) {

    // Abort if there are pending holds or we're already ready
    if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
      return;
    }

    // Remember that the DOM is ready
    jQuery.isReady = true;

    // If a normal DOM Ready event fired, decrement, and wait if need be
    if (wait !== true && --jQuery.readyWait > 0) {
      return;
    }

    // If there are functions bound, to execute
    readyList.resolveWith(document$1, [jQuery]);
  }
});

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
  document$1.removeEventListener("DOMContentLoaded", completed);
  window.removeEventListener("load", completed);
  jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if (document$1.readyState === "complete" ||
  (document$1.readyState !== "loading" && !document$1.documentElement.doScroll)) {

  // Handle it asynchronously to allow scripts the opportunity to delay ready
  window.setTimeout(jQuery.ready);

} else {

  // Use the handy event callback
  document$1.addEventListener("DOMContentLoaded", completed);

  // A fallback to window.onload, that will always work
  window.addEventListener("load", completed);
}


// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
  var i = 0,
    len = elems.length,
    bulk = key == null;

  // Sets many values
  if (toType(key) === "object") {
    chainable = true;
    for (i in key) {
      access(elems, fn, i, key[i], true, emptyGet, raw);
    }

    // Sets one value
  } else if (value !== undefined) {
    chainable = true;

    if (!isFunction(value)) {
      raw = true;
    }

    if (bulk) {

      // Bulk operations run against the entire set
      if (raw) {
        fn.call(elems, value);
        fn = null;

        // ...except when executing function values
      } else {
        bulk = fn;
        fn = function (elem, key, value) {
          return bulk.call(jQuery(elem), value);
        };
      }
    }

    if (fn) {
      for (; i < len; i++) {
        fn(
          elems[i], key, raw ?
          value :
          value.call(elems[i], i, fn(elems[i], key))
        );
      }
    }
  }

  if (chainable) {
    return elems;
  }

  // Gets
  if (bulk) {
    return fn.call(elems);
  }

  return len ? fn(elems[0], key) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
  rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase(all, letter) {
  return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase(string) {
  return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
}

var acceptData = function (owner) {

  // Accepts only:
  //  - Node
  //    - Node.ELEMENT_NODE
  //    - Node.DOCUMENT_NODE
  //  - Object
  //    - Any
  return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
};


function Data() {
  this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

  cache: function (owner) {

    // Check if the owner object already has a cache
    var value = owner[this.expando];

    // If not, create one
    if (!value) {
      value = {};

      // We can accept data for non-element nodes in modern browsers,
      // but we should not, see #8335.
      // Always return an empty object.
      if (acceptData(owner)) {

        // If it is a node unlikely to be stringify-ed or looped over
        // use plain assignment
        if (owner.nodeType) {
          owner[this.expando] = value;

          // Otherwise secure it in a non-enumerable property
          // configurable must be true to allow the property to be
          // deleted when data is removed
        } else {
          Object.defineProperty(owner, this.expando, {
            value: value,
            configurable: true
          });
        }
      }
    }

    return value;
  },
  set: function (owner, data, value) {
    var prop,
      cache = this.cache(owner);

    // Handle: [ owner, key, value ] args
    // Always use camelCase key (gh-2257)
    if (typeof data === "string") {
      cache[camelCase(data)] = value;

      // Handle: [ owner, { properties } ] args
    } else {

      // Copy the properties one-by-one to the cache object
      for (prop in data) {
        cache[camelCase(prop)] = data[prop];
      }
    }
    return cache;
  },
  get: function (owner, key) {
    return key === undefined ?
      this.cache(owner) :

      // Always use camelCase key (gh-2257)
      owner[this.expando] && owner[this.expando][camelCase(key)];
  },
  access: function (owner, key, value) {

    // In cases where either:
    //
    //   1. No key was specified
    //   2. A string key was specified, but no value provided
    //
    // Take the "read" path and allow the get method to determine
    // which value to return, respectively either:
    //
    //   1. The entire cache object
    //   2. The data stored at the key
    //
    if (key === undefined ||
      ((key && typeof key === "string") && value === undefined)) {

      return this.get(owner, key);
    }

    // When the key is not a string, or both a key and value
    // are specified, set or extend (existing objects) with either:
    //
    //   1. An object of properties
    //   2. A key and value
    //
    this.set(owner, key, value);

    // Since the "set" path can have two possible entry points
    // return the expected data based on which path was taken[*]
    return value !== undefined ? value : key;
  },
  remove: function (owner, key) {
    var i,
      cache = owner[this.expando];

    if (cache === undefined) {
      return;
    }

    if (key !== undefined) {

      // Support array or space separated string of keys
      if (Array.isArray(key)) {

        // If key is an array of keys...
        // We always set camelCase keys, so remove that.
        key = key.map(camelCase);
      } else {
        key = camelCase(key);

        // If a key with the spaces exists, use it.
        // Otherwise, create an array by matching non-whitespace
        key = key in cache ?
          [key] :
          (key.match(rnothtmlwhite) || []);
      }

      i = key.length;

      while (i--) {
        delete cache[key[i]];
      }
    }

    // Remove the expando if there's no more data
    if (key === undefined || jQuery.isEmptyObject(cache)) {

      // Support: Chrome <=35 - 45
      // Webkit & Blink performance suffers when deleting properties
      // from DOM nodes, so set to undefined instead
      // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
      if (owner.nodeType) {
        owner[this.expando] = undefined;
      } else {
        delete owner[this.expando];
      }
    }
  },
  hasData: function (owner) {
    var cache = owner[this.expando];
    return cache !== undefined && !jQuery.isEmptyObject(cache);
  }
};
var dataPriv = new Data();

var dataUser = new Data();


//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
  rmultiDash = /[A-Z]/g;

function getData(data) {
  if (data === "true") {
    return true;
  }

  if (data === "false") {
    return false;
  }

  if (data === "null") {
    return null;
  }

  // Only convert to a number if it doesn't change the string
  if (data === +data + "") {
    return +data;
  }

  if (rbrace.test(data)) {
    return JSON.parse(data);
  }

  return data;
}

function dataAttr(elem, key, data) {
  var name;

  // If nothing was found internally, try to fetch any
  // data from the HTML5 data-* attribute
  if (data === undefined && elem.nodeType === 1) {
    name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
    data = elem.getAttribute(name);

    if (typeof data === "string") {
      try {
        data = getData(data);
      } catch (e) {
      }

      // Make sure we set the data so it isn't changed later
      dataUser.set(elem, key, data);
    } else {
      data = undefined;
    }
  }
  return data;
}

jQuery.extend({
  hasData: function (elem) {
    return dataUser.hasData(elem) || dataPriv.hasData(elem);
  },

  data: function (elem, name, data) {
    return dataUser.access(elem, name, data);
  },

  removeData: function (elem, name) {
    dataUser.remove(elem, name);
  },

  // TODO: Now that all calls to _data and _removeData have been replaced
  // with direct calls to dataPriv methods, these can be deprecated.
  _data: function (elem, name, data) {
    return dataPriv.access(elem, name, data);
  },

  _removeData: function (elem, name) {
    dataPriv.remove(elem, name);
  }
});

jQuery.fn.extend({
  data: function (key, value) {
    var i, name, data,
      elem = this[0],
      attrs = elem && elem.attributes;

    // Gets all values
    if (key === undefined) {
      if (this.length) {
        data = dataUser.get(elem);

        if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
          i = attrs.length;
          while (i--) {

            // Support: IE 11 only
            // The attrs elements can be null (#14894)
            if (attrs[i]) {
              name = attrs[i].name;
              if (name.indexOf("data-") === 0) {
                name = camelCase(name.slice(5));
                dataAttr(elem, name, data[name]);
              }
            }
          }
          dataPriv.set(elem, "hasDataAttrs", true);
        }
      }

      return data;
    }

    // Sets multiple values
    if (typeof key === "object") {
      return this.each(function () {
        dataUser.set(this, key);
      });
    }

    return access(this, function (value) {
      var data;

      // The calling jQuery object (element matches) is not empty
      // (and therefore has an element appears at this[ 0 ]) and the
      // `value` parameter was not undefined. An empty jQuery object
      // will result in `undefined` for elem = this[ 0 ] which will
      // throw an exception if an attempt to read a data cache is made.
      if (elem && value === undefined) {

        // Attempt to get data from the cache
        // The key will always be camelCased in Data
        data = dataUser.get(elem, key);
        if (data !== undefined) {
          return data;
        }

        // Attempt to "discover" the data in
        // HTML5 custom data-* attrs
        data = dataAttr(elem, key);
        if (data !== undefined) {
          return data;
        }

        // We tried really hard, but the data doesn't exist.
        return;
      }

      // Set the data...
      this.each(function () {

        // We always store the camelCased key
        dataUser.set(this, key, value);
      });
    }, null, value, arguments.length > 1, null, true);
  },

  removeData: function (key) {
    return this.each(function () {
      dataUser.remove(this, key);
    });
  }
});


jQuery.extend({
  queue: function (elem, type, data) {
    var queue;

    if (elem) {
      type = (type || "fx") + "queue";
      queue = dataPriv.get(elem, type);

      // Speed up dequeue by getting out quickly if this is just a lookup
      if (data) {
        if (!queue || Array.isArray(data)) {
          queue = dataPriv.access(elem, type, jQuery.makeArray(data));
        } else {
          queue.push(data);
        }
      }
      return queue || [];
    }
  },

  dequeue: function (elem, type) {
    type = type || "fx";

    var queue = jQuery.queue(elem, type),
      startLength = queue.length,
      fn = queue.shift(),
      hooks = jQuery._queueHooks(elem, type),
      next = function () {
        jQuery.dequeue(elem, type);
      };

    // If the fx queue is dequeued, always remove the progress sentinel
    if (fn === "inprogress") {
      fn = queue.shift();
      startLength--;
    }

    if (fn) {

      // Add a progress sentinel to prevent the fx queue from being
      // automatically dequeued
      if (type === "fx") {
        queue.unshift("inprogress");
      }

      // Clear up the last queue stop function
      delete hooks.stop;
      fn.call(elem, next, hooks);
    }

    if (!startLength && hooks) {
      hooks.empty.fire();
    }
  },

  // Not public - generate a queueHooks object, or return the current one
  _queueHooks: function (elem, type) {
    var key = type + "queueHooks";
    return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
      empty: jQuery.Callbacks("once memory").add(function () {
        dataPriv.remove(elem, [type + "queue", key]);
      })
    });
  }
});

jQuery.fn.extend({
  queue: function (type, data) {
    var setter = 2;

    if (typeof type !== "string") {
      data = type;
      type = "fx";
      setter--;
    }

    if (arguments.length < setter) {
      return jQuery.queue(this[0], type);
    }

    return data === undefined ?
      this :
      this.each(function () {
        var queue = jQuery.queue(this, type, data);

        // Ensure a hooks for this queue
        jQuery._queueHooks(this, type);

        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
  },
  dequeue: function (type) {
    return this.each(function () {
      jQuery.dequeue(this, type);
    });
  },
  clearQueue: function (type) {
    return this.queue(type || "fx", []);
  },

  // Get a promise resolved when queues of a certain type
  // are emptied (fx is the type by default)
  promise: function (type, obj) {
    var tmp,
      count = 1,
      defer = jQuery.Deferred(),
      elements = this,
      i = this.length,
      resolve = function () {
        if (!(--count)) {
          defer.resolveWith(elements, [elements]);
        }
      };

    if (typeof type !== "string") {
      obj = type;
      type = undefined;
    }
    type = type || "fx";

    while (i--) {
      tmp = dataPriv.get(elements[i], type + "queueHooks");
      if (tmp && tmp.empty) {
        count++;
        tmp.empty.add(resolve);
      }
    }
    resolve();
    return defer.promise(obj);
  }
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");


var cssExpand = ["Top", "Right", "Bottom", "Left"];

var isHiddenWithinTree = function (elem, el) {

  // isHiddenWithinTree might be called from jQuery#filter function;
  // in that case, element will be second argument
  elem = el || elem;

  // Inline style trumps all
  return elem.style.display === "none" ||
    elem.style.display === "" &&

    // Otherwise, check computed style
    // Support: Firefox <=43 - 45
    // Disconnected elements can have computed display: none, so first confirm that elem is
    // in the document.
    jQuery.contains(elem.ownerDocument, elem) &&

    jQuery.css(elem, "display") === "none";
};

var swap = function (elem, options, callback, args) {
  var ret, name,
    old = {};

  // Remember the old values, and insert the new ones
  for (name in options) {
    old[name] = elem.style[name];
    elem.style[name] = options[name];
  }

  ret = callback.apply(elem, args || []);

  // Revert the old values
  for (name in options) {
    elem.style[name] = old[name];
  }

  return ret;
};


function adjustCSS(elem, prop, valueParts, tween) {
  var adjusted, scale,
    maxIterations = 20,
    currentValue = tween ?
      function () {
        return tween.cur();
      } :
      function () {
        return jQuery.css(elem, prop, "");
      },
    initial = currentValue(),
    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),

    // Starting value computation is required for potential unit mismatches
    initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) &&
      rcssNum.exec(jQuery.css(elem, prop));

  if (initialInUnit && initialInUnit[3] !== unit) {

    // Support: Firefox <=54
    // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
    initial = initial / 2;

    // Trust units reported by jQuery.css
    unit = unit || initialInUnit[3];

    // Iteratively approximate from a nonzero starting point
    initialInUnit = +initial || 1;

    while (maxIterations--) {

      // Evaluate and update our best guess (doubling guesses that zero out).
      // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
      jQuery.style(elem, prop, initialInUnit + unit);
      if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
        maxIterations = 0;
      }
      initialInUnit = initialInUnit / scale;

    }

    initialInUnit = initialInUnit * 2;
    jQuery.style(elem, prop, initialInUnit + unit);

    // Make sure we update the tween properties later on
    valueParts = valueParts || [];
  }

  if (valueParts) {
    initialInUnit = +initialInUnit || +initial || 0;

    // Apply relative offset (+=/-=) if specified
    adjusted = valueParts[1] ?
      initialInUnit + (valueParts[1] + 1) * valueParts[2] :
      +valueParts[2];
    if (tween) {
      tween.unit = unit;
      tween.start = initialInUnit;
      tween.end = adjusted;
    }
  }
  return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay(elem) {
  var temp,
    doc = elem.ownerDocument,
    nodeName = elem.nodeName,
    display = defaultDisplayMap[nodeName];

  if (display) {
    return display;
  }

  temp = doc.body.appendChild(doc.createElement(nodeName));
  display = jQuery.css(temp, "display");

  temp.parentNode.removeChild(temp);

  if (display === "none") {
    display = "block";
  }
  defaultDisplayMap[nodeName] = display;

  return display;
}

function showHide(elements, show) {
  var display, elem,
    values = [],
    index = 0,
    length = elements.length;

  // Determine new display value for elements that need to change
  for (; index < length; index++) {
    elem = elements[index];
    if (!elem.style) {
      continue;
    }

    display = elem.style.display;
    if (show) {

      // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
      // check is required in this first loop unless we have a nonempty display value (either
      // inline or about-to-be-restored)
      if (display === "none") {
        values[index] = dataPriv.get(elem, "display") || null;
        if (!values[index]) {
          elem.style.display = "";
        }
      }
      if (elem.style.display === "" && isHiddenWithinTree(elem)) {
        values[index] = getDefaultDisplay(elem);
      }
    } else {
      if (display !== "none") {
        values[index] = "none";

        // Remember what we're overwriting
        dataPriv.set(elem, "display", display);
      }
    }
  }

  // Set the display of the elements in a second loop to avoid constant reflow
  for (index = 0; index < length; index++) {
    if (values[index] != null) {
      elements[index].style.display = values[index];
    }
  }

  return elements;
}

jQuery.fn.extend({
  show: function () {
    return showHide(this, true);
  },
  hide: function () {
    return showHide(this);
  },
  toggle: function (state) {
    if (typeof state === "boolean") {
      return state ? this.show() : this.hide();
    }

    return this.each(function () {
      if (isHiddenWithinTree(this)) {
        jQuery(this).show();
      } else {
        jQuery(this).hide();
      }
    });
  }
});
var rcheckableType = (/^(?:checkbox|radio)$/i);

var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]+)/i);

var rscriptType = (/^$|^module$|\/(?:java|ecma)script/i);


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

  // Support: IE <=9 only
  option: [1, "<select multiple='multiple'>", "</select>"],

  // XHTML parsers do not magically insert elements in the
  // same way that tag soup parsers do. So we cannot shorten
  // this by omitting <tbody> or other required elements.
  thead: [1, "<table>", "</table>"],
  col: [2, "<table><colgroup>", "</colgroup></table>"],
  tr: [2, "<table><tbody>", "</tbody></table>"],
  td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

  _default: [0, "", ""]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll(context, tag) {

  // Support: IE <=9 - 11 only
  // Use typeof to avoid zero-argument method invocation on host objects (#15151)
  var ret;

  if (typeof context.getElementsByTagName !== "undefined") {
    ret = context.getElementsByTagName(tag || "*");

  } else if (typeof context.querySelectorAll !== "undefined") {
    ret = context.querySelectorAll(tag || "*");

  } else {
    ret = [];
  }

  if (tag === undefined || tag && nodeName(context, tag)) {
    return jQuery.merge([context], ret);
  }

  return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval(elems, refElements) {
  var i = 0,
    l = elems.length;

  for (; i < l; i++) {
    dataPriv.set(
      elems[i],
      "globalEval",
      !refElements || dataPriv.get(refElements[i], "globalEval")
    );
  }
}


var rhtml = /<|&#?\w+;/;

function buildFragment(elems, context, scripts, selection, ignored) {
  var elem, tmp, tag, wrap, contains, j,
    fragment = context.createDocumentFragment(),
    nodes = [],
    i = 0,
    l = elems.length;

  for (; i < l; i++) {
    elem = elems[i];

    if (elem || elem === 0) {

      // Add nodes directly
      if (toType(elem) === "object") {

        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

        // Convert non-html into a text node
      } else if (!rhtml.test(elem)) {
        nodes.push(context.createTextNode(elem));

        // Convert html into DOM nodes
      } else {
        tmp = tmp || fragment.appendChild(context.createElement("div"));

        // Deserialize a standard representation
        tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
        wrap = wrapMap[tag] || wrapMap._default;
        tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

        // Descend through wrappers to the right content
        j = wrap[0];
        while (j--) {
          tmp = tmp.lastChild;
        }

        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        jQuery.merge(nodes, tmp.childNodes);

        // Remember the top-level container
        tmp = fragment.firstChild;

        // Ensure the created nodes are orphaned (#12392)
        tmp.textContent = "";
      }
    }
  }

  // Remove wrapper from fragment
  fragment.textContent = "";

  i = 0;
  while ((elem = nodes[i++])) {

    // Skip elements already in the context collection (trac-4087)
    if (selection && jQuery.inArray(elem, selection) > -1) {
      if (ignored) {
        ignored.push(elem);
      }
      continue;
    }

    contains = jQuery.contains(elem.ownerDocument, elem);

    // Append to fragment
    tmp = getAll(fragment.appendChild(elem), "script");

    // Preserve script evaluation history
    if (contains) {
      setGlobalEval(tmp);
    }

    // Capture executables
    if (scripts) {
      j = 0;
      while ((elem = tmp[j++])) {
        if (rscriptType.test(elem.type || "")) {
          scripts.push(elem);
        }
      }
    }
  }

  return fragment;
}


(function () {
  var fragment = document$1.createDocumentFragment(),
    div = fragment.appendChild(document$1.createElement("div")),
    input = document$1.createElement("input");

  // Support: Android 4.0 - 4.3 only
  // Check state lost if the name is set (#11217)
  // Support: Windows Web Apps (WWA)
  // `name` and `type` must use .setAttribute for WWA (#14901)
  input.setAttribute("type", "radio");
  input.setAttribute("checked", "checked");
  input.setAttribute("name", "t");

  div.appendChild(input);

  // Support: Android <=4.1 only
  // Older WebKit doesn't clone checked state correctly in fragments
  support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

  // Support: IE <=11 only
  // Make sure textarea (and checkbox) defaultValue is properly cloned
  div.innerHTML = "<textarea>x</textarea>";
  support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
})();
var documentElement = document$1.documentElement;


var
  rkeyEvent = /^key/,
  rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
  rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
  return true;
}

function returnFalse() {
  return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
  try {
    return document$1.activeElement;
  } catch (err) {
  }
}

function on(elem, types, selector, data, fn, one) {
  var origFn, type;

  // Types can be a map of types/handlers
  if (typeof types === "object") {

    // ( types-Object, selector, data )
    if (typeof selector !== "string") {

      // ( types-Object, data )
      data = data || selector;
      selector = undefined;
    }
    for (type in types) {
      on(elem, type, selector, data, types[type], one);
    }
    return elem;
  }

  if (data == null && fn == null) {

    // ( types, fn )
    fn = selector;
    data = selector = undefined;
  } else if (fn == null) {
    if (typeof selector === "string") {

      // ( types, selector, fn )
      fn = data;
      data = undefined;
    } else {

      // ( types, data, fn )
      fn = data;
      data = selector;
      selector = undefined;
    }
  }
  if (fn === false) {
    fn = returnFalse;
  } else if (!fn) {
    return elem;
  }

  if (one === 1) {
    origFn = fn;
    fn = function (event) {

      // Can use an empty set, since event contains the info
      jQuery().off(event);
      return origFn.apply(this, arguments);
    };

    // Use same guid so caller can remove using origFn
    fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
  }
  return elem.each(function () {
    jQuery.event.add(this, types, fn, data, selector);
  });
}

/*
* Helper functions for managing events -- not part of the public interface.
* Props to Dean Edwards' addEvent library for many of the ideas.
*/
jQuery.event = {

  global: {},

  add: function (elem, types, handler, data, selector) {

    var handleObjIn, eventHandle, tmp,
      events, t, handleObj,
      special, handlers, type, namespaces, origType,
      elemData = dataPriv.get(elem);

    // Don't attach events to noData or text/comment nodes (but allow plain objects)
    if (!elemData) {
      return;
    }

    // Caller can pass in an object of custom data in lieu of the handler
    if (handler.handler) {
      handleObjIn = handler;
      handler = handleObjIn.handler;
      selector = handleObjIn.selector;
    }

    // Ensure that invalid selectors throw exceptions at attach time
    // Evaluate against documentElement in case elem is a non-element node (e.g., document)
    if (selector) {
      jQuery.find.matchesSelector(documentElement, selector);
    }

    // Make sure that the handler has a unique ID, used to find/remove it later
    if (!handler.guid) {
      handler.guid = jQuery.guid++;
    }

    // Init the element's event structure and main handler, if this is the first
    if (!(events = elemData.events)) {
      events = elemData.events = {};
    }
    if (!(eventHandle = elemData.handle)) {
      eventHandle = elemData.handle = function (e) {

        // Discard the second event of a jQuery.event.trigger() and
        // when an event is called after a page has unloaded
        return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
          jQuery.event.dispatch.apply(elem, arguments) : undefined;
      };
    }

    // Handle multiple events separated by a space
    types = (types || "").match(rnothtmlwhite) || [""];
    t = types.length;
    while (t--) {
      tmp = rtypenamespace.exec(types[t]) || [];
      type = origType = tmp[1];
      namespaces = (tmp[2] || "").split(".").sort();

      // There *must* be a type, no attaching namespace-only handlers
      if (!type) {
        continue;
      }

      // If event changes its type, use the special event handlers for the changed type
      special = jQuery.event.special[type] || {};

      // If selector defined, determine special event api type, otherwise given type
      type = (selector ? special.delegateType : special.bindType) || type;

      // Update special based on newly reset type
      special = jQuery.event.special[type] || {};

      // handleObj is passed to all event handlers
      handleObj = jQuery.extend({
        type: type,
        origType: origType,
        data: data,
        handler: handler,
        guid: handler.guid,
        selector: selector,
        needsContext: selector && jQuery.expr.match.needsContext.test(selector),
        namespace: namespaces.join(".")
      }, handleObjIn);

      // Init the event handler queue if we're the first
      if (!(handlers = events[type])) {
        handlers = events[type] = [];
        handlers.delegateCount = 0;

        // Only use addEventListener if the special events handler returns false
        if (!special.setup ||
          special.setup.call(elem, data, namespaces, eventHandle) === false) {

          if (elem.addEventListener) {
            elem.addEventListener(type, eventHandle);
          }
        }
      }

      if (special.add) {
        special.add.call(elem, handleObj);

        if (!handleObj.handler.guid) {
          handleObj.handler.guid = handler.guid;
        }
      }

      // Add to the element's handler list, delegates in front
      if (selector) {
        handlers.splice(handlers.delegateCount++, 0, handleObj);
      } else {
        handlers.push(handleObj);
      }

      // Keep track of which events have ever been used, for event optimization
      jQuery.event.global[type] = true;
    }

  },

  // Detach an event or set of events from an element
  remove: function (elem, types, handler, selector, mappedTypes) {

    var j, origCount, tmp,
      events, t, handleObj,
      special, handlers, type, namespaces, origType,
      elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

    if (!elemData || !(events = elemData.events)) {
      return;
    }

    // Once for each type.namespace in types; type may be omitted
    types = (types || "").match(rnothtmlwhite) || [""];
    t = types.length;
    while (t--) {
      tmp = rtypenamespace.exec(types[t]) || [];
      type = origType = tmp[1];
      namespaces = (tmp[2] || "").split(".").sort();

      // Unbind all events (on this namespace, if provided) for the element
      if (!type) {
        for (type in events) {
          jQuery.event.remove(elem, type + types[t], handler, selector, true);
        }
        continue;
      }

      special = jQuery.event.special[type] || {};
      type = (selector ? special.delegateType : special.bindType) || type;
      handlers = events[type] || [];
      tmp = tmp[2] &&
        new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

      // Remove matching events
      origCount = j = handlers.length;
      while (j--) {
        handleObj = handlers[j];

        if ((mappedTypes || origType === handleObj.origType) &&
          (!handler || handler.guid === handleObj.guid) &&
          (!tmp || tmp.test(handleObj.namespace)) &&
          (!selector || selector === handleObj.selector ||
            selector === "**" && handleObj.selector)) {
          handlers.splice(j, 1);

          if (handleObj.selector) {
            handlers.delegateCount--;
          }
          if (special.remove) {
            special.remove.call(elem, handleObj);
          }
        }
      }

      // Remove generic event handler if we removed something and no more handlers exist
      // (avoids potential for endless recursion during removal of special event handlers)
      if (origCount && !handlers.length) {
        if (!special.teardown ||
          special.teardown.call(elem, namespaces, elemData.handle) === false) {

          jQuery.removeEvent(elem, type, elemData.handle);
        }

        delete events[type];
      }
    }

    // Remove data and the expando if it's no longer used
    if (jQuery.isEmptyObject(events)) {
      dataPriv.remove(elem, "handle events");
    }
  },

  dispatch: function (nativeEvent) {

    // Make a writable jQuery.Event from the native event object
    var event = jQuery.event.fix(nativeEvent);

    var i, j, ret, matched, handleObj, handlerQueue,
      args = new Array(arguments.length),
      handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
      special = jQuery.event.special[event.type] || {};

    // Use the fix-ed jQuery.Event rather than the (read-only) native event
    args[0] = event;

    for (i = 1; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    event.delegateTarget = this;

    // Call the preDispatch hook for the mapped type, and let it bail if desired
    if (special.preDispatch && special.preDispatch.call(this, event) === false) {
      return;
    }

    // Determine handlers
    handlerQueue = jQuery.event.handlers.call(this, event, handlers);

    // Run delegates first; they may want to stop propagation beneath us
    i = 0;
    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
      event.currentTarget = matched.elem;

      j = 0;
      while ((handleObj = matched.handlers[j++]) &&
        !event.isImmediatePropagationStopped()) {

        // Triggered event must either 1) have no namespace, or 2) have namespace(s)
        // a subset or equal to those in the bound event (both can have no namespace).
        if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

          event.handleObj = handleObj;
          event.data = handleObj.data;

          ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||
            handleObj.handler).apply(matched.elem, args);

          if (ret !== undefined) {
            if ((event.result = ret) === false) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      }
    }

    // Call the postDispatch hook for the mapped type
    if (special.postDispatch) {
      special.postDispatch.call(this, event);
    }

    return event.result;
  },

  handlers: function (event, handlers) {
    var i, handleObj, sel, matchedHandlers, matchedSelectors,
      handlerQueue = [],
      delegateCount = handlers.delegateCount,
      cur = event.target;

    // Find delegate handlers
    if (delegateCount &&

      // Support: IE <=9
      // Black-hole SVG <use> instance trees (trac-13180)
      cur.nodeType &&

      // Support: Firefox <=42
      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
      // Support: IE 11 only
      // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
      !(event.type === "click" && event.button >= 1)) {

      for (; cur !== this; cur = cur.parentNode || this) {

        // Don't check non-elements (#13208)
        // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
        if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
          matchedHandlers = [];
          matchedSelectors = {};
          for (i = 0; i < delegateCount; i++) {
            handleObj = handlers[i];

            // Don't conflict with Object.prototype properties (#13203)
            sel = handleObj.selector + " ";

            if (matchedSelectors[sel] === undefined) {
              matchedSelectors[sel] = handleObj.needsContext ?
                jQuery(sel, this).index(cur) > -1 :
                jQuery.find(sel, this, null, [cur]).length;
            }
            if (matchedSelectors[sel]) {
              matchedHandlers.push(handleObj);
            }
          }
          if (matchedHandlers.length) {
            handlerQueue.push({ elem: cur, handlers: matchedHandlers });
          }
        }
      }
    }

    // Add the remaining (directly-bound) handlers
    cur = this;
    if (delegateCount < handlers.length) {
      handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
    }

    return handlerQueue;
  },

  addProp: function (name, hook) {
    Object.defineProperty(jQuery.Event.prototype, name, {
      enumerable: true,
      configurable: true,

      get: isFunction(hook) ?
        function () {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } :
        function () {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },

      set: function (value) {
        Object.defineProperty(this, name, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: value
        });
      }
    });
  },

  fix: function (originalEvent) {
    return originalEvent[jQuery.expando] ?
      originalEvent :
      new jQuery.Event(originalEvent);
  },

  special: {
    load: {

      // Prevent triggered image.load events from bubbling to window.load
      noBubble: true
    },
    focus: {

      // Fire native event if possible so blur/focus sequence is correct
      trigger: function () {
        if (this !== safeActiveElement() && this.focus) {
          this.focus();
          return false;
        }
      },
      delegateType: "focusin"
    },
    blur: {
      trigger: function () {
        if (this === safeActiveElement() && this.blur) {
          this.blur();
          return false;
        }
      },
      delegateType: "focusout"
    },
    click: {

      // For checkbox, fire native event so checked state will be right
      trigger: function () {
        if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
          this.click();
          return false;
        }
      },

      // For cross-browser consistency, don't fire native .click() on links
      _default: function (event) {
        return nodeName(event.target, "a");
      }
    },

    beforeunload: {
      postDispatch: function (event) {

        // Support: Firefox 20+
        // Firefox doesn't alert if the returnValue field is not set.
        if (event.result !== undefined && event.originalEvent) {
          event.originalEvent.returnValue = event.result;
        }
      }
    }
  }
};

jQuery.removeEvent = function (elem, type, handle) {

  // This "if" is needed for plain objects
  if (elem.removeEventListener) {
    elem.removeEventListener(type, handle);
  }
};

jQuery.Event = function (src, props) {

  // Allow instantiation without the 'new' keyword
  if (!(this instanceof jQuery.Event)) {
    return new jQuery.Event(src, props);
  }

  // Event object
  if (src && src.type) {
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = src.defaultPrevented ||
      src.defaultPrevented === undefined &&

      // Support: Android <=2.3 only
      src.returnValue === false ?
      returnTrue :
      returnFalse;

    // Create target properties
    // Support: Safari <=6 - 7 only
    // Target should not be a text node (#504, #13143)
    this.target = (src.target && src.target.nodeType === 3) ?
      src.target.parentNode :
      src.target;

    this.currentTarget = src.currentTarget;
    this.relatedTarget = src.relatedTarget;

    // Event type
  } else {
    this.type = src;
  }

  // Put explicitly provided properties onto the event object
  if (props) {
    jQuery.extend(this, props);
  }

  // Create a timestamp if incoming event doesn't have one
  this.timeStamp = src && src.timeStamp || Date.now();

  // Mark it as fixed
  this[jQuery.expando] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
  constructor: jQuery.Event,
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse,
  isSimulated: false,

  preventDefault: function () {
    var e = this.originalEvent;

    this.isDefaultPrevented = returnTrue;

    if (e && !this.isSimulated) {
      e.preventDefault;
    }
  },
  stopPropagation: function () {
    var e = this.originalEvent;

    this.isPropagationStopped = returnTrue;

    if (e && !this.isSimulated) {
      e.stopPropagation();
    }
  },
  stopImmediatePropagation: function () {
    var e = this.originalEvent;

    this.isImmediatePropagationStopped = returnTrue;

    if (e && !this.isSimulated) {
      e.stopImmediatePropagation();
    }

    this.stopPropagation();
  }
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each({
  altKey: true,
  bubbles: true,
  cancelable: true,
  changedTouches: true,
  ctrlKey: true,
  detail: true,
  eventPhase: true,
  metaKey: true,
  pageX: true,
  pageY: true,
  shiftKey: true,
  view: true,
  "char": true,
  charCode: true,
  key: true,
  keyCode: true,
  button: true,
  buttons: true,
  clientX: true,
  clientY: true,
  offsetX: true,
  offsetY: true,
  pointerId: true,
  pointerType: true,
  screenX: true,
  screenY: true,
  targetTouches: true,
  toElement: true,
  touches: true,

  which: function (event) {
    var button = event.button;

    // Add which for key events
    if (event.which == null && rkeyEvent.test(event.type)) {
      return event.charCode != null ? event.charCode : event.keyCode;
    }

    // Add which for click: 1 === left; 2 === middle; 3 === right
    if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
      if (button & 1) {
        return 1;
      }

      if (button & 2) {
        return 3;
      }

      if (button & 4) {
        return 2;
      }

      return 0;
    }

    return event.which;
  }
}, jQuery.event.addProp);

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each({
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  pointerenter: "pointerover",
  pointerleave: "pointerout"
}, function (orig, fix) {
  jQuery.event.special[orig] = {
    delegateType: fix,
    bindType: fix,

    handle: function (event) {
      var ret,
        target = this,
        related = event.relatedTarget,
        handleObj = event.handleObj;

      // For mouseenter/leave call the handler if related is outside the target.
      // NB: No relatedTarget if the mouse left/entered the browser window
      if (!related || (related !== target && !jQuery.contains(target, related))) {
        event.type = handleObj.origType;
        ret = handleObj.handler.apply(this, arguments);
        event.type = fix;
      }
      return ret;
    }
  };
});

jQuery.fn.extend({

  on: function (types, selector, data, fn) {
    return on(this, types, selector, data, fn);
  },
  one: function (types, selector, data, fn) {
    return on(this, types, selector, data, fn, 1);
  },
  off: function (types, selector, fn) {
    var handleObj, type;
    if (types && types.preventDefault && types.handleObj) {

      // ( event )  dispatched jQuery.Event
      handleObj = types.handleObj;
      jQuery(types.delegateTarget).off(
        handleObj.namespace ?
          handleObj.origType + "." + handleObj.namespace :
          handleObj.origType,
        handleObj.selector,
        handleObj.handler
      );
      return this;
    }
    if (typeof types === "object") {

      // ( types-object [, selector] )
      for (type in types) {
        this.off(type, selector, types[type]);
      }
      return this;
    }
    if (selector === false || typeof selector === "function") {

      // ( types [, fn] )
      fn = selector;
      selector = undefined;
    }
    if (fn === false) {
      fn = returnFalse;
    }
    return this.each(function () {
      jQuery.event.remove(this, types, fn, selector);
    });
  }
});


var

  /* eslint-disable max-len */

  // See https://github.com/eslint/eslint/issues/3229
  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

  /* eslint-enable */

  // Support: IE <=10 - 11, Edge 12 - 13 only
  // In IE/Edge using regex groups here causes severe slowdowns.
  // See https://connect.microsoft.com/IE/feedback/details/1736512/
  rnoInnerhtml = /<script|<style|<link/i,

  // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
  rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget(elem, content) {
  if (nodeName(elem, "table") &&
    nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {

    return jQuery(elem).children("tbody")[0] || elem;
  }

  return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript(elem) {
  elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
  return elem;
}

function restoreScript(elem) {
  if ((elem.type || "").slice(0, 5) === "true/") {
    elem.type = elem.type.slice(5);
  } else {
    elem.removeAttribute("type");
  }

  return elem;
}

function cloneCopyEvent(src, dest) {
  var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

  if (dest.nodeType !== 1) {
    return;
  }

  // 1. Copy private data: events, handlers, etc.
  if (dataPriv.hasData(src)) {
    pdataOld = dataPriv.access(src);
    pdataCur = dataPriv.set(dest, pdataOld);
    events = pdataOld.events;

    if (events) {
      delete pdataCur.handle;
      pdataCur.events = {};

      for (type in events) {
        for (i = 0, l = events[type].length; i < l; i++) {
          jQuery.event.add(dest, type, events[type][i]);
        }
      }
    }
  }

  // 2. Copy user data
  if (dataUser.hasData(src)) {
    udataOld = dataUser.access(src);
    udataCur = jQuery.extend({}, udataOld);

    dataUser.set(dest, udataCur);
  }
}

// Fix IE bugs, see support tests
function fixInput(src, dest) {
  var nodeName = dest.nodeName.toLowerCase();

  // Fails to persist the checked state of a cloned checkbox or radio button.
  if (nodeName === "input" && rcheckableType.test(src.type)) {
    dest.checked = src.checked;

    // Fails to return the selected option to the default selected state when cloning options
  } else if (nodeName === "input" || nodeName === "textarea") {
    dest.defaultValue = src.defaultValue;
  }
}

function domManip(collection, args, callback, ignored) {

  // Flatten any nested arrays
  args = concat.apply([], args);

  var fragment, first, scripts, hasScripts, node, doc,
    i = 0,
    l = collection.length,
    iNoClone = l - 1,
    value = args[0],
    valueIsFunction = isFunction(value);

  // We can't cloneNode fragments that contain checked, in WebKit
  if (valueIsFunction ||
    (l > 1 && typeof value === "string" &&
      !support.checkClone && rchecked.test(value))) {
    return collection.each(function (index) {
      var self = collection.eq(index);
      if (valueIsFunction) {
        args[0] = value.call(this, index, self.html());
      }
      domManip(self, args, callback, ignored);
    });
  }

  if (l) {
    fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
    first = fragment.firstChild;

    if (fragment.childNodes.length === 1) {
      fragment = first;
    }

    // Require either new content or an interest in ignored elements to invoke the callback
    if (first || ignored) {
      scripts = jQuery.map(getAll(fragment, "script"), disableScript);
      hasScripts = scripts.length;

      // Use the original fragment for the last item
      // instead of the first because it can end up
      // being emptied incorrectly in certain situations (#8070).
      for (; i < l; i++) {
        node = fragment;

        if (i !== iNoClone) {
          node = jQuery.clone(node, true, true);

          // Keep references to cloned scripts for later restoration
          if (hasScripts) {

            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge(scripts, getAll(node, "script"));
          }
        }

        callback.call(collection[i], node, i);
      }

      if (hasScripts) {
        doc = scripts[scripts.length - 1].ownerDocument;

        // Reenable scripts
        jQuery.map(scripts, restoreScript);

        // Evaluate executable scripts on first document insertion
        for (i = 0; i < hasScripts; i++) {
          node = scripts[i];
          if (rscriptType.test(node.type || "") &&
            !dataPriv.access(node, "globalEval") &&
            jQuery.contains(doc, node)) {

            if (node.src && (node.type || "").toLowerCase() !== "module") {

              // Optional AJAX dependency, but won't run scripts if not present
              if (jQuery._evalUrl) {
                jQuery._evalUrl(node.src);
              }
            } else {
              DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
            }
          }
        }
      }
    }
  }

  return collection;
}

function remove(elem, selector, keepData) {
  var node,
    nodes = selector ? jQuery.filter(selector, elem) : elem,
    i = 0;

  for (; (node = nodes[i]) != null; i++) {
    if (!keepData && node.nodeType === 1) {
      jQuery.cleanData(getAll(node));
    }

    if (node.parentNode) {
      if (keepData && jQuery.contains(node.ownerDocument, node)) {
        setGlobalEval(getAll(node, "script"));
      }
      node.parentNode.removeChild(node);
    }
  }

  return elem;
}

jQuery.extend({
  htmlPrefilter: function (html) {
    return html.replace(rxhtmlTag, "<$1></$2>");
  },

  clone: function (elem, dataAndEvents, deepDataAndEvents) {
    var i, l, srcElements, destElements,
      clone = elem.cloneNode(true),
      inPage = jQuery.contains(elem.ownerDocument, elem);

    // Fix IE cloning issues
    if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
      !jQuery.isXMLDoc(elem)) {

      // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
      destElements = getAll(clone);
      srcElements = getAll(elem);

      for (i = 0, l = srcElements.length; i < l; i++) {
        fixInput(srcElements[i], destElements[i]);
      }
    }

    // Copy the events from the original to the clone
    if (dataAndEvents) {
      if (deepDataAndEvents) {
        srcElements = srcElements || getAll(elem);
        destElements = destElements || getAll(clone);

        for (i = 0, l = srcElements.length; i < l; i++) {
          cloneCopyEvent(srcElements[i], destElements[i]);
        }
      } else {
        cloneCopyEvent(elem, clone);
      }
    }

    // Preserve script evaluation history
    destElements = getAll(clone, "script");
    if (destElements.length > 0) {
      setGlobalEval(destElements, !inPage && getAll(elem, "script"));
    }

    // Return the cloned set
    return clone;
  },

  cleanData: function (elems) {
    var data, elem, type,
      special = jQuery.event.special,
      i = 0;

    for (; (elem = elems[i]) !== undefined; i++) {
      if (acceptData(elem)) {
        if ((data = elem[dataPriv.expando])) {
          if (data.events) {
            for (type in data.events) {
              if (special[type]) {
                jQuery.event.remove(elem, type);

                // This is a shortcut to avoid jQuery.event.remove's overhead
              } else {
                jQuery.removeEvent(elem, type, data.handle);
              }
            }
          }

          // Support: Chrome <=35 - 45+
          // Assign undefined instead of using delete, see Data#remove
          elem[dataPriv.expando] = undefined;
        }
        if (elem[dataUser.expando]) {

          // Support: Chrome <=35 - 45+
          // Assign undefined instead of using delete, see Data#remove
          elem[dataUser.expando] = undefined;
        }
      }
    }
  }
});

jQuery.fn.extend({
  detach: function (selector) {
    return remove(this, selector, true);
  },

  remove: function (selector) {
    return remove(this, selector);
  },

  text: function (value) {
    return access(this, function (value) {
      return value === undefined ?
        jQuery.text(this) :
        this.empty().each(function () {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
    }, null, value, arguments.length);
  },

  append: function () {
    return domManip(this, arguments, function (elem) {
      if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
        var target = manipulationTarget(this, elem);
        target.appendChild(elem);
      }
    });
  },

  prepend: function () {
    return domManip(this, arguments, function (elem) {
      if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
        var target = manipulationTarget(this, elem);
        target.insertBefore(elem, target.firstChild);
      }
    });
  },

  before: function () {
    return domManip(this, arguments, function (elem) {
      if (this.parentNode) {
        this.parentNode.insertBefore(elem, this);
      }
    });
  },

  after: function () {
    return domManip(this, arguments, function (elem) {
      if (this.parentNode) {
        this.parentNode.insertBefore(elem, this.nextSibling);
      }
    });
  },

  empty: function () {
    var elem,
      i = 0;

    for (; (elem = this[i]) != null; i++) {
      if (elem.nodeType === 1) {

        // Prevent memory leaks
        jQuery.cleanData(getAll(elem, false));

        // Remove any remaining nodes
        elem.textContent = "";
      }
    }

    return this;
  },

  clone: function (dataAndEvents, deepDataAndEvents) {
    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

    return this.map(function () {
      return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
    });
  },

  html: function (value) {
    return access(this, function (value) {
      var elem = this[0] || {},
        i = 0,
        l = this.length;

      if (value === undefined && elem.nodeType === 1) {
        return elem.innerHTML;
      }

      // See if we can take a shortcut and just use innerHTML
      if (typeof value === "string" && !rnoInnerhtml.test(value) &&
        !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

        value = jQuery.htmlPrefilter(value);

        try {
          for (; i < l; i++) {
            elem = this[i] || {};

            // Remove element nodes and prevent memory leaks
            if (elem.nodeType === 1) {
              jQuery.cleanData(getAll(elem, false));
              elem.innerHTML = value;
            }
          }

          elem = 0;

          // If using innerHTML throws an exception, use the fallback method
        } catch (e) {
        }
      }

      if (elem) {
        this.empty().append(value);
      }
    }, null, value, arguments.length);
  },

  replaceWith: function () {
    var ignored = [];

    // Make the changes, replacing each non-ignored context element with the new content
    return domManip(this, arguments, function (elem) {
      var parent = this.parentNode;

      if (jQuery.inArray(this, ignored) < 0) {
        jQuery.cleanData(getAll(this));
        if (parent) {
          parent.replaceChild(elem, this);
        }
      }

      // Force callback invocation
    }, ignored);
  }
});

jQuery.each({
  appendTo: "append",
  prependTo: "prepend",
  insertBefore: "before",
  insertAfter: "after",
  replaceAll: "replaceWith"
}, function (name, original) {
  jQuery.fn[name] = function (selector) {
    var elems,
      ret = [],
      insert = jQuery(selector),
      last = insert.length - 1,
      i = 0;

    for (; i <= last; i++) {
      elems = i === last ? this : this.clone(true);
      jQuery(insert[i])[original](elems);

      // Support: Android <=4.0 only, PhantomJS 1 only
      // .get() because push.apply(_, arraylike) throws on ancient WebKit
      push.apply(ret, elems.get());
    }

    return this.pushStack(ret);
  };
});
var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

var getStyles = function (elem) {

  // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
  // IE throws on elements created in popups
  // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
  var view = elem.ownerDocument.defaultView;

  if (!view || !view.opener) {
    view = window;
  }

  return view.getComputedStyle(elem);
};

var rboxStyle = new RegExp(cssExpand.join("|"), "i");


(function () {

  // Executing both pixelPosition & boxSizingReliable tests require only one layout
  // so they're executed at the same time to save the second computation.
  function computeStyleTests() {

    // This is a singleton, we need to execute it only once
    if (!div) {
      return;
    }

    container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
      "margin-top:1px;padding:0;border:0";
    div.style.cssText =
      "position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
      "margin:auto;border:1px;padding:1px;" +
      "width:60%;top:1%";
    documentElement.appendChild(container).appendChild(div);

    var divStyle = window.getComputedStyle(div);
    pixelPositionVal = divStyle.top !== "1%";

    // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
    reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;

    // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
    // Some styles come back with percentage values, even though they shouldn't
    div.style.right = "60%";
    pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;

    // Support: IE 9 - 11 only
    // Detect misreporting of content dimensions for box-sizing:border-box elements
    boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;

    // Support: IE 9 only
    // Detect overflow:scroll screwiness (gh-3699)
    div.style.position = "absolute";
    scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

    documentElement.removeChild(container);

    // Nullify the div so it wouldn't be stored in the memory and
    // it will also be a sign that checks already performed
    div = null;
  }

  function roundPixelMeasures(measure) {
    return Math.round(parseFloat(measure));
  }

  var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
    reliableMarginLeftVal,
    container = document$1.createElement("div"),
    div = document$1.createElement("div");

  // Finish early in limited (non-browser) environments
  if (!div.style) {
    return;
  }

  // Support: IE <=9 - 11 only
  // Style of cloned element affects source element cloned (#8908)
  div.style.backgroundClip = "content-box";
  div.cloneNode(true).style.backgroundClip = "";
  support.clearCloneStyle = div.style.backgroundClip === "content-box";

  jQuery.extend(support, {
    boxSizingReliable: function () {
      computeStyleTests();
      return boxSizingReliableVal;
    },
    pixelBoxStyles: function () {
      computeStyleTests();
      return pixelBoxStylesVal;
    },
    pixelPosition: function () {
      computeStyleTests();
      return pixelPositionVal;
    },
    reliableMarginLeft: function () {
      computeStyleTests();
      return reliableMarginLeftVal;
    },
    scrollboxSize: function () {
      computeStyleTests();
      return scrollboxSizeVal;
    }
  });
})();


function curCSS(elem, name, computed) {
  var width, minWidth, maxWidth, ret,

    // Support: Firefox 51+
    // Retrieving style before computed somehow
    // fixes an issue with getting wrong values
    // on detached elements
    style = elem.style;

  computed = computed || getStyles(elem);

  // getPropertyValue is needed for:
  //   .css('filter') (IE 9 only, #12537)
  //   .css('--customProperty) (#3144)
  if (computed) {
    ret = computed.getPropertyValue(name) || computed[name];

    if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
      ret = jQuery.style(elem, name);
    }

    // A tribute to the "awesome hack by Dean Edwards"
    // Android Browser returns percentage for some values,
    // but width seems to be reliably pixels.
    // This is against the CSSOM draft spec:
    // https://drafts.csswg.org/cssom/#resolved-values
    if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {

      // Remember the original values
      width = style.width;
      minWidth = style.minWidth;
      maxWidth = style.maxWidth;

      // Put in the new values to get a computed value out
      style.minWidth = style.maxWidth = style.width = ret;
      ret = computed.width;

      // Revert the changed values
      style.width = width;
      style.minWidth = minWidth;
      style.maxWidth = maxWidth;
    }
  }

  return ret !== undefined ?

    // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + "" :
    ret;
}


function addGetHookIf(conditionFn, hookFn) {

  // Define the hook, we'll check on the first run if it's really needed.
  return {
    get: function () {
      if (conditionFn()) {

        // Hook not needed (or it's not possible to use it due
        // to missing dependency), remove it.
        delete this.get;
        return;
      }

      // Hook needed; redefine it so that the support test is not executed again.
      return (this.get = hookFn).apply(this, arguments);
    }
  };
}


var

  // Swappable if display is none or starts with table
  // except "table", "table-cell", or "table-caption"
  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  rcustomProp = /^--/,
  cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  },

  cssPrefixes = ["Webkit", "Moz", "ms"],
  emptyStyle = document$1.createElement("div").style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName(name) {

  // Shortcut for names that are not vendor prefixed
  if (name in emptyStyle) {
    return name;
  }

  // Check for vendor prefixed names
  var capName = name[0].toUpperCase() + name.slice(1),
    i = cssPrefixes.length;

  while (i--) {
    name = cssPrefixes[i] + capName;
    if (name in emptyStyle) {
      return name;
    }
  }
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName(name) {
  var ret = jQuery.cssProps[name];
  if (!ret) {
    ret = jQuery.cssProps[name] = vendorPropName(name) || name;
  }
  return ret;
}

function setPositiveNumber(elem, value, subtract) {

  // Any relative (+/-) values have already been
  // normalized at this point
  var matches = rcssNum.exec(value);
  return matches ?

    // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") :
    value;
}

function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
  var i = dimension === "width" ? 1 : 0,
    extra = 0,
    delta = 0;

  // Adjustment may not be necessary
  if (box === (isBorderBox ? "border" : "content")) {
    return 0;
  }

  for (; i < 4; i += 2) {

    // Both box models exclude margin
    if (box === "margin") {
      delta += jQuery.css(elem, box + cssExpand[i], true, styles);
    }

    // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
    if (!isBorderBox) {

      // Add padding
      delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

      // For "border" or "margin", add border
      if (box !== "padding") {
        delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);

        // But still keep track of it otherwise
      } else {
        extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
      }

      // If we get here with a border-box (content + padding + border), we're seeking "content" or
      // "padding" or "margin"
    } else {

      // For "content", subtract padding
      if (box === "content") {
        delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
      }

      // For "content" or "padding", subtract border
      if (box !== "margin") {
        delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
      }
    }
  }

  // Account for positive content-box scroll gutter when requested by providing computedVal
  if (!isBorderBox && computedVal >= 0) {

    // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
    // Assuming integer scroll gutter, subtract the rest and round down
    delta += Math.max(0, Math.ceil(
      elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
      computedVal -
      delta -
      extra -
      0.5
    ));
  }

  return delta;
}

function getWidthOrHeight(elem, dimension, extra) {

  // Start with computed style
  var styles = getStyles(elem),
    val = curCSS(elem, dimension, styles),
    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
    valueIsBorderBox = isBorderBox;

  // Support: Firefox <=54
  // Return a confounding non-pixel value or feign ignorance, as appropriate.
  if (rnumnonpx.test(val)) {
    if (!extra) {
      return val;
    }
    val = "auto";
  }

  // Check for style in case a browser which returns unreliable values
  // for getComputedStyle silently falls back to the reliable elem.style
  valueIsBorderBox = valueIsBorderBox &&
    (support.boxSizingReliable() || val === elem.style[dimension]);

  // Fall back to offsetWidth/offsetHeight when value is "auto"
  // This happens for inline elements with no explicit setting (gh-3571)
  // Support: Android <=4.1 - 4.3 only
  // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
  if (val === "auto" ||
    !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {

    val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)];

    // offsetWidth/offsetHeight provide border-box values
    valueIsBorderBox = true;
  }

  // Normalize "" and auto
  val = parseFloat(val) || 0;

  // Adjust for the element's box model
  return (val +
    boxModelAdjustment(
      elem,
      dimension,
      extra || (isBorderBox ? "border" : "content"),
      valueIsBorderBox,
      styles,

      // Provide the current computed size to request scroll gutter calculation (gh-3589)
      val
    )
  ) + "px";
}

jQuery.extend({

  // Add in style property hooks for overriding the default
  // behavior of getting and setting a style property
  cssHooks: {
    opacity: {
      get: function (elem, computed) {
        if (computed) {

          // We should always get a number back from opacity
          var ret = curCSS(elem, "opacity");
          return ret === "" ? "1" : ret;
        }
      }
    }
  },

  // Don't automatically add "px" to these possibly-unitless properties
  cssNumber: {
    "animationIterationCount": true,
    "columnCount": true,
    "fillOpacity": true,
    "flexGrow": true,
    "flexShrink": true,
    "fontWeight": true,
    "lineHeight": true,
    "opacity": true,
    "order": true,
    "orphans": true,
    "widows": true,
    "zIndex": true,
    "zoom": true
  },

  // Add in properties whose names you wish to fix before
  // setting or getting the value
  cssProps: {},

  // Get and set the style property on a DOM Node
  style: function (elem, name, value, extra) {

    // Don't set styles on text and comment nodes
    if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
      return;
    }

    // Make sure that we're working with the right name
    var ret, type, hooks,
      origName = camelCase(name),
      isCustomProp = rcustomProp.test(name),
      style = elem.style;

    // Make sure that we're working with the right name. We don't
    // want to query the value if it is a CSS custom property
    // since they are user-defined.
    if (!isCustomProp) {
      name = finalPropName(origName);
    }

    // Gets hook for the prefixed version, then unprefixed version
    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

    // Check if we're setting a value
    if (value !== undefined) {
      type = typeof value;

      // Convert "+=" or "-=" to relative numbers (#7345)
      if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
        value = adjustCSS(elem, name, ret);

        // Fixes bug #9237
        type = "number";
      }

      // Make sure that null and NaN values aren't set (#7116)
      if (value == null || value !== value) {
        return;
      }

      // If a number was passed in, add the unit (except for certain CSS properties)
      if (type === "number") {
        value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
      }

      // background-* props affect original clone's values
      if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
        style[name] = "inherit";
      }

      // If a hook was provided, use that value, otherwise just set the specified value
      if (!hooks || !("set" in hooks) ||
        (value = hooks.set(elem, value, extra)) !== undefined) {

        if (isCustomProp) {
          style.setProperty(name, value);
        } else {
          style[name] = value;
        }
      }

    } else {

      // If a hook was provided get the non-computed value from there
      if (hooks && "get" in hooks &&
        (ret = hooks.get(elem, false, extra)) !== undefined) {

        return ret;
      }

      // Otherwise just get the value from the style object
      return style[name];
    }
  },

  css: function (elem, name, extra, styles) {
    var val, num, hooks,
      origName = camelCase(name),
      isCustomProp = rcustomProp.test(name);

    // Make sure that we're working with the right name. We don't
    // want to modify the value if it is a CSS custom property
    // since they are user-defined.
    if (!isCustomProp) {
      name = finalPropName(origName);
    }

    // Try prefixed name followed by the unprefixed name
    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

    // If a hook was provided get the computed value from there
    if (hooks && "get" in hooks) {
      val = hooks.get(elem, true, extra);
    }

    // Otherwise, if a way to get the computed value exists, use that
    if (val === undefined) {
      val = curCSS(elem, name, styles);
    }

    // Convert "normal" to computed value
    if (val === "normal" && name in cssNormalTransform) {
      val = cssNormalTransform[name];
    }

    // Make numeric if forced or a qualifier was provided and val looks numeric
    if (extra === "" || extra) {
      num = parseFloat(val);
      return extra === true || isFinite(num) ? num || 0 : val;
    }

    return val;
  }
});

jQuery.each(["height", "width"], function (i, dimension) {
  jQuery.cssHooks[dimension] = {
    get: function (elem, computed, extra) {
      if (computed) {

        // Certain elements can have dimension info if we invisibly show them
        // but it must have a current display style that would benefit
        return rdisplayswap.test(jQuery.css(elem, "display")) &&

          // Support: Safari 8+
          // Table columns in Safari have non-zero offsetWidth & zero
          // getBoundingClientRect().width unless display is changed.
          // Support: IE <=11 only
          // Running getBoundingClientRect on a disconnected node
          // in IE throws an error.
          (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ?
          swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, dimension, extra);
          }) :
          getWidthOrHeight(elem, dimension, extra);
      }
    },

    set: function (elem, value, extra) {
      var matches,
        styles = getStyles(elem),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
        subtract = extra && boxModelAdjustment(
          elem,
          dimension,
          extra,
          isBorderBox,
          styles
        );

      // Account for unreliable border-box dimensions by comparing offset* to computed and
      // faking a content-box to get border and padding (gh-3699)
      if (isBorderBox && support.scrollboxSize() === styles.position) {
        subtract -= Math.ceil(
          elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
          parseFloat(styles[dimension]) -
          boxModelAdjustment(elem, dimension, "border", false, styles) -
          0.5
        );
      }

      // Convert to pixels if value adjustment is needed
      if (subtract && (matches = rcssNum.exec(value)) &&
        (matches[3] || "px") !== "px") {

        elem.style[dimension] = value;
        value = jQuery.css(elem, dimension);
      }

      return setPositiveNumber(elem, value, subtract);
    }
  };
});

jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft,
  function (elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) ||
        elem.getBoundingClientRect().left -
        swap(elem, { marginLeft: 0 }, function () {
          return elem.getBoundingClientRect().left;
        })
      ) + "px";
    }
  }
);

// These hooks are used by animate to expand properties
jQuery.each({
  margin: "",
  padding: "",
  border: "Width"
}, function (prefix, suffix) {
  jQuery.cssHooks[prefix + suffix] = {
    expand: function (value) {
      var i = 0,
        expanded = {},

        // Assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [value];

      for (; i < 4; i++) {
        expanded[prefix + cssExpand[i] + suffix] =
          parts[i] || parts[i - 2] || parts[0];
      }

      return expanded;
    }
  };

  if (prefix !== "margin") {
    jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
  }
});

jQuery.fn.extend({
  css: function (name, value) {
    return access(this, function (elem, name, value) {
      var styles, len,
        map = {},
        i = 0;

      if (Array.isArray(name)) {
        styles = getStyles(elem);
        len = name.length;

        for (; i < len; i++) {
          map[name[i]] = jQuery.css(elem, name[i], false, styles);
        }

        return map;
      }

      return value !== undefined ?
        jQuery.style(elem, name, value) :
        jQuery.css(elem, name);
    }, name, value, arguments.length > 1);
  }
});


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function (time, type) {
  time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
  type = type || "fx";

  return this.queue(type, function (next, hooks) {
    var timeout = window.setTimeout(next, time);
    hooks.stop = function () {
      window.clearTimeout(timeout);
    };
  });
};


(function () {
  var input = document$1.createElement("input"),
    select = document$1.createElement("select"),
    opt = select.appendChild(document$1.createElement("option"));

  input.type = "checkbox";

  // Support: Android <=4.3 only
  // Default value for a checkbox should be "on"
  support.checkOn = input.value !== "";

  // Support: IE <=11 only
  // Must access selectedIndex to make default options select
  support.optSelected = opt.selected;

  // Support: IE <=11 only
  // An input loses its value after becoming a radio
  input = document$1.createElement("input");
  input.value = "t";
  input.type = "radio";
  support.radioValue = input.value === "t";
})();


var boolHook,
  attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
  attr: function (name, value) {
    return access(this, jQuery.attr, name, value, arguments.length > 1);
  },

  removeAttr: function (name) {
    return this.each(function () {
      jQuery.removeAttr(this, name);
    });
  }
});

jQuery.extend({
  attr: function (elem, name, value) {
    var ret, hooks,
      nType = elem.nodeType;

    // Don't get/set attributes on text, comment and attribute nodes
    if (nType === 3 || nType === 8 || nType === 2) {
      return;
    }

    // Fallback to prop when attributes are not supported
    if (typeof elem.getAttribute === "undefined") {
      return jQuery.prop(elem, name, value);
    }

    // Attribute hooks are determined by the lowercase version
    // Grab necessary hook if one is defined
    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
      hooks = jQuery.attrHooks[name.toLowerCase()] ||
        (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
    }

    if (value !== undefined) {
      if (value === null) {
        jQuery.removeAttr(elem, name);
        return;
      }

      if (hooks && "set" in hooks &&
        (ret = hooks.set(elem, value, name)) !== undefined) {
        return ret;
      }

      elem.setAttribute(name, value + "");
      return value;
    }

    if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
      return ret;
    }

    ret = jQuery.find.attr(elem, name);

    // Non-existent attributes return null, we normalize to undefined
    return ret == null ? undefined : ret;
  },

  attrHooks: {
    type: {
      set: function (elem, value) {
        if (!support.radioValue && value === "radio" &&
          nodeName(elem, "input")) {
          var val = elem.value;
          elem.setAttribute("type", value);
          if (val) {
            elem.value = val;
          }
          return value;
        }
      }
    }
  },

  removeAttr: function (elem, value) {
    var name,
      i = 0,

      // Attribute names can contain non-HTML whitespace characters
      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
      attrNames = value && value.match(rnothtmlwhite);

    if (attrNames && elem.nodeType === 1) {
      while ((name = attrNames[i++])) {
        elem.removeAttribute(name);
      }
    }
  }
});

// Hooks for boolean attributes
boolHook = {
  set: function (elem, value, name) {
    if (value === false) {

      // Remove boolean attributes when set to false
      jQuery.removeAttr(elem, name);
    } else {
      elem.setAttribute(name, name);
    }
    return name;
  }
};

jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
  var getter = attrHandle[name] || jQuery.find.attr;

  attrHandle[name] = function (elem, name, isXML) {
    var ret, handle,
      lowercaseName = name.toLowerCase();

    if (!isXML) {

      // Avoid an infinite loop by temporarily removing this function from the getter
      handle = attrHandle[lowercaseName];
      attrHandle[lowercaseName] = ret;
      ret = getter(elem, name, isXML) != null ?
        lowercaseName :
        null;
      attrHandle[lowercaseName] = handle;
    }
    return ret;
  };
});


var rfocusable = /^(?:input|select|textarea|button)$/i,
  rclickable = /^(?:a|area)$/i;

jQuery.fn.extend({
  prop: function (name, value) {
    return access(this, jQuery.prop, name, value, arguments.length > 1);
  },

  removeProp: function (name) {
    return this.each(function () {
      delete this[jQuery.propFix[name] || name];
    });
  }
});

jQuery.extend({
  prop: function (elem, name, value) {
    var ret, hooks,
      nType = elem.nodeType;

    // Don't get/set properties on text, comment and attribute nodes
    if (nType === 3 || nType === 8 || nType === 2) {
      return;
    }

    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

      // Fix name and attach hooks
      name = jQuery.propFix[name] || name;
      hooks = jQuery.propHooks[name];
    }

    if (value !== undefined) {
      if (hooks && "set" in hooks &&
        (ret = hooks.set(elem, value, name)) !== undefined) {
        return ret;
      }

      return (elem[name] = value);
    }

    if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
      return ret;
    }

    return elem[name];
  },

  propHooks: {
    tabIndex: {
      get: function (elem) {

        // Support: IE <=9 - 11 only
        // elem.tabIndex doesn't always return the
        // correct value when it hasn't been explicitly set
        // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
        // Use proper attribute retrieval(#12072)
        var tabindex = jQuery.find.attr(elem, "tabindex");

        if (tabindex) {
          return parseInt(tabindex, 10);
        }

        if (
          rfocusable.test(elem.nodeName) ||
          rclickable.test(elem.nodeName) &&
          elem.href
        ) {
          return 0;
        }

        return -1;
      }
    }
  },

  propFix: {
    "for": "htmlFor",
    "class": "className"
  }
});

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if (!support.optSelected) {
  jQuery.propHooks.selected = {
    get: function (elem) {

      /* eslint no-unused-expressions: "off" */

      var parent = elem.parentNode;
      if (parent && parent.parentNode) {
        parent.parentNode.selectedIndex;
      }
      return null;
    },
    set: function (elem) {

      /* eslint no-unused-expressions: "off" */

      var parent = elem.parentNode;
      if (parent) {
        parent.selectedIndex;

        if (parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
      }
    }
  };
}

jQuery.each([
  "tabIndex",
  "readOnly",
  "maxLength",
  "cellSpacing",
  "cellPadding",
  "rowSpan",
  "colSpan",
  "useMap",
  "frameBorder",
  "contentEditable"
], function () {
  jQuery.propFix[this.toLowerCase()] = this;
});


// Strip and collapse whitespace according to HTML spec
// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
function stripAndCollapse(value) {
  var tokens = value.match(rnothtmlwhite) || [];
  return tokens.join(" ");
}


function getClass(elem) {
  return elem.getAttribute && elem.getAttribute("class") || "";
}

function classesToArray(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "string") {
    return value.match(rnothtmlwhite) || [];
  }
  return [];
}

jQuery.fn.extend({
  addClass: function (value) {
    var classes, elem, cur, curValue, clazz, j, finalValue,
      i = 0;

    if (isFunction(value)) {
      return this.each(function (j) {
        jQuery(this).addClass(value.call(this, j, getClass(this)));
      });
    }

    classes = classesToArray(value);

    if (classes.length) {
      while ((elem = this[i++])) {
        curValue = getClass(elem);
        cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

        if (cur) {
          j = 0;
          while ((clazz = classes[j++])) {
            if (cur.indexOf(" " + clazz + " ") < 0) {
              cur += clazz + " ";
            }
          }

          // Only assign if different to avoid unneeded rendering.
          finalValue = stripAndCollapse(cur);
          if (curValue !== finalValue) {
            elem.setAttribute("class", finalValue);
          }
        }
      }
    }

    return this;
  },

  removeClass: function (value) {
    var classes, elem, cur, curValue, clazz, j, finalValue,
      i = 0;

    if (isFunction(value)) {
      return this.each(function (j) {
        jQuery(this).removeClass(value.call(this, j, getClass(this)));
      });
    }

    if (!arguments.length) {
      return this.attr("class", "");
    }

    classes = classesToArray(value);

    if (classes.length) {
      while ((elem = this[i++])) {
        curValue = getClass(elem);

        // This expression is here for better compressibility (see addClass)
        cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

        if (cur) {
          j = 0;
          while ((clazz = classes[j++])) {

            // Remove *all* instances
            while (cur.indexOf(" " + clazz + " ") > -1) {
              cur = cur.replace(" " + clazz + " ", " ");
            }
          }

          // Only assign if different to avoid unneeded rendering.
          finalValue = stripAndCollapse(cur);
          if (curValue !== finalValue) {
            elem.setAttribute("class", finalValue);
          }
        }
      }
    }

    return this;
  },

  toggleClass: function (value, stateVal) {
    var type = typeof value,
      isValidValue = type === "string" || Array.isArray(value);

    if (typeof stateVal === "boolean" && isValidValue) {
      return stateVal ? this.addClass(value) : this.removeClass(value);
    }

    if (isFunction(value)) {
      return this.each(function (i) {
        jQuery(this).toggleClass(
          value.call(this, i, getClass(this), stateVal),
          stateVal
        );
      });
    }

    return this.each(function () {
      var className, i, self, classNames;

      if (isValidValue) {

        // Toggle individual class names
        i = 0;
        self = jQuery(this);
        classNames = classesToArray(value);

        while ((className = classNames[i++])) {

          // Check each className given, space separated list
          if (self.hasClass(className)) {
            self.removeClass(className);
          } else {
            self.addClass(className);
          }
        }

        // Toggle whole class name
      } else if (value === undefined || type === "boolean") {
        className = getClass(this);
        if (className) {

          // Store className if set
          dataPriv.set(this, "__className__", className);
        }

        // If the element has a class name or if we're passed `false`,
        // then remove the whole classname (if there was one, the above saved it).
        // Otherwise bring back whatever was previously saved (if anything),
        // falling back to the empty string if nothing was stored.
        if (this.setAttribute) {
          this.setAttribute("class",
            className || value === false ?
              "" :
              dataPriv.get(this, "__className__") || ""
          );
        }
      }
    });
  },

  hasClass: function (selector) {
    var className, elem,
      i = 0;

    className = " " + selector + " ";
    while ((elem = this[i++])) {
      if (elem.nodeType === 1 &&
        (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
        return true;
      }
    }

    return false;
  }
});


var rreturn = /\r/g;

jQuery.fn.extend({
  val: function (value) {
    var hooks, ret, valueIsFunction,
      elem = this[0];

    if (!arguments.length) {
      if (elem) {
        hooks = jQuery.valHooks[elem.type] ||
          jQuery.valHooks[elem.nodeName.toLowerCase()];

        if (hooks &&
          "get" in hooks &&
          (ret = hooks.get(elem, "value")) !== undefined
        ) {
          return ret;
        }

        ret = elem.value;

        // Handle most common string cases
        if (typeof ret === "string") {
          return ret.replace(rreturn, "");
        }

        // Handle cases where value is null/undef or number
        return ret == null ? "" : ret;
      }

      return;
    }

    valueIsFunction = isFunction(value);

    return this.each(function (i) {
      var val;

      if (this.nodeType !== 1) {
        return;
      }

      if (valueIsFunction) {
        val = value.call(this, i, jQuery(this).val());
      } else {
        val = value;
      }

      // Treat null/undefined as ""; convert numbers to string
      if (val == null) {
        val = "";

      } else if (typeof val === "number") {
        val += "";

      } else if (Array.isArray(val)) {
        val = jQuery.map(val, function (value) {
          return value == null ? "" : value + "";
        });
      }

      hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

      // If set returns undefined, fall back to normal setting
      if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
        this.value = val;
      }
    });
  }
});

jQuery.extend({
  valHooks: {
    option: {
      get: function (elem) {

        var val = jQuery.find.attr(elem, "value");
        return val != null ?
          val :

          // Support: IE <=10 - 11 only
          // option.text throws exceptions (#14686, #14858)
          // Strip and collapse whitespace
          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
          stripAndCollapse(jQuery.text(elem));
      }
    },
    select: {
      get: function (elem) {
        var value, option, i,
          options = elem.options,
          index = elem.selectedIndex,
          one = elem.type === "select-one",
          values = one ? null : [],
          max = one ? index + 1 : options.length;

        if (index < 0) {
          i = max;

        } else {
          i = one ? index : 0;
        }

        // Loop through all the selected options
        for (; i < max; i++) {
          option = options[i];

          // Support: IE <=9 only
          // IE8-9 doesn't update selected after form reset (#2551)
          if ((option.selected || i === index) &&

            // Don't return options that are disabled or in a disabled optgroup
            !option.disabled &&
            (!option.parentNode.disabled ||
              !nodeName(option.parentNode, "optgroup"))) {

            // Get the specific value for the option
            value = jQuery(option).val();

            // We don't need an array for one selects
            if (one) {
              return value;
            }

            // Multi-Selects return an array
            values.push(value);
          }
        }

        return values;
      },

      set: function (elem, value) {
        var optionSet, option,
          options = elem.options,
          values = jQuery.makeArray(value),
          i = options.length;

        while (i--) {
          option = options[i];

          /* eslint-disable no-cond-assign */

          if (option.selected =
            jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1
          ) {
            optionSet = true;
          }

          /* eslint-enable no-cond-assign */
        }

        // Force browsers to behave consistently when non-matching value is set
        if (!optionSet) {
          elem.selectedIndex = -1;
        }
        return values;
      }
    }
  }
});

// Radios and checkboxes getter/setter
jQuery.each(["radio", "checkbox"], function () {
  jQuery.valHooks[this] = {
    set: function (elem, value) {
      if (Array.isArray(value)) {
        return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
      }
    }
  };
  if (!support.checkOn) {
    jQuery.valHooks[this].get = function (elem) {
      return elem.getAttribute("value") === null ? "on" : elem.value;
    };
  }
});


// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  stopPropagationCallback = function (e) {
    //e.stopPropagation();
  };

jQuery.extend(jQuery.event, {

  trigger: function (event, data, elem, onlyHandlers) {

    var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
      eventPath = [elem || document$1],
      type = hasOwn.call(event, "type") ? event.type : event,
      namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

    cur = lastElement = tmp = elem = elem || document$1;

    // Don't do events on text and comment nodes
    if (elem.nodeType === 3 || elem.nodeType === 8) {
      return;
    }

    // focus/blur morphs to focusin/out; ensure we're not firing them right now
    if (rfocusMorph.test(type + jQuery.event.triggered)) {
      return;
    }

    if (type.indexOf(".") > -1) {

      // Namespaced trigger; create a regexp to match event type in handle()
      namespaces = type.split(".");
      type = namespaces.shift();
      namespaces.sort();
    }
    ontype = type.indexOf(":") < 0 && "on" + type;

    // Caller can pass in a jQuery.Event object, Object, or just an event type string
    event = event[jQuery.expando] ?
      event :
      new jQuery.Event(type, typeof event === "object" && event);

    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
    event.isTrigger = onlyHandlers ? 2 : 3;
    event.namespace = namespaces.join(".");
    event.rnamespace = event.namespace ?
      new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
      null;

    // Clean up the event in case it is being reused
    event.result = undefined;
    if (!event.target) {
      event.target = elem;
    }

    // Clone any incoming data and prepend the event, creating the handler arg list
    data = data == null ?
      [event] :
      jQuery.makeArray(data, [event]);

    // Allow special events to draw outside the lines
    special = jQuery.event.special[type] || {};
    if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
      return;
    }

    // Determine event propagation path in advance, per W3C events spec (#9951)
    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
    if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {

      bubbleType = special.delegateType || type;
      if (!rfocusMorph.test(bubbleType + type)) {
        cur = cur.parentNode;
      }
      for (; cur; cur = cur.parentNode) {
        eventPath.push(cur);
        tmp = cur;
      }

      // Only add window if we got to document (e.g., not plain obj or detached DOM)
      if (tmp === (elem.ownerDocument || document$1)) {
        eventPath.push(tmp.defaultView || tmp.parentWindow || window);
      }
    }

    // Fire handlers on the event path
    i = 0;
    while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
      lastElement = cur;
      event.type = i > 1 ?
        bubbleType :
        special.bindType || type;

      // jQuery handler
      handle = (dataPriv.get(cur, "events") || {})[event.type] &&
        dataPriv.get(cur, "handle");
      if (handle) {
        handle.apply(cur, data);
      }

      // Native handler
      handle = ontype && cur[ontype];
      if (handle && handle.apply && acceptData(cur)) {
        event.result = handle.apply(cur, data);
        if (event.result === false) {
          event.preventDefault();
        }
      }
    }
    event.type = type;

    // If nobody prevented the default action, do it now
    if (!onlyHandlers && !event.isDefaultPrevented()) {

      if ((!special._default ||
        special._default.apply(eventPath.pop(), data) === false) &&
        acceptData(elem)) {

        // Call a native DOM method on the target with the same name as the event.
        // Don't do default actions on window, that's where global variables be (#6170)
        if (ontype && isFunction(elem[type]) && !isWindow(elem)) {

          // Don't re-trigger an onFOO event when we call its FOO() method
          tmp = elem[ontype];

          if (tmp) {
            elem[ontype] = null;
          }

          // Prevent re-triggering of the same event, since we already bubbled it above
          jQuery.event.triggered = type;

          if (event.isPropagationStopped()) {
            lastElement.addEventListener(type, stopPropagationCallback);
          }

          elem[type]();

          if (event.isPropagationStopped()) {
            lastElement.removeEventListener(type, stopPropagationCallback);
          }

          jQuery.event.triggered = undefined;

          if (tmp) {
            elem[ontype] = tmp;
          }
        }
      }
    }

    return event.result;
  },

  // Piggyback on a donor event to simulate a different one
  // Used only for `focus(in | out)` events
  simulate: function (type, elem, event) {
    var e = jQuery.extend(
      new jQuery.Event(),
      event,
      {
        type: type,
        isSimulated: true
      }
    );

    jQuery.event.trigger(e, null, elem);
  }

});

jQuery.fn.extend({

  trigger: function (type, data) {
    return this.each(function () {
      jQuery.event.trigger(type, data, this);
    });
  },
  triggerHandler: function (type, data) {
    var elem = this[0];
    if (elem) {
      return jQuery.event.trigger(type, data, elem, true);
    }
  }
});


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if (!support.focusin) {
  jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

    // Attach a single capturing handler on the document while someone wants focusin/focusout
    var handler = function (event) {
      jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
    };

    jQuery.event.special[fix] = {
      setup: function () {
        var doc = this.ownerDocument || this,
          attaches = dataPriv.access(doc, fix);

        if (!attaches) {
          doc.addEventListener(orig, handler, true);
        }
        dataPriv.access(doc, fix, (attaches || 0) + 1);
      },
      teardown: function () {
        var doc = this.ownerDocument || this,
          attaches = dataPriv.access(doc, fix) - 1;

        if (!attaches) {
          doc.removeEventListener(orig, handler, true);
          dataPriv.remove(doc, fix);

        } else {
          dataPriv.access(doc, fix, attaches);
        }
      }
    };
  });
}


var
  rbracket = /\[\]$/,
  rCRLF = /\r?\n/g,
  rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
  rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams(prefix, obj, traditional, add) {
  var name;

  if (Array.isArray(obj)) {

    // Serialize array item.
    jQuery.each(obj, function (i, v) {
      if (traditional || rbracket.test(prefix)) {

        // Treat each array item as a scalar.
        add(prefix, v);

      } else {

        // Item is non-scalar (array or object), encode its numeric index.
        buildParams(
          prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
          v,
          traditional,
          add
        );
      }
    });

  } else if (!traditional && toType(obj) === "object") {

    // Serialize object item.
    for (name in obj) {
      buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
    }

  } else {

    // Serialize scalar item.
    add(prefix, obj);
  }
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function (a, traditional) {
  var prefix,
    s = [],
    add = function (key, valueOrFunction) {

      // If value is a function, invoke it and use its return value
      var value = isFunction(valueOrFunction) ?
        valueOrFunction() :
        valueOrFunction;

      s[s.length] = encodeURIComponent(key) + "=" +
        encodeURIComponent(value == null ? "" : value);
    };

  // If an array was passed in, assume that it is an array of form elements.
  if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {

    // Serialize the form elements
    jQuery.each(a, function () {
      add(this.name, this.value);
    });

  } else {

    // If traditional, encode the "old" way (the way 1.3.2 or older
    // did it), otherwise encode params recursively.
    for (prefix in a) {
      buildParams(prefix, a[prefix], traditional, add);
    }
  }

  // Return the resulting serialization
  return s.join("&");
};

jQuery.fn.extend({
  serialize: function () {
    return jQuery.param(this.serializeArray());
  },
  serializeArray: function () {
    return this.map(function () {

      // Can add propHook for "elements" to filter or add form elements
      var elements = jQuery.prop(this, "elements");
      return elements ? jQuery.makeArray(elements) : this;
    })
      .filter(function () {
        var type = this.type;

        // Use .is( ":disabled" ) so that fieldset[disabled] works
        return this.name && !jQuery(this).is(":disabled") &&
          rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
          (this.checked || !rcheckableType.test(type));
      })
      .map(function (i, elem) {
        var val = jQuery(this).val();

        if (val == null) {
          return null;
        }

        if (Array.isArray(val)) {
          return jQuery.map(val, function (val) {
            return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
          });
        }

        return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
      }).get();
  }
});


jQuery.fn.extend({
  wrapAll: function (html) {
    var wrap;

    if (this[0]) {
      if (isFunction(html)) {
        html = html.call(this[0]);
      }

      // The elements to wrap the target around
      wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

      if (this[0].parentNode) {
        wrap.insertBefore(this[0]);
      }

      wrap.map(function () {
        var elem = this;

        while (elem.firstElementChild) {
          elem = elem.firstElementChild;
        }

        return elem;
      }).append(this);
    }

    return this;
  },

  wrapInner: function (html) {
    if (isFunction(html)) {
      return this.each(function (i) {
        jQuery(this).wrapInner(html.call(this, i));
      });
    }

    return this.each(function () {
      var self = jQuery(this),
        contents = self.contents();

      if (contents.length) {
        contents.wrapAll(html);

      } else {
        self.append(html);
      }
    });
  },

  wrap: function (html) {
    var htmlIsFunction = isFunction(html);

    return this.each(function (i) {
      jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
    });
  },

  unwrap: function (selector) {
    this.parent(selector).not("body").each(function () {
      jQuery(this).replaceWith(this.childNodes);
    });
    return this;
  }
});


jQuery.expr.pseudos.hidden = function (elem) {
  return !jQuery.expr.pseudos.visible(elem);
};
jQuery.expr.pseudos.visible = function (elem) {
  return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
};


// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = (function () {
  var body = document$1.implementation.createHTMLDocument("").body;
  body.innerHTML = "<form></form><form></form>";
  return body.childNodes.length === 2;
})();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function (data, context, keepScripts) {
  if (typeof data !== "string") {
    return [];
  }
  if (typeof context === "boolean") {
    keepScripts = context;
    context = false;
  }

  var base, parsed, scripts;

  if (!context) {

    // Stop scripts or inline event handlers from being executed immediately
    // by using document.implementation
    if (support.createHTMLDocument) {
      context = document$1.implementation.createHTMLDocument("");

      // Set the base href for the created document
      // so any parsed elements with URLs
      // are based on the document's URL (gh-2965)
      base = context.createElement("base");
      base.href = document$1.location.href;
      context.head.appendChild(base);
    } else {
      context = document$1;
    }
  }

  parsed = rsingleTag.exec(data);
  scripts = !keepScripts && [];

  // Single tag
  if (parsed) {
    return [context.createElement(parsed[1])];
  }

  parsed = buildFragment([data], context, scripts);

  if (scripts && scripts.length) {
    jQuery(scripts).remove();
  }

  return jQuery.merge([], parsed.childNodes);
};


jQuery.offset = {
  setOffset: function (elem, options, i) {
    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
      position = jQuery.css(elem, "position"),
      curElem = jQuery(elem),
      props = {};

    // Set position first, in-case top/left are set even on static elem
    if (position === "static") {
      elem.style.position = "relative";
    }

    curOffset = curElem.offset();
    curCSSTop = jQuery.css(elem, "top");
    curCSSLeft = jQuery.css(elem, "left");
    calculatePosition = (position === "absolute" || position === "fixed") &&
      (curCSSTop + curCSSLeft).indexOf("auto") > -1;

    // Need to be able to calculate position if either
    // top or left is auto and position is either absolute or fixed
    if (calculatePosition) {
      curPosition = curElem.position();
      curTop = curPosition.top;
      curLeft = curPosition.left;

    } else {
      curTop = parseFloat(curCSSTop) || 0;
      curLeft = parseFloat(curCSSLeft) || 0;
    }

    if (isFunction(options)) {

      // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
      options = options.call(elem, i, jQuery.extend({}, curOffset));
    }

    if (options.top != null) {
      props.top = (options.top - curOffset.top) + curTop;
    }
    if (options.left != null) {
      props.left = (options.left - curOffset.left) + curLeft;
    }

    if ("using" in options) {
      options.using.call(elem, props);

    } else {
      curElem.css(props);
    }
  }
};

jQuery.fn.extend({

  // offset() relates an element's border box to the document origin
  offset: function (options) {

    // Preserve chaining for setter
    if (arguments.length) {
      return options === undefined ?
        this :
        this.each(function (i) {
          jQuery.offset.setOffset(this, options, i);
        });
    }

    var rect, win,
      elem = this[0];

    if (!elem) {
      return;
    }

    // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
    // Support: IE <=11 only
    // Running getBoundingClientRect on a
    // disconnected node in IE throws an error
    if (!elem.getClientRects().length) {
      return { top: 0, left: 0 };
    }

    // Get document-relative position by adding viewport scroll to viewport-relative gBCR
    rect = elem.getBoundingClientRect();
    win = elem.ownerDocument.defaultView;
    return {
      top: rect.top + win.pageYOffset,
      left: rect.left + win.pageXOffset
    };
  },

  // position() relates an element's margin box to its offset parent's padding box
  // This corresponds to the behavior of CSS absolute positioning
  position: function () {
    if (!this[0]) {
      return;
    }

    var offsetParent, offset, doc,
      elem = this[0],
      parentOffset = { top: 0, left: 0 };

    // position:fixed elements are offset from the viewport, which itself always has zero offset
    if (jQuery.css(elem, "position") === "fixed") {

      // Assume position:fixed implies availability of getBoundingClientRect
      offset = elem.getBoundingClientRect();

    } else {
      offset = this.offset();

      // Account for the *real* offset parent, which can be the document or its root element
      // when a statically positioned element is identified
      doc = elem.ownerDocument;
      offsetParent = elem.offsetParent || doc.documentElement;
      while (offsetParent &&
        (offsetParent === doc.body || offsetParent === doc.documentElement) &&
        jQuery.css(offsetParent, "position") === "static") {

        offsetParent = offsetParent.parentNode;
      }
      if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {

        // Incorporate borders into its offset, since they are outside its content origin
        parentOffset = jQuery(offsetParent).offset();
        parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
      }
    }

    // Subtract parent offsets and element margins
    return {
      top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
      left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
    };
  },

  // This method will return documentElement in the following cases:
  // 1) For the element inside the iframe without offsetParent, this method will return
  //    documentElement of the parent window
  // 2) For the hidden or detached element
  // 3) For body or html element, i.e. in case of the html node - it will return itself
  //
  // but those exceptions were never presented as a real life use-cases
  // and might be considered as more preferable results.
  //
  // This logic, however, is not guaranteed and can change at any point in the future
  offsetParent: function () {
    return this.map(function () {
      var offsetParent = this.offsetParent;

      while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
        offsetParent = offsetParent.offsetParent;
      }

      return offsetParent || documentElement;
    });
  }
});

// Create scrollLeft and scrollTop methods
jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
  var top = "pageYOffset" === prop;

  jQuery.fn[method] = function (val) {
    return access(this, function (elem, method, val) {

      // Coalesce documents and windows
      var win;
      if (isWindow(elem)) {
        win = elem;
      } else if (elem.nodeType === 9) {
        win = elem.defaultView;
      }

      if (val === undefined) {
        return win ? win[prop] : elem[method];
      }

      if (win) {
        win.scrollTo(
          !top ? val : win.pageXOffset,
          top ? val : win.pageYOffset
        );

      } else {
        elem[method] = val;
      }
    }, method, val, arguments.length);
  };
});

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each(["top", "left"], function (i, prop) {
  jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
    function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);

        // If curCSS returns percentage, fallback to offset
        return rnumnonpx.test(computed) ?
          jQuery(elem).position()[prop] + "px" :
          computed;
      }
    }
  );
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
  jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name },
    function (defaultExtra, funcName) {

      // Margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
          extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

        return access(this, function (elem, type, value) {
          var doc;

          if (isWindow(elem)) {

            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
            return funcName.indexOf("outer") === 0 ?
              elem["inner" + name] :
              elem.document.documentElement["client" + name];
          }

          // Get document width or height
          if (elem.nodeType === 9) {
            doc = elem.documentElement;

            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest
            return Math.max(
              elem.body["scroll" + name], doc["scroll" + name],
              elem.body["offset" + name], doc["offset" + name],
              doc["client" + name]
            );
          }

          return value === undefined ?

            // Get width or height on the element, requesting but not forcing parseFloat
            jQuery.css(elem, type, extra) :

            // Set width or height on the element
            jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
});


jQuery.each(("blur focus focusin focusout resize scroll click dblclick " +
  "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  "change select submit keydown keypress keyup contextmenu").split(" "),
  function (i, name) {

    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ?
        this.on(name, null, data, fn) :
        this.trigger(name);
    };
  });

jQuery.fn.extend({
  hover: function (fnOver, fnOut) {
    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
  }
});


jQuery.fn.extend({

  bind: function (types, data, fn) {
    return this.on(types, null, data, fn);
  },
  unbind: function (types, fn) {
    return this.off(types, null, fn);
  },

  delegate: function (selector, types, data, fn) {
    return this.on(types, selector, data, fn);
  },
  undelegate: function (selector, types, fn) {

    // ( namespace ) or ( selector, types [, fn] )
    return arguments.length === 1 ?
      this.off(selector, "**") :
      this.off(types, selector || "**", fn);
  }
});

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function (fn, context) {
  var tmp, args, proxy;

  if (typeof context === "string") {
    tmp = fn[context];
    context = fn;
    fn = tmp;
  }

  // Quick check to determine if target is callable, in the spec
  // this throws a TypeError, but we will just return undefined.
  if (!isFunction(fn)) {
    return undefined;
  }

  // Simulated bind
  args = slice.call(arguments, 2);
  proxy = function () {
    return fn.apply(context || this, args.concat(slice.call(arguments)));
  };

  // Set the guid of unique handler to the same of original handler, so it can be removed
  proxy.guid = fn.guid = fn.guid || jQuery.guid++;

  return proxy;
};

jQuery.holdReady = function (hold) {
  if (hold) {
    jQuery.readyWait++;
  } else {
    jQuery.ready(true);
  }
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function (obj) {

  // As of jQuery 3.0, isNumeric is limited to
  // strings and numbers (primitives or objects)
  // that can be coerced to finite numbers (gh-2662)
  var type = jQuery.type(obj);
  return (type === "number" || type === "string") &&

    // parseFloat NaNs numeric-cast false positives ("")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    !isNaN(obj - parseFloat(obj));
};

const $ = jQuery;

/**
* Test if object is a File or File-like object.
*
* Copied from igv-utils.FileUtils version 1.3.8
*
* @param object
*/
function isFile(object) {
  if (!object) {
    return false;
  }
  return typeof object !== 'function' &&
    (object instanceof File ||
      (object.name !== undefined && typeof object.slice === 'function' && typeof object.arrayBuffer === 'function'))
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

/**
* Test if the given value is a string or number.  Not using typeof as it fails on boxed primitives.
*
* @param value
* @returns boolean
*/

function isSimpleType(value) {
  const simpleTypes = new Set(["boolean", "number", "string", "symbol"]);
  const valueType = typeof value;
  return (value !== undefined && (simpleTypes.has(valueType) || value.substring || value.toFixed))
}

function buildOptions$1(config, options) {

  var defaultOptions = {
    oauthToken: config.oauthToken,
    headers: config.headers,
    withCredentials: config.withCredentials,
    filename: config.filename
  };

  return Object.assign(defaultOptions, options);
}

/**
* isMobile test from http://detectmobilebrowsers.com
* TODO -- improve UI design so this isn't neccessary
* @returns {boolean}
*/

// igv.isMobile = function () {
//
//     const a = (navigator.userAgent || navigator.vendor || window.opera);
//     return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) ||
//         /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
//
// }

const doAutoscale = function (features) {
  var min, max;

  if (features.length > 0) {
    min = Number.MAX_VALUE;
    max = -Number.MAX_VALUE;

    features.forEach(function (f) {
      if (!Number.isNaN(f.value)) {
        min = Math.min(min, f.value);
        max = Math.max(max, f.value);
      }
    });

    // Insure we have a zero baseline
    if (max > 0) min = Math.min(0, min);
    if (max < 0) max = 0;
  } else {
    // No features -- default
    min = 0;
    max = 100;
  }

  return { min: min, max: max };
};

/*!
* is-number <https://github.com/jonschlinkert/is-number>
*
* Copyright (c) 2014-present, Jon Schlinkert.
* Released under the MIT License.
*/

const isNumber = function (num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};

function inferTrackType(config) {

  translateDeprecatedTypes(config);

  if (config.type) {
    return config.type;
  }

  let format;
  if ("file" === config.sourceType || (undefined === config.sourceType && config.url)) {
    if (undefined === config.format) {
      const path = isFile(config.url) ? config.url.name : config.url;
      format = inferFileFormat(path);
    } else {
      format = config.format.toLowerCase();
    }
  }

  if (format) {
    switch (format) {
      case "bw":
      case "bigwig":
      case "wig":
      case "bedgraph":
      case "tdf":
        return "wig";
      case "vcf":
        return "variant";
      case "seg":
        return "seg";
      case "bam":
      case "cram":
        return "alignment";
      case "bedpe":
      case "bedpe-loop":
        return "interaction";
      case "bp":
        return "arc";
      case "gwas":
        return "gwas";
      case "bed":
      case "bigbed":
      case "bb":
        return "bedtype";
      default:
        return "annotation";
    }
  }
}

function translateDeprecatedTypes(config) {

  if (config.featureType) {  // Translate deprecated "feature" type
    config.type = config.type || config.featureType;
    config.featureType = undefined;
  }
  if ("junctions" === config.type) {
    config.type = "spliceJunctions";
  } else if ("bed" === config.type) {
    config.type = "annotation";
    config.format = config.format || "bed";
  } else if ("annotations" === config.type) {
    config.type = "annotation";
  } else if ("alignments" === config.type) {
    config.type = "alignment";
  } else if ("bam" === config.type) {
    config.type = "alignment";
    config.format = "bam";
  } else if ("vcf" === config.type) {
    config.type = "variant";
    config.format = "vcf";
  } else if ("t2d" === config.type) {
    config.type = "gwas";
  } else if ("FusionJuncSpan" === config.type && !config.format) {
    config.format = "fusionjuncspan";
  } else if ("aed" === config.type) {
    config.type = "annotation";
    config.format = config.format || "aed";
  }
}

/**
* Decoder for bedpe records.
*
* Bedpe format was created by Aaron Quinlan et al as part of the bedtools project.
* The spec is here:  https://bedtools.readthedocs.io/en/latest/content/general-usage.html,  however there
* are off spec variants, an important one being a 7 column format with score in place of the standard
* name column.
*
* Another common variant is a "hiccups" output file, which is standard bedpe with the exception of a header line
* of the form
* chr1    x1    x2    chr2    y1    y2    name    score    strand1    strand2    color    observed    expectedBL    expectedDonut    expectedH    expectedV    fdrBL    fdrDonut    fdrH    fdrV
*
* @param tokens
* @param ignore
* @returns {{start1: number, end2: number, end1: number, chr1: *, chr2: *, start2: number}|undefined}
*/

function decodeBedpe(tokens, header) {

  if (tokens.length < 6) {
    console.log("Skipping line: " + tokens.join(' '));
    return undefined;
  }

  var feature = {
    chr1: tokens[0],
    start1: Number.parseInt(tokens[1]),
    end1: Number.parseInt(tokens[2]),
    chr2: tokens[3],
    start2: Number.parseInt(tokens[4]),
    end2: Number.parseInt(tokens[5])
  };

  if (isNaN(feature.start1) || isNaN(feature.end1) || isNaN(feature.start2) || isNaN(feature.end2)) {
    //throw Error(`Error parsing line: ${tokens.join('\t')}`);
    return undefined;
  }

  if (tokens.length > 6 && tokens[6] !== ".") {
    feature.name = tokens[6];
  }

  if (tokens.length > 7 && tokens[7] !== ".") {
    feature.score = parseFloat(tokens[7]);
  }

  if (tokens.length > 8 && tokens[8] !== ".") {
    feature.strand1 = tokens[8];
  }

  if (tokens.length > 9 && tokens[9] !== ".") {
    feature.strand2 = tokens[9];
  }

  // Optional extra columns
  if (header) {
    const colorColumn = header.colorColumn;
    if (colorColumn && colorColumn < tokens.length) {
      feature.color = IGVColor.createColorString(tokens[colorColumn]);
    }
    const thicknessColumn = header.thicknessColumn;
    if (thicknessColumn && thicknessColumn < tokens.length) {
      feature.thickness = tokens[thicknessColumn];
    }

    if (tokens.length > 10 && header.columnNames && header.columnNames.length === tokens.length) {
      feature.extras = tokens.slice(10);
    }
  }


  // Set total extent of feature
  if (feature.chr1 === feature.chr2) {
    feature.chr = feature.chr1;
    feature.start = Math.min(feature.start1, feature.start2);
    feature.end = Math.max(feature.end1, feature.end2);

  }
  return feature;
}

/**
* Hack for non-standard bedPE formats, where numeric score can be in column 7 (name field from spec)
* @param features
*/
function fixBedPE(features) {

  if (features.length == 0) return;

  // Assume all features have same properties
  const firstFeature = features[0];
  if (firstFeature.score === undefined && firstFeature.name !== undefined) {
    // Name field (col 7) is sometimes used for score.
    for (let f of features) {
      if (!(isNumber(f.name) || f.name === '.')) return;
    }
    for (let f of features) {
      f.score = parseFloat(f.name);
      delete f.name;
    }
  }

  // Make copies of inter-chr features, one for each chromosome
  const interChrFeatures = features.filter(f => f.chr1 !== f.chr2);
  for (let f1 of interChrFeatures) {
    const f2 = Object.assign({}, f1);
    f2.dup = true;
    features.push(f2);

    f1.chr = f1.chr1;
    f1.start = f1.start1;
    f1.end = f1.end1;

    f2.chr = f2.chr2;
    f2.start = f2.start2;
    f2.end = f2.end2;
  }
}


/**
* Special decoder for Hic Domain files.   In these files feature1 == feature2, they are really bed records.
* @param tokens
* @param ignore
* @returns {*}
*/
function decodeBedpeDomain(tokens, header) {

  if (tokens.length < 8) return undefined;

  return {
    chr: tokens[0],
    start: Number.parseInt(tokens[1]),
    end: Number.parseInt(tokens[2]),
    color: IGVColor.createColorString(tokens[6]),
    value: Number.parseFloat(tokens[7])
  };
}

/**
* Decode UCSC "interact" files.  See https://genome.ucsc.edu/goldenpath/help/interact.html
*
0  string chrom;        "Chromosome (or contig, scaffold, etc.). For interchromosomal, use 2 records"
1  uint chromStart;     "Start position of lower region. For interchromosomal, set to chromStart of this region"
2  uint chromEnd;       "End position of upper region. For interchromosomal, set to chromEnd of this region"
3  string name;         "Name of item, for display.  Usually 'sourceName/targetName/exp' or empty"
4  uint score;          "Score (0-1000)"
5  double value;        "Strength of interaction or other data value. Typically basis for score"
6  string exp;          "Experiment name (metadata for filtering). Use . if not applicable"
7  string color;        "Item color.  Specified as r,g,b or hexadecimal #RRGGBB or html color name, as in //www.w3.org/TR/css3-color/#html4. Use 0 and spectrum setting to shade by score"
8  string sourceChrom;  "Chromosome of source region (directional) or lower region. For non-directional interchromosomal, chrom of this region."
9  uint sourceStart;    "Start position in chromosome of source/lower/this region"
10 uint sourceEnd;      "End position in chromosome of source/lower/this region"
11 string sourceName;   "Identifier of source/lower/this region"
12 string sourceStrand; "Orientation of source/lower/this region: + or -.  Use . if not applicable"
13 string targetChrom;  "Chromosome of target region (directional) or upper region. For non-directional interchromosomal, chrom of other region"
14 uint targetStart;    "Start position in chromosome of target/upper/this region"
15 uint targetEnd;      "End position in chromosome of target/upper/this region"
16 string targetName;   "Identifier of target/upper/this region"
17 string targetStrand; "Orientation of target/upper/this region: + or -.  Use . if not applicable"
*
* @param tokens
* @param ignore
* @returns {*}
*/
function decodeInteract(tokens, header) {

  if (tokens.length < 6) {
    console.log("Skipping line: " + tokens.join(' '));
    return undefined;
  }

  var feature = {
    chr: tokens[0],
    start: tokens[1],
    end: tokens[2],

    chr1: tokens[8],
    start1: Number.parseInt(tokens[9]),
    end1: Number.parseInt(tokens[10]),

    chr2: tokens[13],
    start2: Number.parseInt(tokens[14]),
    end2: Number.parseInt(tokens[15]),

    name: tokens[3],
    score: Number.parseFloat(tokens[4]),
    value: Number.parseFloat(tokens[5]),
    color: tokens[7] === '.' ? undefined : tokens[7] === "0" ? "rgb(0,0,0)" : tokens[7],

  };

  return feature;
}

const gffNameFields = ["Name", "gene_name", "gene", "gene_id", "alias", "locus", "name"];

/**
* Decode a single gff record (1 line in file).  Aggregations such as gene models are constructed at a higher level.
*      ctg123 . mRNA            1050  9000  .  +  .  ID=mRNA00001;Parent=gene00001
* @param tokens
* @param ignore
* @returns {*}
*/
function decodeGFF(tokens, header) {

  var tokenCount, chr, start, end, strand, type, score, attributeString, color, name,
    i,
    format = header.format;

  tokenCount = tokens.length;
  if (tokenCount < 9) {
    return null;      // Not a valid gff record
  }

  chr = tokens[0];
  type = tokens[2];
  start = parseInt(tokens[3]) - 1;
  end = parseInt(tokens[4]);
  score = "." === tokens[5] ? 0 : parseFloat(tokens[5]);
  strand = tokens[6];
  "." === tokens[7] ? 0 : parseInt(tokens[7]);
  attributeString = tokens[8];

  // Find ID and Parent, or transcript_id
  var delim = ('gff3' === format) ? '=' : /\s+/;
  var attributes = parseAttributeString(attributeString, delim);
  for (let [key, value] of Object.entries(attributes)) {
    const keyLower = key.toLowerCase();
    if ("color" === keyLower || "colour" === keyLower) {
      color = IGVColor.createColorString(value);
    } else if ('gff3' === format)
      try {
        attributes[key] = unescape(value);
      } catch (e) {
        attributes[key] = value;   // Invalid
        console.error(`Malformed gff3 attibute value: ${value}`);
      }
  }

  // Find name (label) property
  if (header.nameField) {
    name = attributes[header.nameField];
  } else {
    for (i = 0; i < gffNameFields.length; i++) {
      if (attributes.hasOwnProperty(gffNameFields[i])) {
        header.nameField = gffNameFields[i];
        name = attributes[header.nameField];
        break;
      }
    }
  }

  const id = attributes["ID"] || attributes["transcript_id"];
  const parent = attributes["Parent"];

  return {
    id: id,
    parent: parent,
    name: name,
    type: type,
    chr: chr,
    start: start,
    end: end,
    score: score,
    strand: strand,
    color: color,
    attributeString: attributeString,
    delim: delim,
    popupData: popupData
  }

}

function parseAttributeString(attributeString, keyValueDelim) {
  // parse 'attributes' string (see column 9 docs in https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md)
  var attributes = {};
  for (let kv of attributeString.split(';')) {
    const t = kv.trim().split(keyValueDelim, 2);
    if (t.length === 2) {
      const key = t[0].trim();
      let value = t[1].trim();
      //Strip off quotes, if any
      if (value.startsWith('"') && value.endsWith('"')) {
        value = value.substr(1, value.length - 2);
      }
      attributes[key] = value;
    }
  }
  return attributes
}

function popupData(genomicLocation) {
  const kvs = this.attributeString.split(';');
  const pd = [];
  if (this.name) {
    pd.push({ name: 'name:', value: this.name });
  }
  pd.push({ name: 'type:', value: this.type });
  for (let kv of kvs) {
    const t = kv.trim().split(this.delim, 2);
    if (t.length === 2 && t[1] !== undefined) {
      const key = t[0].trim();
      if ('name' === key.toLowerCase()) continue;
      let value = t[1].trim();
      //Strip off quotes, if any
      if (value.startsWith('"') && value.endsWith('"')) {
        value = value.substr(1, value.length - 2);
      }
      pd.push({ name: key + ":", value: value });
    }
  }
  pd.push({
    name: 'position:',
    value: `${this.chr}:${numberFormatter(this.start + 1)}-${numberFormatter(this.end)}`
  });
  return pd;
}

/**
* Decode the UCSC bed format.  Only the first 3 columns (chr, start, end) are required.   The remaining columns
* must follow standard bed order, but we will tolerate deviations after column 3.
*
* @param tokens
* @param ignore
* @returns decoded feature, or null if this is not a valid record
*/
function decodeBed(tokens, header) {


  if (tokens.length < 3) return undefined;

  header && header.gffTags;

  const chr = tokens[0];
  const start = parseInt(tokens[1]);
  const end = tokens.length > 2 ? parseInt(tokens[2]) : start + 1;
  if (isNaN(start) || isNaN(end)) {
    throw Error(`Unparsable bed record: ${tokens.join('\t')}`);
  }
  const feature = { chr: chr, start: start, end: end, score: 1000 };

  try {
    if (tokens.length > 3) {

      // Note: these are very special rules for the gencode gene files.
      // tmp = tokens[3].replace(/"/g, '');
      // idName = tmp.split(';');
      // for (var i = 0; i < idName.length; i++) {
      //     var kv = idName[i].split('=');
      //     if (kv[0] == "gene_id") {
      //         id = kv[1];
      //     }
      //     if (kv[0] == "gene_name") {
      //         name = kv[1];
      //     }
      // }
      // feature.id = id ? id : tmp;
      // feature.name = name ? name : tmp;

      //parse gffTags in the name field
      if (tokens[3].indexOf(';') > 0 && tokens[3].indexOf('=') > 0) {
        const attributes = parseAttributeString(tokens[3], '=');
        for (let nmField of gffNameFields) {
          if (attributes.hasOwnProperty(nmField)) {
            feature.name = attributes[nmField];
            delete attributes[nmField];
            break;
          }
        }
        feature.attributes = attributes;
      }
      if (!feature.name) {
        feature.name = tokens[3] === '.' ? '' : tokens[3];
      }
    }

    if (tokens.length > 4) {
      feature.score = tokens[4] === '.' ? 0 : parseFloat(tokens[4]);
      if (isNaN(feature.score)) {
        return feature;
      }
    }

    if (tokens.length > 5) {
      feature.strand = tokens[5];
      if (!(feature.strand === '.' || feature.strand === '+' || feature.strand === '-')) {
        return feature;
      }
    }

    if (tokens.length > 6) {
      feature.cdStart = parseInt(tokens[6]);
      if (isNaN(feature.cdStart)) {
        return feature;
      }
    }

    if (tokens.length > 7) {
      feature.cdEnd = parseInt(tokens[7]);
      if (isNaN(feature.cdEnd)) {
        return feature;
      }
    }

    if (tokens.length > 8) {
      if (tokens[8] !== "." && tokens[8] !== "0")
        feature.color = IGVColor.createColorString(tokens[8]);
    }

    if (tokens.length > 11) {
      const exonCount = parseInt(tokens[9]);
      // Some basic validation
      if (exonCount > 1000) {
        // unlikely
        return feature;
      }

      const exonSizes = tokens[10].replace(/,$/, '').split(',');
      const exonStarts = tokens[11].replace(/,$/, '').split(',');
      if (!(exonSizes.length === exonStarts.length && exonCount === exonSizes.length)) {
        return feature;
      }

      const exons = [];
      for (let i = 0; i < exonCount; i++) {
        const eStart = start + parseInt(exonStarts[i]);
        const eEnd = eStart + parseInt(exonSizes[i]);
        exons.push({ start: eStart, end: eEnd });
      }
      findUTRs(exons, feature.cdStart, feature.cdEnd);
      feature.exons = exons;
    }

    // Optional extra columns
    if (header) {
      let thicknessColumn = header.thicknessColumn;
      let colorColumn = header.colorColumn;
      if (colorColumn && colorColumn < tokens.length) {
        feature.color = IGVColor.createColorString(tokens[colorColumn]);
      }
      if (thicknessColumn && thicknessColumn < tokens.length) {
        feature.thickness = tokens[thicknessColumn];
      }
    }
  } catch
  (e) {

  }

  return feature;

}

/**
* Decode a UCSC repeat masker record.
*
* Columns, from UCSC documentation
*
* 0  bin    585    smallint(5) unsigned    Indexing field to speed chromosome range queries.
* 1  swScore    1504    int(10) unsigned    Smith Waterman alignment score
* 2  milliDiv    13    int(10) unsigned    Base mismatches in parts per thousand
* 3  milliDel    4    int(10) unsigned    Bases deleted in parts per thousand
* 4  milliIns    13    int(10) unsigned    Bases inserted in parts per thousand
* 5  genoName    chr1    varchar(255)    Genomic sequence name
* 6  genoStart    10000    int(10) unsigned    Start in genomic sequence
* 7  genoEnd    10468    int(10) unsigned    End in genomic sequence
* 8  genoLeft    -249240153    int(11)    -#bases after match in genomic sequence
* 9  strand    +    char(1)    Relative orientation + or -
* 10 repName    (CCCTAA)n    varchar(255)    Name of repeat
* 11 repClass    Simple_repeat    varchar(255)    Class of repeat
* 12 repFamily    Simple_repeat    varchar(255)    Family of repeat
* 13 repStart    1    int(11)    Start (if strand is +) or -#bases after match (if strand is -) in repeat sequence
* 14 repEnd    463    int(11)    End in repeat sequence
* 15 repLeft    0    int(11)    -#bases after match (if strand is +) or start (if strand is -) in repeat sequence
* 16 id    1    char(1)    First digit of id field in RepeatMasker .out file. Best ignored.
*/
function decodeRepeatMasker(tokens, header) {

  if (tokens.length <= 15) return undefined;

  const feature = {
    swScore: Number.parseInt(tokens[1]),
    milliDiv: Number.parseInt(tokens[2]),
    milliDel: Number.parseInt(tokens[3]),
    milliIns: Number.parseInt(tokens[4]),
    chr: tokens[5],
    start: Number.parseInt(tokens[6]),
    end: Number.parseInt(tokens[7]),
    //genoLeft: tokens[8],
    strand: tokens[9],
    repName: tokens[10],
    repClass: tokens[11],
    repFamily: tokens[12],
    repStart: Number.parseInt(tokens[13]),
    repEnd: Number.parseInt(tokens[14]),
    repLeft: Number.parseInt(tokens[15])
  };

  return feature;

}

/**
* Decode a UCSC "genePred" record.
*
* @param tokens
* @param ignore
* @returns {*}
*/
function decodeGenePred(tokens, header) {

  var shift = header.shift === undefined ? 0 : 1;

  if (tokens.length <= 9 + shift) return undefined;

  const cdStart = parseInt(tokens[5 + shift]);
  const cdEnd = parseInt(tokens[6 + shift]);
  var feature = {
    name: tokens[0 + shift],
    chr: tokens[1 + shift],
    strand: tokens[2 + shift],
    start: parseInt(tokens[3 + shift]),
    end: parseInt(tokens[4 + shift]),
    cdStart: cdStart,
    cdEnd: cdEnd,
    id: tokens[0 + shift]
  },
    exonCount = parseInt(tokens[7 + shift]),
    exonStarts = tokens[8 + shift].split(','),
    exonEnds = tokens[9 + shift].split(','),
    exons = [];

  for (let i = 0; i < exonCount; i++) {
    const start = parseInt(exonStarts[i]);
    const end = parseInt(exonEnds[i]);
    exons.push({ start: start, end: end });
  }
  findUTRs(exons, cdStart, cdEnd);

  feature.exons = exons;

  return feature;

}

/**
* Decode a UCSC "genePredExt" record.  refGene files are in this format.
*
* @param tokens
* @param ignore
* @returns {*}
*/
function decodeGenePredExt(tokens, header) {

  var shift = header.shift === undefined ? 0 : 1;

  if (tokens.length <= 11 + shift) return undefined;

  const cdStart = parseInt(tokens[5 + shift]);
  const cdEnd = parseInt(tokens[6 + shift]);
  const feature = {
    name: tokens[11 + shift],
    chr: tokens[1 + shift],
    strand: tokens[2 + shift],
    start: parseInt(tokens[3 + shift]),
    end: parseInt(tokens[4 + shift]),
    cdStart: cdStart,
    cdEnd: cdEnd,
    id: tokens[0 + shift]
  },
    exonCount = parseInt(tokens[7 + shift]),
    exonStarts = tokens[8 + shift].split(','),
    exonEnds = tokens[9 + shift].split(','),
    exons = [];

  for (let i = 0; i < exonCount; i++) {
    const start = parseInt(exonStarts[i]);
    const end = parseInt(exonEnds[i]);
    exons.push({ start: start, end: end });
  }
  findUTRs(exons, cdStart, cdEnd);

  feature.exons = exons;

  return feature;
}

/**
* Decode a UCSC "refFlat" record
* @param tokens
* @param ignore
* @returns {*}
*/
function decodeReflat(tokens, header) {

  var shift = header.shift === undefined ? 0 : 1;

  if (tokens.length <= 10 + shift) return undefined;

  const cdStart = parseInt(tokens[6 + shift]);
  const cdEnd = parseInt(tokens[7 + shift]);
  var feature = {
    name: tokens[0 + shift],
    id: tokens[1 + shift],
    chr: tokens[2 + shift],
    strand: tokens[3 + shift],
    start: parseInt(tokens[4 + shift]),
    end: parseInt(tokens[5 + shift]),
    cdStart: cdStart,
    cdEnd: cdEnd
  },
    exonCount = parseInt(tokens[8 + shift]),
    exonStarts = tokens[9 + shift].split(','),
    exonEnds = tokens[10 + shift].split(','),
    exons = [];

  for (let i = 0; i < exonCount; i++) {
    const start = parseInt(exonStarts[i]);
    const end = parseInt(exonEnds[i]);
    exons.push({ start: start, end: end });
  }
  findUTRs(exons, cdStart, cdEnd);

  feature.exons = exons;

  return feature;
}

function findUTRs(exons, cdStart, cdEnd) {

  for (let exon of exons) {
    const end = exon.end;
    const start = exon.start;
    if (end < cdStart || start > cdEnd) {
      exon.utr = true;
    } else {
      if (cdStart >= start && cdStart <= end) {
        exon.cdStart = cdStart;
      }
      if (cdEnd >= start && cdEnd <= end) {
        exon.cdEnd = cdEnd;
      }
    }
  }

}

function decodePeak(tokens, header) {

  var tokenCount, chr, start, end, strand, name, score, qValue, signal, pValue;

  tokenCount = tokens.length;
  if (tokenCount < 9) {
    return undefined;
  }

  chr = tokens[0];
  start = parseInt(tokens[1]);
  end = parseInt(tokens[2]);
  name = tokens[3];
  score = parseFloat(tokens[4]);
  strand = tokens[5].trim();
  signal = parseFloat(tokens[6]);
  pValue = parseFloat(tokens[7]);
  qValue = parseFloat(tokens[8]);

  if (score === 0) score = signal;

  return {
    chr: chr, start: start, end: end, name: name, score: score, strand: strand, signal: signal,
    pValue: pValue, qValue: qValue
  };
}

function decodeBedGraph(tokens, header) {

  var chr, start, end, value;

  if (tokens.length <= 3) return undefined;

  chr = tokens[0];
  start = parseInt(tokens[1]);
  end = parseInt(tokens[2]);
  value = parseFloat(tokens[3]);
  const feature = { chr: chr, start: start, end: end, value: value };

  // Optional extra columns
  if (header) {
    let colorColumn = header.colorColumn;
    if (colorColumn && colorColumn < tokens.length) {
      feature.color = IGVColor.createColorString(tokens[colorColumn]);
    }
  }

  return feature;
}

function decodeWig(tokens, header) {

  const wig = header.wig;

  if (wig && wig.format === "fixedStep") {
    const ss = (wig.index * wig.step) + wig.start;
    const ee = ss + wig.span;
    const value = parseFloat(tokens[0]);
    ++(wig.index);
    return isNaN(value) ? null : { chr: wig.chrom, start: ss, end: ee, value: value };
  } else if (wig && wig.format === "variableStep") {

    if (tokens.length < 2) return null;
    const ss = parseInt(tokens[0], 10) - 1;
    const ee = ss + wig.span;
    const value = parseFloat(tokens[1]);
    return isNaN(value) ? null : { chr: wig.chrom, start: ss, end: ee, value: value };

  } else {
    return decodeBedGraph(tokens);
  }
}

function decodeSNP(tokens, header) {

  if (tokens.length < 6) return undefined;

  const autoSql = [
    'bin',
    'chr',
    'start',
    'end',
    'name',
    'score',
    'strand',
    'refNCBI',
    'refUCSC',
    'observed',
    'molType',
    'class',
    'valid',
    'avHet',
    'avHetSE',
    'func',
    'locType',
    'weight',
    'exceptions',
    'submitterCount',
    'submitters',
    'alleleFreqCount',
    'alleles',
    'alleleNs',
    'alleleFreqs',
    'bitfields'
  ];


  const feature = {
    chr: tokens[1],
    start: Number.parseInt(tokens[2]),
    end: Number.parseInt(tokens[3]),
    name: tokens[4],
    score: Number.parseInt(tokens[5])
  };

  const n = Math.min(tokens.length, autoSql.length);
  for (let i = 6; i < n; i++) {
    feature[autoSql[i]] = tokens[i];
  }
  return feature;

}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/


/**
*  Parser for column style (tab delimited, etc) text file formats (bed, gff, vcf, etc).
*
*
*/


/**
* Return a parser for the given file format.
*/
class FeatureParser {

  constructor(config) {

    this.config = config;
    this.header = {};
    if (config.nameField) {
      this.header.nameField = config.nameField;
    }

    this.skipRows = 0;   // The number of fixed header rows to skip.  Override for specific types as needed

    if (config.decode) {
      this.decode = config.decode;
      this.delimiter = config.delimiter || "\t";
    } else if (config.format) {
      this.header.format = config.format.toLowerCase();
      this.setDecoder(this.header.format);
    }

    if (!this.delimiter) {
      this.delimiter = "\t";
    }
  }

  /**
   * Parse metadata from the file.   A variety of conventions are in use to supply metadata about file contents
   * through header lines (e.g. 'track') and # directives. This method unifies metadata as properties of a
   * 'header' object.
   *
   * @param data
   * @returns {{}}
   */
  async parseHeader(dataWrapper) {

    let header = this.header;
    let columnNames;
    let line;
    while ((line = await dataWrapper.nextLine()) !== undefined) {
      if (line.startsWith("track") || line.startsWith("#track")) {
        let h = parseTrackLine(line);
        Object.assign(header, h);
      } else if (line.startsWith("browser")); else if (line.startsWith("#columns")) {
        let h = parseColumnsDirective(line);
        Object.assign(header, h);
      } else if (line.startsWith("##gff-version 3")) {
        header.format = "gff3";
      } else if (line.startsWith("#gffTags")) {
        header.gffTags = true;
      } else if (line.startsWith("fixedStep") || line.startsWith("variableStep")) {
        // Wig directives -- we are in the data section
        break;
      } else if (line.startsWith("#")) {
        const tokens = line.split(this.delimiter || "\t");
        if (tokens.length > 1) {
          columnNames = tokens;   // Possible column names
        }
      } else {
        // All directives that could change the format, and thus decoder, should have been read by now.
        this.setDecoder(header.format);

        // If the line can be parsed as a feature assume we are beyond the header, if any
        try {
          const tokens = line.split(this.delimiter || "\t");
          const tmpHeader = Object.assign({ columnNames }, header);
          if (this.decode(tokens, tmpHeader)) {
            break;
          } else {
            if (tokens.length > 1) {
              columnNames = tokens; // possible column names
            }
          }
        } catch (e) {
          // Not a feature
        }
      }
    }

    if (columnNames) {
      header.columnNames = columnNames;
      for (let n = 0; n < columnNames.length; n++) {
        if (columnNames[n] === "color" || columnNames[n] === "colour") {
          header.colorColumn = n;
        } else if (columnNames[n] === "thickness") {
          header.thicknessColumn = n;
        }
      }
    }

    this.header = header;    // Directives might be needed for parsing lines
    return header;
  }

  async parseFeatures(dataWrapper) {

    const allFeatures = [];
    const decode = this.decode;
    const format = this.header.format;
    const delimiter = this.delimiter || "\t";
    let i = 0;
    let line;
    while ((line = await dataWrapper.nextLine()) !== undefined) {
      i++;
      if (i <= this.skipRows) continue;

      if (!line || line.startsWith("track") || line.startsWith("#") || line.startsWith("browser")) {
        continue;
      } else if (format === "wig" && line.startsWith("fixedStep")) {
        this.header.wig = parseFixedStep(line);
        continue;
      } else if (format === "wig" && line.startsWith("variableStep")) {
        this.header.wig = parseVariableStep(line);
        continue;
      }

      const tokens = line.split(delimiter);
      if (tokens.length < 1) {
        continue;
      }

      const feature = decode(tokens, this.header);
      if (feature) {
        allFeatures.push(feature);
      }
    }

    // Special hack for bedPE
    if (decode === decodeBedpe) {
      fixBedPE(allFeatures);
    }

    return allFeatures;

  }

  setDecoder(format) {

    switch (format) {
      case "narrowpeak":
      case "broadpeak":
      case "regionpeak":
      case "peaks":
        this.decode = decodePeak;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "bedgraph":
        this.decode = decodeBedGraph;
        this.delimiter = /\s+/;
        break;
      case "wig":
        this.decode = decodeWig;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "gff3":
      case "gff":
      case "gtf":
        this.decode = decodeGFF;
        this.delimiter = "\t";
        break;
      case "fusionjuncspan":
        // bhaas, needed for FusionInspector view
        this.decode = decodeFusionJuncSpan;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "gtexgwas":
        this.skipRows = 1;
        this.decode = decodeGtexGWAS;
        this.delimiter = "\t";
        break;
      case "refflat":
        this.decode = decodeReflat;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "genepred":
        this.decode = decodeGenePred;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "genepredext":
        this.decode = decodeGenePredExt;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "ensgene":
        this.decode = decodeGenePred;
        this.header.shift = 1;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "refgene":
        this.decode = decodeGenePredExt;
        this.delimiter = this.config.delimiter || /\s+/;
        this.header.shift = 1;
        break;
      case "bed":
        this.decode = decodeBed;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "bedpe":
        this.decode = decodeBedpe;
        this.delimiter = this.config.delimiter || "\t";
        break;
      case "bedpe-domain":
        this.decode = decodeBedpeDomain;
        this.headerLine = true;
        this.delimiter = this.config.delimiter || "\t";
        break;
      case "bedpe-loop":
        this.decode = decodeBedpe;
        this.delimiter = this.config.delimiter || "\t";
        this.header = { colorColumn: 7 };
        break;
      case "interact":
        this.decode = decodeInteract;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "snp":
        this.decode = decodeSNP;
        this.delimiter = "\t";
        break;
      case "rmsk":
        this.decode = decodeRepeatMasker;
        this.delimiter = "\t";
        break;
      case "gcnv":
        this.decode = decodeGcnv;
        this.delimiter = "\t";
        break;
      default:
        const customFormat = getFormat(format);
        if (customFormat !== undefined) {
          this.decode = decodeCustom;
          this.header.customFormat = customFormat;
          this.delimiter = customFormat.delimiter || "\t";
        } else {
          this.decode = decodeBed;
          this.delimiter = this.config.delimiter || /\s+/;
        }
    }

  }
}

function parseTrackLine(line) {

  const properties = {};
  const tokens = line.split(/(?:")([^"]+)(?:")|([^\s"]+)(?=\s+|$)/g);

  // Clean up tokens array
  let curr;
  const tmp = [];
  for (let tk of tokens) {
    if (!tk || tk.trim().length === 0) continue;
    if (tk.endsWith("=")) {
      curr = tk;
    } else if (curr) {
      tmp.push(curr + tk);
      curr = undefined;
    } else {
      tmp.push(tk);
    }
  }

  for (let str of tmp) {
    if (!str) return;
    var kv = str.split('=', 2);
    if (kv.length === 2) {
      const key = kv[0].trim();
      const value = kv[1].trim();
      if (properties.hasOwnProperty(key)) {
        let currentValue = properties[key];
        if (Array.isArray(currentValue)) {
          currentValue.push(value);
        } else {
          properties[key] = [currentValue, value];
        }
      } else {
        properties[key] = value;
      }
    }
  }
  if ("interact" == properties["type"]) {
    properties["format"] = "interact";
  } else if ("gcnv" === properties["type"]) {
    properties["format"] = "gcnv";
  }
  return properties;
}

function parseColumnsDirective(line) {

  let properties = {};
  let t1 = line.split(/\s+/);

  if (t1.length === 2) {
    let t2 = t1[1].split(";");
    t2.forEach(function (keyValue) {
      let t = keyValue.split("=");
      if (t[0] === "color") {
        properties.colorColumn = Number.parseInt(t[1]) - 1;
      } else if (t[0] === "thickness") {
        properties.thicknessColumn = Number.parseInt(t[1]) - 1;
      }
    });
  }

  return properties;
}

function parseFixedStep(line) {
  const tokens = line.split(/\s+/);
  const chrom = tokens[1].split("=")[1];
  const start = parseInt(tokens[2].split("=")[1], 10) - 1;
  const step = parseInt(tokens[3].split("=")[1], 10);
  const span = (tokens.length > 4) ? parseInt(tokens[4].split("=")[1], 10) : 1;
  return { format: "fixedStep", chrom, start, step, span, index: 0 };
}

function parseVariableStep(line) {
  const tokens = line.split(/\s+/);
  const chrom = tokens[1].split("=")[1];
  const span = tokens.length > 2 ? parseInt(tokens[2].split("=")[1], 10) : 1;
  return { format: "variableStep", chrom, span }
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2018 Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

/**
* A collection of properties and methods shared by all (or most) track types.
*
* @param config
* @param browser
* @constructor
*/
class TrackBase {

  constructor(config, browser) {

    if (config.displayMode) {
      config.displayMode = config.displayMode.toUpperCase();
    }

    this.config = config;
    this.browser = browser;
    this.url = config.url;
    this.type = config.type;
    this.description = config.description;
    this.supportHiDPI = config.supportHiDPI === undefined ? true : config.supportHiDPI;

    if (config.name || config.label) {
      this.name = config.name || config.label;
    } else {
      if (isFile(config.url)) this.name = config.url.name;
      else this.name = config.url;
    }
    this.id = this.config.id === undefined ? this.name : this.config.id;

    this.order = config.order;

    this.color = config.color;
    this.altColor = config.altColor;
    if ("civic-ws" === config.sourceType) {    // Ugly proxy for specialized track type
      this.defaultColor = "rgb(155,20,20)";
    } else {
      this.defaultColor = "rgb(0,0,150)";
    }

    this.autoscaleGroup = config.autoscaleGroup;

    this.removable = config.removable === undefined ? true : config.removable;      // Defaults to true

    this.height = config.height || 100;
    this.autoHeight = config.autoHeight;
    this.minHeight = config.minHeight || Math.min(25, this.height);
    this.maxHeight = config.maxHeight || Math.max(1000, this.height);

    this.visibilityWindow = config.visibilityWindow;
  }

  /**
   * Default implementation -- update config with current values.
   * to create session object for bookmarking, sharing.  Updates the track "config" object to reflect the
   * current state.  Only simple properties (string, number, boolean) are updated.
   */
  getState() {

    // Create copy of config, minus transient properties (convention is name starts with '_')
    const state = {};
    for (let key of Object.keys(this.config)) {
      if (!key.startsWith("_")) {
        state[key] = this.config[key];
      }
    }

    // Update original config values with any changes
    for (let key of Object.keys(state)) {
      if (key.startsWith("_")) continue;   // transient property
      const value = this[key];
      if (value && (isSimpleType(value) || typeof value === "boolean")) {
        state[key] = value;
      }
    }

    if (this.color) state.color = this.color;
    if (this.altColor) state.altColor = this.altColor;

    // Flatten dataRange if present
    if (!this.autoscale && this.dataRange) {
      if (state.min !== undefined && state.min !== null) {
        state.min = this.dataRange.min;
      }
      if (state.max !== undefined && state.max !== null) {
        state.max = this.dataRange.max;
      }
    }

    // Check for non-json-if-yable properties.  Perhaps we should test what can be saved.
    for (let key of Object.keys(state)) {
      if (typeof state[key] === 'function') {
        throw Error(`Property '${key}' of track '${this.name} is a function. Functions cannot be saved in sessions.`);
      }
      if (state[key] instanceof File) {
        throw Error(`Property '${key}' of track '${this.name} is a local File. Local file references cannot be saved in sessions.`);
      }
      if (state[key] instanceof Promise) {
        throw Error(`Property '${key}' of track '${this.name} is a Promise. Promises cannot be saved in sessions.`);
      }
    }

    // Remove properties with undefined values, no reason to save these
    let keys = Object.keys(state);
    for (let key of keys) {
      if (state[key] === undefined) {
        delete state[key];
      }
    }

    return state;
  }

  supportsWholeGenome() {
    return false;
  }

  getGenomeId() {
    return this.browser.genome ? this.browser.genome.id : undefined
  }

  /**
   * Set certain track properties, usually from a "track" line.  Not all UCSC properties are supported.
   *
   * Track configuration settings have precendence over track line properties, so if both are present ignore the
   * track line.
   *
   * @param properties
   */
  setTrackProperties(properties) {


    const tracklineConfg = {};
    let tokens;
    for (let key of Object.keys(properties)) {
      switch (key.toLowerCase()) {
        case "usescore":
          tracklineConfg.useScore = (
            properties[key] === 1 || properties[key] === "1" || properties[key] === "on" || properties[key] === true);
          break;
        case "visibility":
          //0 - hide, 1 - dense, 2 - full, 3 - pack, and 4 - squish
          switch (properties[key]) {
            case "2":
            case "3":
            case "pack":
            case "full":
              tracklineConfg.displayMode = "EXPANDED";
              break;
            case "4":
            case "squish":
              tracklineConfg.displayMode = "SQUISHED";
              break;
            case "1":
            case "dense":
              tracklineConfg.displayMode = "COLLAPSED";
          }
          break;
        case "color":
        case "altcolor":
          tracklineConfg[key] = properties[key].startsWith("rgb(") ? properties[key] : "rgb(" + properties[key] + ")";
          break;
        case "featurevisiblitywindow":
        case "visibilitywindow":
          tracklineConfg.visibilityWindow = Number.parseInt(properties[key]);
          break;
        case "maxheightpixels":
          tokens = properties[key].split(":");
          if (tokens.length === 3) {
            tracklineConfg.minHeight = Number.parseInt(tokens[2]);
            tracklineConfg.height = Number.parseInt(tokens[1]);
            tracklineConfg.maxHeight = Number.parseInt(tokens[0]);
          }
          break;
        case "viewlimits":
          if (!this.config.autoscale) {   // autoscale in the config has precedence
            tokens = properties[key].split(":");
            let min = 0;
            let max;
            if (tokens.length == 1) {
              max = Number.parseFloat(tokens[0]);
            } else if (tokens.length == 2) {
              min = Number.parseFloat(tokens[0]);
              max = Number.parseFloat(tokens[1]);
            }
            tracklineConfg.autoscale = false;
            tracklineConfg.dataRange = { min, max };
          }
        case "name":
          tracklineConfg[key] = properties[key];
      }
    }

    // Track configuration objects have precendence over track line properties
    for (let key of Object.keys(tracklineConfg)) {
      if (!this.config.hasOwnProperty(key)) {
        this[key] = tracklineConfg[key];
      }
    }
  }

  getVisibilityWindow() {
    return this.visibilityWindow;
  }

  clickedFeatures(clickState) {

    // We use the cached features rather than method to avoid async load.  If the
    // feature is not already loaded this won't work,  but the user wouldn't be mousing over it either.
    const features = clickState.viewport.getCachedFeatures();

    if (!features || features.length === 0) {
      return [];
    }

    const genomicLocation = clickState.genomicLocation;

    // When zoomed out we need some tolerance around genomicLocation
    const tolerance = (clickState.referenceFrame.bpPerPixel > 0.2) ? 3 * clickState.referenceFrame.bpPerPixel : 0;
    const ss = Math.floor(genomicLocation) - tolerance;
    const ee = Math.floor(genomicLocation) + tolerance;
    return (FeatureUtils.findOverlapping(features, ss, ee));
  }

  /**
   * Default popup text function -- just extracts string and number properties in random order.
   * @param feature
   * @returns {Array}
   */
  static extractPopupData(feature, genomeId) {

    const filteredProperties = new Set(['row', 'color', 'chr', 'start', 'end', 'cdStart', 'cdEnd', 'strand', 'alpha']);
    const data = [];

    let alleles, alleleFreqs;
    for (var property in feature) {

      if (feature.hasOwnProperty(property) &&
        !filteredProperties.has(property) &&
        isSimpleType(feature[property])) {
        let value = feature[property];
        data.push({ name: capitalize(property), value: value });

        if (property === "alleles") {
          alleles = feature[property];
        } else if (property === "alleleFreqs") {
          alleleFreqs = feature[property];
        }
      }
    }

    //const genomeId = this.getGenomeId()
    if (alleles && alleleFreqs) {

      if (alleles.endsWith(",")) {
        alleles = alleles.substr(0, alleles.length - 1);
      }
      if (alleleFreqs.endsWith(",")) {
        alleleFreqs = alleleFreqs.substr(0, alleleFreqs.length - 1);
      }

      let a = alleles.split(",");
      let af = alleleFreqs.split(",");
      if (af.length > 1) {
        let b = [];
        for (let i = 0; i < af.length; i++) {
          b.push({ a: a[i], af: Number.parseFloat(af[i]) });
        }
        b.sort(function (x, y) {
          return x.af - y.af
        });

        let ref = b[b.length - 1].a;
        if (ref.length === 1) {
          for (let i = b.length - 2; i >= 0; i--) {
            let alt = b[i].a;
            if (alt.length === 1) {
              const cravatLink = TrackBase.getCravatLink(feature.chr, feature.start + 1, ref, alt, genomeId);
              if (cravatLink) {
                data.push("<hr/>");
                data.push(cravatLink);
              }
            }
          }
        }
      }
    }

    if (feature.attributes) {
      for (let key of Object.keys(feature.attributes)) {
        data.push({ name: key, value: feature.attributes[key] });
      }
    }

    // final chr position
    let posString = `${feature.chr}:${numberFormatter(feature.start + 1)}-${numberFormatter(feature.end)}`;
    if (feature.strand) {
      posString += ` (${feature.strand})`;
    }
    data.push('<hr\>');
    data.push(posString);

    return data;

  }

  static getCravatLink(chr, position, ref, alt, genomeID) {

    if ("hg38" === genomeID || "GRCh38" === genomeID) {

      const cravatChr = chr.startsWith("chr") ? chr : "chr" + chr;
      return `<a target="_blank" href="https://run.opencravat.org/result/nocache/variant.html` +
        `?chrom=${cravatChr}&pos=${position}&ref_base=${ref}&alt_base=${alt}">Cravat ${ref}->${alt}</a>`
      // return "<a target='_blank' " +
      //     "href='https://www.cravat.us/CRAVAT/variant.html?variant=" +
      //     cravatChr + "_" + position + "_+_" + ref + "_" + alt + "'>Cravat " + ref + "->" + alt + "</a>"
    } else {
      return undefined
    }
  }
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/


const knownAltBases = new Set(["A", "C", "T", "G"].map(c => c.charCodeAt(0)));

function createVCFVariant(tokens) {
  return new Variant(tokens);
}


class Variant {

  constructor(tokens) {
    this.chr = tokens[0]; // TODO -- use genome aliases
    this.pos = parseInt(tokens[1]);
    this.names = tokens[2];    // id in VCF
    this.referenceBases = tokens[3];
    this.alternateBases = tokens[4];
    this.quality = tokens[5];
    this.filter = tokens[6];
    this.info = getInfoObject(tokens[7]);
    this.init();
  }

  init() {

    const ref = this.referenceBases;
    const altBases = this.alternateBases;

    if (this.info) {
      if (this.info["VT"]) {
        this.type = this.info["VT"];
      } else if (this.info["SVTYPE"]) {
        this.type = "SV";
      } else if (this.info["PERIOD"]) {
        this.type = "STR";
      }
    }
    if (this.type === undefined) {
      this.type = determineType(ref, altBases);
    }
    if (this.type === "NONVARIANT") {
      this.heterozygosity = 0;
    }

    // Determine start/end coordinates -- these are the coordinates representing the actual variant,
    // not the leading or trailing reference
    if (this.info["END"]) {
      this.start = this.pos - 1;
      if (this.info["CHR2"] && this.info["CHR2"] !== this.chr) {
        this.end = this.start + 1;
      } else {
        this.end = Number.parseInt(this.info["END"]);
      }
    } else {
      if (this.type === "NONVARIANT") {
        this.start = this.pos - 1;      // convert to 0-based coordinate convention
        this.end = this.start + ref.length;
      } else {

        const altTokens = altBases.split(",").filter(token => token.length > 0);
        this.alleles = [];
        this.start = undefined;
        this.end = undefined;

        for (let alt of altTokens) {

          this.alleles.push(alt);

          // We don't yet handle  SV and other special alt representations
          if ("SV" !== this.type && isKnownAlt(alt)) {

            let altLength = alt.length;
            let lengthOnRef = ref.length;

            // Trim off matching bases.  Try first match, then right -> left,  then any remaining left -> right
            let s = 0;
            if (ref.charCodeAt(0) === alt.charCodeAt(0)) {
              s++;
              altLength--;
              lengthOnRef--;
            }

            // right -> left from end
            while (altLength > 0 && lengthOnRef > 0) {
              const altIdx = s + altLength - 1;
              const refIdx = s + lengthOnRef - 1;
              if (alt.charCodeAt(altIdx) === ref.charCodeAt(refIdx)) {
                altLength--;
                lengthOnRef--;
              } else {
                break;
              }
            }

            // if any remaining, left -> right
            while (altLength > 0 && lengthOnRef > 0) {
              const altIdx = s;
              const refIdx = s;
              if (alt.charCodeAt(altIdx) === ref.charCodeAt(refIdx)) {
                s++;
                altLength--;
                lengthOnRef--;
              } else {
                break;
              }
            }

            const alleleStart = this.pos + s - 1;      // -1 for zero based coordinates
            const alleleEnd = alleleStart + lengthOnRef;    // insertions have zero length on ref, but we give them 1
            this.start = this.start === undefined ? alleleStart : Math.min(this.start, alleleStart);
            this.end = this.end === undefined ? alleleEnd : Math.max(this.end, alleleEnd);
          }
        }

        // Default to single base representation @ position for variant types not otherwise handled
        if (this.start === undefined) {
          this.start = this.pos - 1;
          this.end = this.pos;
        }
      }
    }
  }


  popupData(genomicLocation, genomeId) {

    var self = this,
      fields, gt;

    const posString = this.end === this.pos ? this.pos : `${this.pos}-${this.end}`;
    fields = [
      { name: "Chr", value: this.chr },
      { name: "Pos", value: posString },
      { name: "Names", value: this.names ? this.names : "" },
      { name: "Ref", value: this.referenceBases },
      { name: "Alt", value: this.alternateBases.replace("<", "&lt;") },
      { name: "Qual", value: this.quality },
      { name: "Filter", value: this.filter }
    ];

    if ("SNP" === this.type) {
      let ref = this.referenceBases;
      if (ref.length === 1) {
        let altArray = this.alternateBases.split(",");
        for (let alt of altArray) {
          if (alt.length === 1) {
            let l = TrackBase.getCravatLink(this.chr, this.pos, ref, alt, genomeId);
            if (l) {
              fields.push("<hr/>");
              fields.push(l);
            }
          }
        }
      }
    }

    if (this.hasOwnProperty("heterozygosity")) {
      fields.push({ name: "Heterozygosity", value: this.heterozygosity });
    }

    if (this.info) {
      fields.push('<hr>');
      Object.keys(this.info).forEach(function (key) {
        fields.push({ name: key, value: arrayToString(self.info[key]) });
      });
    }


    // Special case of VCF with a single sample
    if (this.calls && this.calls.length === 1) {
      fields.push('<hr>');
      gt = this.alleles[this.calls[0].genotype[0]] + this.alleles[this.calls[0].genotype[1]];
      fields.push({ name: "Genotype", value: gt });
    }


    return fields;


  };

  isRefBlock() {
    return "NONVARIANT" === this.type;
  }

}

function getInfoObject(infoStr) {
  var info = {};
  if (infoStr) {
    infoStr.split(';').forEach(function (elem) {
      var element = elem.split('=');
      info[element[0]] = element[1];
    });
  }
  return info;
}


function isKnownAlt(alt) {
  for (let i = 0; i < alt.length; i++) {
    if (!knownAltBases.has(alt.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}


function determineType(ref, altAlleles) {
  const refLength = ref.length;
  if (altAlleles === undefined) {
    return "UNKNOWN";
  } else if (altAlleles.trim().length === 0 ||
    altAlleles === "<NON_REF>" ||
    altAlleles === "<*>" ||
    altAlleles === ".") {
    return "NONVARIANT";
  } else {
    const alleles = altAlleles.split(",");
    const types = alleles.map(function (a) {
      if (refLength === 1 && a.length === 1) {
        return "SNP";
      } else {
        return "<NON_REF>" === a ? "NONVARIANT" : "OTHER";
      }
    });
    let type = types[0];
    for (let t of types) {
      if (t !== type) {
        return "MIXED";
      }
    }
    return type;
  }
}

function arrayToString(value, delim) {

  if (delim === undefined) delim = ",";

  if (!(Array.isArray(value))) {
    return value;
  }
  return value.join(delim);
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

/**
* Parser for VCF files.
*/

class VcfParser {

  construtor() {
  }

  async parseHeader(dataWrapper) {

    const header = {};

    // First line must be file format
    let line = await dataWrapper.nextLine();
    if (line.startsWith("##fileformat")) {
      header.version = line.substr(13);
    } else {
      throw new Error("Invalid VCF file: missing fileformat line");
    }

    while ((line = await dataWrapper.nextLine()) !== undefined) {

      if (line.startsWith("#")) {

        let id;
        const values = {};

        if (line.startsWith("##")) {

          if (line.startsWith("##INFO") || line.startsWith("##FILTER") || line.startsWith("##FORMAT")) {

            const ltIdx = line.indexOf("<");
            const gtIdx = line.lastIndexOf(">");

            if (!(ltIdx > 2 && gtIdx > 0)) {
              console.log("Malformed VCF header line: " + line);
              continue;
            }

            const type = line.substring(2, ltIdx - 1);
            if (!header[type]) header[type] = {};

            //##INFO=<ID=AF,Number=A,Type=Float,Description="Allele frequency based on Flow Evaluator observation counts">
            // ##FILTER=<ID=NOCALL,Description="Generic filter. Filtering details stored in FR info tag.">
            // ##FORMAT=<ID=AF,Number=A,Type=Float,Description="Allele frequency based on Flow Evaluator observation counts">

            const tokens = splitStringRespectingQuotes(line.substring(ltIdx + 1, gtIdx - 1), ",");

            for (let token of tokens) {
              var kv = token.split("=");
              if (kv.length > 1) {
                if (kv[0] === "ID") {
                  id = kv[1];
                } else {
                  values[kv[0]] = kv[1];
                }
              }
            }

            if (id) {
              header[type][id] = values;
            }
          }
        } else if (line.startsWith("#CHROM")) {
          const tokens = line.split("\t");

          if (tokens.length > 8) {

            // call set names -- use column index for id
            header.callSets = [];
            for (let j = 9; j < tokens.length; j++) {
              header.callSets.push({ id: j, name: tokens[j] });
            }
          }
        }

      } else {
        break;
      }

    }

    this.header = header;  // Will need to intrepret genotypes and info field

    return header;
  }


  /**
   * Parse data as a collection of Variant objects.
   *
   * @param data
   * @returns {Array}
   */
  async parseFeatures(dataWrapper) {

    const allFeatures = [];
    const callSets = this.header.callSets;
    const nExpectedColumns = 8 + (callSets ? callSets.length + 1 : 0);
    let line;
    while ((line = await dataWrapper.nextLine()) !== undefined) {

      if (line && !line.startsWith("#")) {
        const tokens = line.split("\t");
        if (tokens.length === nExpectedColumns) {
          const variant = createVCFVariant(tokens);
          variant.header = this.header;       // Keep a pointer to the header to interpret fields for popup text
          allFeatures.push(variant);

          if (tokens.length > 9) {

            // Format
            const callFields = extractCallFields(tokens[8].split(":"));

            variant.calls = {};
            for (let index = 9; index < tokens.length; index++) {

              const token = tokens[index];

              var callSet = callSets[index - 9],
                call = {
                  callSetName: callSet.name,
                  info: {}
                };

              variant.calls[callSet.id] = call;

              token.split(":").forEach(function (callToken, idx) {

                switch (idx) {
                  case callFields.genotypeIndex:
                    call.genotype = [];
                    callToken.split(/[\|\/]/).forEach(function (s) {
                      call.genotype.push('.' === s ? s : parseInt(s));
                    });
                    break;

                  default:
                    call.info[callFields.fields[idx]] = callToken;
                }
              });
            }
          }
        }
      }
    }

    return allFeatures;
  }
}

function extractCallFields(tokens) {

  const callFields = {
    genotypeIndex: -1,
    fields: tokens
  };
  for (let i = 0; i < tokens.length; i++) {
    if ("GT" === tokens[i]) {
      callFields.genotypeIndex = i;
    }
  }
  return callFields;
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/


// TODO -- big endian?

class BinaryParser$1 {
  constructor(dataView, littleEndian) {

    this.littleEndian = littleEndian !== undefined ? littleEndian : true;
    this.position = 0;
    this.view = dataView;
    this.length = dataView.byteLength;
  }

  available() {
    return this.length - this.position;
  }

  remLength() {
    return this.length - this.position;
  }

  hasNext() {
    return this.position < this.length - 1;
  }

  getByte() {
    var retValue = this.view.getUint8(this.position, this.littleEndian);
    this.position++;
    return retValue;
  }

  getShort() {

    var retValue = this.view.getInt16(this.position, this.littleEndian);
    this.position += 2;
    return retValue;
  }

  getUShort() {

    // var byte1 = this.getByte(),
    //     byte2 = this.getByte(),
    //     retValue = ((byte2 << 24 >>> 16) + (byte1 << 24 >>> 24));
    //     return retValue;

    //
    var retValue = this.view.getUint16(this.position, this.littleEndian);
    this.position += 2;
    return retValue;
  }


  getInt() {

    var retValue = this.view.getInt32(this.position, this.littleEndian);
    this.position += 4;
    return retValue;
  }


  getUInt() {
    var retValue = this.view.getUint32(this.position, this.littleEndian);
    this.position += 4;
    return retValue;
  }

  getLong() {

    // DataView doesn't support long. So we'll try manually

    var b = [];
    b[0] = this.view.getUint8(this.position);
    b[1] = this.view.getUint8(this.position + 1);
    b[2] = this.view.getUint8(this.position + 2);
    b[3] = this.view.getUint8(this.position + 3);
    b[4] = this.view.getUint8(this.position + 4);
    b[5] = this.view.getUint8(this.position + 5);
    b[6] = this.view.getUint8(this.position + 6);
    b[7] = this.view.getUint8(this.position + 7);

    var value = 0;
    if (this.littleEndian) {
      for (let i = b.length - 1; i >= 0; i--) {
        value = (value * 256) + b[i];
      }
    } else {
      for (let i = 0; i < b.length; i++) {
        value = (value * 256) + b[i];
      }
    }


    this.position += 8;
    return value;
  }

  getString(len) {

    var s = "";
    var c;
    while ((c = this.view.getUint8(this.position++)) !== 0) {
      s += String.fromCharCode(c);
      if (len && s.length === len) break;
    }
    return s;
  }

  getFixedLengthString(len) {

    var s = "";
    var i;
    var c;
    for (i = 0; i < len; i++) {
      c = this.view.getUint8(this.position++);
      if (c > 0) {
        s += String.fromCharCode(c);
      }
    }
    return s;
  }

  getFixedLengthTrimmedString(len) {

    var s = "";
    var i;
    var c;
    for (i = 0; i < len; i++) {
      c = this.view.getUint8(this.position++);
      if (c > 32) {
        s += String.fromCharCode(c);
      }
    }
    return s;
  }

  getFloat() {

    var retValue = this.view.getFloat32(this.position, this.littleEndian);
    this.position += 4;
    return retValue;


  }

  getDouble() {

    var retValue = this.view.getFloat64(this.position, this.littleEndian);
    this.position += 8;
    return retValue;
  }

  skip(n) {

    this.position += n;
    return this.position;
  }


  /**
   * Return a BGZip (bam and tabix) virtual pointer
   * TODO -- why isn't 8th byte used ?
   * @returns {*}
   */
  getVPointer() {

    var position = this.position,
      offset = (this.view.getUint8(position + 1) << 8) | (this.view.getUint8(position)),
      byte6 = ((this.view.getUint8(position + 6) & 0xff) * 0x100000000),
      byte5 = ((this.view.getUint8(position + 5) & 0xff) * 0x1000000),
      byte4 = ((this.view.getUint8(position + 4) & 0xff) * 0x10000),
      byte3 = ((this.view.getUint8(position + 3) & 0xff) * 0x100),
      byte2 = ((this.view.getUint8(position + 2) & 0xff)),
      block = byte6 + byte5 + byte4 + byte3 + byte2;
    this.position += 8;

    //       if (block == 0 && offset == 0) {
    //           return null;
    //       } else {
    return new VPointer$1(block, offset);
    //       }
  }
}

class VPointer$1 {
  constructor(block, offset) {
    this.block = block;
    this.offset = offset;
  }

  isLessThan(vp) {
    return this.block < vp.block ||
      (this.block === vp.block && this.offset < vp.offset);
  }

  isGreaterThan(vp) {
    return this.block > vp.block ||
      (this.block === vp.block && this.offset > vp.offset);
  }

  print() {
    return "" + this.block + ":" + this.offset;
  }
}

// Represents a BAM index.

const CSI1_MAGIC$1 = 21582659; // CSI\1
const CSI2_MAGIC$1 = 38359875; // CSI\2

async function parseCsiIndex(arrayBuffer, genome) {

  const idx = new CSIIndex();
  idx.parse(arrayBuffer, genome);
  return idx;
}

class CSIIndex {

  constructor(tabix) {
    this.tabix = true;   // Means whatever is indexed is BGZipped
  }

  parse(arrayBuffer, genome) {
    const parser = new BinaryParser$1(new DataView(arrayBuffer));

    const magic = parser.getInt();

    if (magic !== CSI1_MAGIC$1) {
      if (magic === CSI2_MAGIC$1) {
        throw Error("CSI version 2 is not supported.  Please enter an issue at https://github.com/igvteam/igv.js");
      } else {
        throw Error("Not a CSI index");
      }
    }

    this.indices = [];
    this.blockMin = Number.MAX_SAFE_INTEGER;
    this.blockMax = 0;
    this.sequenceIndexMap = {};

    this.minShift = parser.getInt();
    this.depth = parser.getInt();
    const lAux = parser.getInt();

    if (lAux >= 28) {
      // Tabix header parameters aren't used, but they must be read to advance the pointer
      parser.getInt();
      parser.getInt();
      parser.getInt();
      parser.getInt();
      parser.getInt();
      parser.getInt();
      const l_nm = parser.getInt();
      const nameEndPos = parser.position + l_nm;
      let i = 0;
      while (parser.position < nameEndPos) {
        let seq_name = parser.getString();
        // Translate to "official" chr name.
        if (genome) {
          seq_name = genome.getChromosomeName(seq_name);
        }
        this.sequenceIndexMap[seq_name] = i;
        i++;
      }
    }

    const MAX_BIN = this.bin_limit() + 1;
    const nref = parser.getInt();
    for (let ref = 0; ref < nref; ref++) {

      const binIndex = [];
      const loffset = [];
      const nbin = parser.getInt();
      for (let b = 0; b < nbin; b++) {

        const binNumber = parser.getInt();
        loffset[binNumber] = parser.getVPointer();

        if (binNumber > MAX_BIN) {
          // This is a psuedo bin, not used but we have to consume the bytes
          parser.getInt(); // # of chunks for this bin
          parser.getVPointer();   // unmapped beg
          parser.getVPointer();   // unmapped end
          parser.getLong();
          parser.getLong();

        } else {

          binIndex[binNumber] = [];
          const nchnk = parser.getInt(); // # of chunks for this bin

          for (let i = 0; i < nchnk; i++) {
            const cs = parser.getVPointer();    //chunk_beg
            const ce = parser.getVPointer();    //chunk_end
            if (cs && ce) {
              if (cs.block < this.blockMin) {
                this.blockMin = cs.block;    // Block containing first alignment
              }
              if (ce.block > this.blockMax) {
                this.blockMax = ce.block;
              }
              binIndex[binNumber].push([cs, ce]);
            }
          }
        }
      }

      if (nbin > 0) {
        this.indices[ref] = {
          binIndex: binIndex,
          loffset: loffset
        };
      }
    }
  }

  /**
   * Fetch blocks for a particular genomic range.  This method is public so it can be unit-tested.
   *
   * @param refId  the sequence dictionary index of the chromosome
   * @param min  genomic start position
   * @param max  genomic end position
   * @param return an array of {minv: {filePointer, offset}, {maxv: {filePointer, offset}}
   */
  blocksForRange(refId, min, max) {

    const ba = this.indices[refId];
    if (!ba) {
      return [];
    } else {
      const overlappingBins = this.reg2bins(min, max);        // List of bin #s that overlap min, max
      if (overlappingBins.length == 0) return [];

      const chunks = [];
      // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned
      for (let binRange of overlappingBins) {
        for (let bin = binRange[0]; bin <= binRange[1]; bin++) {
          if (ba.binIndex[bin]) {
            const binChunks = ba.binIndex[bin];
            const nchnk = binChunks.length;
            for (let c = 0; c < nchnk; ++c) {
              const cs = binChunks[c][0];
              const ce = binChunks[c][1];
              chunks.push({ minv: cs, maxv: ce, bin: bin });
            }
          }
        }
      }

      const lowestOffset = ba.loffset[overlappingBins[0]];

      return optimizeChunks$1(chunks, lowestOffset);
    }

  }

  // reg2bins implementation adapted from GMOD/tabix-js  https://github.com/GMOD/tabix-js/blob/master/src/csi.ts
  reg2bins(beg, end) {
    beg -= 1; // < convert to 1-based closed
    if (beg < 1) beg = 1;
    if (end > 2 ** 50) end = 2 ** 34; // 17 GiB ought to be enough for anybody
    end -= 1;
    let l = 0;
    let t = 0;
    let s = this.minShift + this.depth * 3;
    const bins = [];
    for (; l <= this.depth; s -= 3, t += (1 << l * 3), l += 1) {
      const b = t + (beg >> s);
      const e = t + (end >> s);
      if (e - b + bins.length > this.maxBinNumber)
        throw new Error(
          `query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`,
        )
      //for (let i = b; i <= e; i += 1) bins.push(i)
      bins.push([b, e]);
    }
    return bins
  }

  // function reg2bins(beg, end, min_shift, depth) {
  //     let l, t, n, s = min_shift + depth * 3;
  //     const bins = [];
  //     for (--end, l = n = t = 0; l <= depth; s -= 3, t += 1 << l * 3, ++l) {
  //         let b = t + (beg >> s), e = t + (end >> s), i;
  //         for (i = b; i <= e; ++i) bins[n++] = i;
  //     }
  //     return bins;
  // }

  bin_limit() {
    return ((1 << (this.depth + 1) * 3) - 1) / 7;
  }

}

function optimizeChunks$1(chunks, lowest) {

  const mergedChunks = [];
  let lastChunk = null;

  if (chunks.length === 0) return chunks;

  chunks.sort(function (c0, c1) {
    const dif = c0.minv.block - c1.minv.block;
    if (dif !== 0) {
      return dif;
    } else {
      return c0.minv.offset - c1.minv.offset;
    }
  });

  chunks.forEach(function (chunk) {

    if (!lowest || chunk.maxv.isGreaterThan(lowest)) {
      if (lastChunk === null) {
        mergedChunks.push(chunk);
        lastChunk = chunk;
      } else {
        if (canMerge$1(lastChunk, chunk)) {
          if (chunk.maxv.isGreaterThan(lastChunk.maxv)) {
            lastChunk.maxv = chunk.maxv;
          }
        } else {
          mergedChunks.push(chunk);
          lastChunk = chunk;
        }
      }
    } else {
      console.log(`skipping chunk ${chunk.minv.block} - ${chunk.maxv.block}`);
    }
  });

  return mergedChunks;
}

function canMerge$1(chunk1, chunk2) {
  return (chunk2.minv.block - chunk1.maxv.block) < 65000 &&
    (chunk2.maxv.block - chunk1.minv.block) < 5000000;
  // lastChunk.minv.block === lastChunk.maxv.block &&
  // lastChunk.maxv.block === chunk.minv.block &&
  // chunk.minv.block === chunk.maxv.block

}

// Represents a BAM index.

const BAI_MAGIC$1 = 21578050;
const TABIX_MAGIC$1 = 21578324;

async function parseBamIndex(arrayBuffer, genome) {
  return parseIndex(arrayBuffer, false, genome);
}

async function parseTabixIndex(arrayBuffer, genome) {
  return parseIndex(arrayBuffer, true, genome);
}

async function parseIndex(arrayBuffer, tabix, genome) {

  const indices = [];
  let blockMin = Number.MAX_SAFE_INTEGER;
  let blockMax = 0;


  const parser = new BinaryParser$1(new DataView(arrayBuffer));
  const magic = parser.getInt();
  const sequenceIndexMap = {};
  if (magic === BAI_MAGIC$1 || (tabix && magic === TABIX_MAGIC$1)) {

    const nref = parser.getInt();
    if (tabix) {
      // Tabix header parameters aren't used, but they must be read to advance the pointer
      parser.getInt();
      parser.getInt();
      parser.getInt();
      parser.getInt();
      parser.getInt();
      parser.getInt();
      parser.getInt();

      for (let i = 0; i < nref; i++) {
        let seq_name = parser.getString();
        // Translate to "official" chr name.
        if (genome) {
          seq_name = genome.getChromosomeName(seq_name);
        }
        sequenceIndexMap[seq_name] = i;
      }
    }


    for (let ref = 0; ref < nref; ref++) {

      const binIndex = {};
      const linearIndex = [];
      const nbin = parser.getInt();
      for (let b = 0; b < nbin; b++) {

        const binNumber = parser.getInt();

        if (binNumber === 37450) {
          // This is a psuedo bin, not used but we have to consume the bytes
          parser.getInt(); // # of chunks for this bin
          parser.getVPointer();   // unmapped beg
          parser.getVPointer();   // unmapped end
          parser.getLong();
          parser.getLong();

        } else {

          binIndex[binNumber] = [];
          const nchnk = parser.getInt(); // # of chunks for this bin

          for (let i = 0; i < nchnk; i++) {
            const cs = parser.getVPointer();    //chunk_beg
            const ce = parser.getVPointer();    //chunk_end
            if (cs && ce) {
              if (cs.block < blockMin) {
                blockMin = cs.block;    // Block containing first alignment
              }
              if (ce.block > blockMax) {
                blockMax = ce.block;
              }
              binIndex[binNumber].push([cs, ce]);
            }
          }
        }
      }

      const nintv = parser.getInt();
      for (let i = 0; i < nintv; i++) {
        const cs = parser.getVPointer();
        linearIndex.push(cs);   // Might be null
      }

      if (nbin > 0) {
        indices[ref] = {
          binIndex: binIndex,
          linearIndex: linearIndex
        };
      }
    }

  } else {
    throw new Error(indexURL + " is not a " + (tabix ? "tabix" : "bai") + " file");
  }

  return new BamIndex(indices, blockMin, blockMax, sequenceIndexMap, tabix);

}

class BamIndex {

  constructor(indices, blockMin, blockMax, sequenceIndexMap, tabix) {
    this.firstAlignmentBlock = blockMin;
    this.lastAlignmentBlock = blockMax;
    this.indices = indices;
    this.sequenceIndexMap = sequenceIndexMap;
    this.tabix = tabix;
  }

  /**
   * Fetch blocks for a particular genomic range.  This method is public so it can be unit-tested.
   *
   * @param refId  the sequence dictionary index of the chromosome
   * @param min  genomic start position
   * @param max  genomic end position
   * @param return an array of {minv: {filePointer, offset}, {maxv: {filePointer, offset}}
   */
  blocksForRange(refId, min, max) {

    const bam = this;
    const ba = bam.indices[refId];

    if (!ba) {
      return [];
    } else {
      const overlappingBins = reg2bins(min, max);        // List of bin #s that overlap min, max
      const chunks = [];

      // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned
      for (let binRange of overlappingBins) {
        for (let bin = binRange[0]; bin <= binRange[1]; bin++) {
          if (ba.binIndex[bin]) {
            const binChunks = ba.binIndex[bin],
              nchnk = binChunks.length;
            for (let c = 0; c < nchnk; ++c) {
              const cs = binChunks[c][0];
              const ce = binChunks[c][1];
              chunks.push({ minv: cs, maxv: ce, bin: bin });
            }
          }
        }
      }

      // Use the linear index to find minimum file position of chunks that could contain alignments in the region
      const nintv = ba.linearIndex.length;
      let lowest = null;
      const minLin = Math.min(min >> 14, nintv - 1);
      const maxLin = Math.min(max >> 14, nintv - 1);
      for (let i = minLin; i <= maxLin; ++i) {
        const vp = ba.linearIndex[i];
        if (vp) {
          // todo -- I think, but am not sure, that the values in the linear index have to be in increasing order.  So the first non-null should be minimum
          if (!lowest || vp.isLessThan(lowest)) {
            lowest = vp;
          }
        }
      }

      return optimizeChunks(chunks, lowest);
    }
  }
}

function optimizeChunks(chunks, lowest) {

  const mergedChunks = [];
  let lastChunk = null;

  if (chunks.length === 0) return chunks;

  chunks.sort(function (c0, c1) {
    const dif = c0.minv.block - c1.minv.block;
    if (dif !== 0) {
      return dif;
    } else {
      return c0.minv.offset - c1.minv.offset;
    }
  });

  chunks.forEach(function (chunk) {

    if (!lowest || chunk.maxv.isGreaterThan(lowest)) {
      if (lastChunk === null) {
        mergedChunks.push(chunk);
        lastChunk = chunk;
      } else {
        if (canMerge(lastChunk, chunk)) {
          if (chunk.maxv.isGreaterThan(lastChunk.maxv)) {
            lastChunk.maxv = chunk.maxv;
          }
        } else {
          mergedChunks.push(chunk);
          lastChunk = chunk;
        }
      }
    } else {
      console.log(`skipping chunk ${chunk.minv.block} - ${chunk.maxv.block}`);
    }
  });

  return mergedChunks;
}

function canMerge(chunk1, chunk2) {
  return (chunk2.minv.block - chunk1.maxv.block) < 65000 &&
    (chunk2.maxv.block - chunk1.minv.block) < 5000000;
  // lastChunk.minv.block === lastChunk.maxv.block &&
  // lastChunk.maxv.block === chunk.minv.block &&
  // chunk.minv.block === chunk.maxv.block

}

/**
* Calculate the list of bins that overlap with region [beg, end]
*
*/
function reg2bins(beg, end) {
  const list = [];
  if (end >= 1 << 29) end = 1 << 29;
  --end;
  list.push(0);
  list.push([1 + (beg >> 26), 1 + (end >> 26)]);
  list.push([9 + (beg >> 23), 9 + (end >> 23)]);
  list.push([73 + (beg >> 20), 73 + (end >> 20)]);
  list.push([585 + (beg >> 17), 585 + (end >> 17)]);
  list.push([4681 + (beg >> 14), 4681 + (end >> 14)]);

  // for (k = 1 + (beg >> 26); k <= 1 + (end >> 26); ++k) list.push(k);
  // for (k = 9 + (beg >> 23); k <= 9 + (end >> 23); ++k) list.push(k);
  // for (k = 73 + (beg >> 20); k <= 73 + (end >> 20); ++k) list.push(k);
  // for (k = 585 + (beg >> 17); k <= 585 + (end >> 17); ++k) list.push(k);
  // for (k = 4681 + (beg >> 14); k <= 4681 + (end >> 14); ++k) list.push(k);
  return list;
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

async function parseTribbleIndex(arrayBuffer, genome) {

  const index = {};
  const parser = new BinaryParser$1(new DataView(arrayBuffer));
  readHeader(parser);

  let nChrs = parser.getInt();
  while (nChrs-- > 0) {
    // todo -- support interval tree index, we're assuming its a linear index
    const chrIdx = readLinear(parser);
    index[chrIdx.chr] = chrIdx;
  }

  return new TribbleIndex(index);

  /**
   * Read the header file.   Data here is not used in igv.js but we need to read it to advance the pointer.
   * @param parser
   */
  function readHeader(parser) {

    parser.getInt();     //   view._getInt32(offset += 32, true);
    parser.getInt();
    const version = parser.getInt();
    parser.getString();
    parser.getLong();
    parser.getLong();
    parser.getString();
    parser.getInt();
    if (version >= 3) {
      let nProperties = parser.getInt();
      while (nProperties-- > 0) {
        parser.getString();
        parser.getString();
      }
    }
  }

  function readLinear(parser) {

    let chr = parser.getString();

    // Translate to canonical name
    if (genome) chr = genome.getChromosomeName(chr);

    const binWidth = parser.getInt();
    const nBins = parser.getInt();
    const longestFeature = parser.getInt();
    parser.getInt() > 0;
    parser.getInt();

    // note the code below accounts for > 60% of the total time to read an index
    let pos = parser.getLong();

    const blocks = new Array();
    for (let binNumber = 0; binNumber < nBins; binNumber++) {
      const nextPos = parser.getLong();
      blocks.push({ min: pos, max: nextPos }); //        {position: pos, size: size});
      pos = nextPos;
    }
    return { chr: chr, blocks: blocks, longestFeature: longestFeature, binWidth: binWidth };
  }
}

class TribbleIndex {

  constructor(chrIndexTable) {
    this.chrIndex = chrIndexTable;      // Dictionary of chr -> tribble index
  }

  /**
   * Fetch blocks for a particular genomic range.
   *
   * @param queryChr the sequence dictionary index of the chromosome
   * @param min  genomic start position
   * @param max  genomic end position
   */
  blocksForRange(queryChr, min, max) { //function (refId, min, max) {
    const chrIdx = this.chrIndex[queryChr];

    if (chrIdx) {
      const blocks = chrIdx.blocks;
      const longestFeature = chrIdx.longestFeature;
      const binWidth = chrIdx.binWidth;
      const adjustedPosition = Math.max(min - longestFeature, 0);
      const startBinNumber = Math.floor(adjustedPosition / binWidth);

      if (startBinNumber >= blocks.length) // are we off the end of the bin list, so return nothing
        return [];
      else {
        const endBinNumber = Math.min(Math.floor((max - 1) / binWidth), blocks.length - 1);

        // By definition blocks are adjacent in the file for the liner index.  Combine them into one merged block
        const startPos = blocks[startBinNumber].min;
        const endPos = blocks[endBinNumber].max;
        const size = endPos - startPos;
        if (size === 0) {
          return [];
        } else {
          const mergedBlock = { minv: { block: startPos, offset: 0 }, maxv: { block: endPos, offset: 0 } };
          return [mergedBlock];
        }
      }
    } else {
      return undefined;
    }
  }
}

const CSI1_MAGIC = 21582659; // CSI\1
const CSI2_MAGIC = 38359875; // CSI\2
const BAI_MAGIC = 21578050;
const TABIX_MAGIC = 21578324;
const TRIBBLE_MAGIC = 1480870228;   //  byte[]{'T', 'I', 'D', 'X'};

/**
* @param indexURL
* @param config
* @param tabix
*
*/
async function loadIndex(indexURL, config, genome) {

  let arrayBuffer = await igvxhr.loadArrayBuffer(indexURL, buildOptions$1(config));
  let dv = new DataView(arrayBuffer);

  // Some indexs are gzipped, specifically tabix, and csi.  Bam (bai) are not.  Tribble is usually not.
  // Check first 2 bytes of file for gzip magic number, and inflate if neccessary
  if (dv.getUint8(0) === 0x1f && dv.getUint8(1) === 0x8b) {    // gzipped
    const inflate = new Zlib$2.Gunzip(new Uint8Array(arrayBuffer));
    arrayBuffer = inflate.decompress().buffer;
    dv = new DataView(arrayBuffer);
  }

  const magic = dv.getInt32(0, true);
  switch (magic) {
    case BAI_MAGIC:
      return parseBamIndex(arrayBuffer, genome);
    case TABIX_MAGIC:
      return parseTabixIndex(arrayBuffer, genome);
    case CSI1_MAGIC:
      return parseCsiIndex(arrayBuffer, genome);
    case TRIBBLE_MAGIC:
      return parseTribbleIndex(arrayBuffer, genome);
    case CSI2_MAGIC:
      throw Error("CSI version 2 is not supported.");
    default:
      throw Error(`Unrecognized index type: ${indexURL}`);
  }
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
* Author: Jim Robinson
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

function getDataWrapper(data) {

  if (typeof (data) == 'string' || data instanceof String) {
    return new StringDataWrapper(data);
  } else {
    return new ByteArrayDataWrapper(data);
  }
}


// Data might be a string, or an UInt8Array
class StringDataWrapper {

  constructor(string) {
    this.data = string;
    this.ptr = 0;
  }

  nextLine() {
    var start = this.ptr,
      idx = this.data.indexOf('\n', start),
      data = this.data;

    if (idx > 0) {
      this.ptr = idx + 1;   // Advance pointer for next line
      if (idx > start && data.charAt(idx - 1) === '\r') {
        // Trim CR manually in CR/LF sequence
        return data.substring(start, idx - 1);
      }
      return data.substring(start, idx);
    } else {
      var length = data.length;
      this.ptr = length;
      // Return undefined only at the very end of the data
      return (start >= length) ? undefined : data.substring(start);
    }
  }
}

class ByteArrayDataWrapper {

  constructor(array) {
    this.data = array;
    this.length = this.data.length;
    this.ptr = 0;
  }

  nextLine() {

    var c, result;
    result = "";

    if (this.ptr >= this.length) return undefined;

    for (var i = this.ptr; i < this.length; i++) {
      c = String.fromCharCode(this.data[i]);
      if (c === '\r') continue;
      if (c === '\n') break;
      result = result + c;
    }

    this.ptr = i + 1;
    return result;
  }

}

class BGZipLineReader {

  constructor(config) {
    this.config = config;
    this.filePtr = 0;
    this.bufferPtr = 0;
    this.buffer;
  }

  async nextLine() {

    let result = undefined;

    try {
      while (true) {
        const length = this.buffer ? this.buffer.length : 0;
        while (this.bufferPtr < length) {
          const c = String.fromCharCode(this.buffer[this.bufferPtr++]);
          if (c === '\r') continue;
          if (c === '\n') {
            return result;
          }
          result = result ? result + c : c;
        }
        if (this.eof) {
          return result;
        } else {
          await this.readNextBlock();
        }
      }
    } catch (e) {
      console.warn(e);
      this.eof = true;
      return result;
    }
  }

  async readNextBlock() {

    const bsizeOptions = buildOptions$1(this.config, {
      range: {
        start: this.filePtr,
        size: 26
      }
    });
    const abuffer = await igvxhr.loadArrayBuffer(this.config.url, bsizeOptions);
    const bufferSize = bgzBlockSize(abuffer);
    //console.log(`next block ${this.filePtr}  ${bufferSize}`);

    if (bufferSize === 0) {
      this.eof = true;
      this.buffer = undefined;
    } else {

      const options = buildOptions$1(this.config, { range: { start: this.filePtr, size: bufferSize } });
      const data = await igvxhr.loadArrayBuffer(this.config.url, options);
      if (data.byteLength < bufferSize) {
        this.eof = true; // Assumption
      }
      this.buffer = unbgzf(data);
      this.bufferPtr = 0;
      this.filePtr += data.byteLength; //data.byteLength;
    }
  }

}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

const isString$1 = isString$2;

/**
* Reader for "bed like" files (tab delimited files with 1 feature per line: bed, gff, vcf, etc)
*
* @param config
* @constructor
*/
class FeatureFileReader {

  constructor(config, genome) {

    var uriParts;

    this.config = config || {};
    this.genome = genome;
    this.indexURL = config.indexURL;
    this.indexed = config.indexed;

    if (isFile(this.config.url)) {
      this.filename = this.config.url.name;
    } else if (isString$1(this.config.url) && this.config.url.startsWith('data:')) {
      this.indexed = false;  // by definition
      this.dataURI = config.url;
    } else {
      uriParts = parseUri(this.config.url);
      this.filename = config.filename || uriParts.file;
    }

    this.parser = this.getParser(this.config);

    if (this.config.format === "vcf" && !this.config.indexURL) {
      console.warn("Warning: index file not specified.  The entire vcf file will be loaded.");
    }
  }

  /**
   * Return a promise to load features for the genomic interval
   * @param chr
   * @param start
   * @param end
   */
  async readFeatures(chr, start, end) {

    const index = await this.getIndex();
    if (index) {
      this.indexed = true;
      return this.loadFeaturesWithIndex(chr, start, end);
    } else if (this.dataURI) {
      this.indexed = false;
      return this.loadFeaturesFromDataURI();
    } else {
      this.indexed = false;
      return this.loadFeaturesNoIndex()
    }

  }

  async readHeader() {

    if (this.dataURI) {
      this.loadFeaturesFromDataURI(this.dataURI);
      return this.header;
    } else {

      if (this.config.indexURL) {
        const index = await this.getIndex();
        if (!index) {
          // Note - it should be impossible to get here
          throw new Error("Unable to load index: " + this.config.indexURL);
        }

        let dataWrapper;
        if (index.tabix) {
          dataWrapper = new BGZipLineReader(this.config);
        } else {
          // Tribble
          const maxSize = Object.values(index.chrIndex)
            .flatMap(chr => chr.blocks)
            .map(block => block.max)
            .reduce((previous, current) =>
              Math.min(previous, current), Number.MAX_SAFE_INTEGER);

          const options = buildOptions$1(this.config, { bgz: index.tabix, range: { start: 0, size: maxSize } });
          const data = await igvxhr.loadString(this.config.url, options);
          dataWrapper = getDataWrapper(data);
        }


        this.header = await this.parser.parseHeader(dataWrapper);  // Cache header, might be needed to parse features
        return this.header;

      } else {
        // If this is a non-indexed file we will load all features in advance
        const options = buildOptions$1(this.config);
        const data = await igvxhr.loadString(this.config.url, options);
        let dataWrapper = getDataWrapper(data);
        this.header = await this.parser.parseHeader(dataWrapper);

        // Reset data wrapper and parse features
        dataWrapper = getDataWrapper(data);
        this.features = await this.parser.parseFeatures(dataWrapper);   // cache features
        return this.header;
      }
    }
  }


  getParser(config) {

    switch (config.format) {
      case "vcf":
        return new VcfParser(config);
      case "seg":
        return new SegParser();
      case "gwas":
        return new GWASParser(config);
      case "aed":
        return new AEDParser(config);
      default:
        return new FeatureParser(config);
    }
  }

  async loadFeaturesNoIndex() {

    if (this.features) {
      // An optimization hack for non-indexed files, features are temporarily cached when header is read.
      const tmp = this.features;
      delete this.features;
      return tmp;
    } else {
      const options = buildOptions$1(this.config);    // Add oauth token, if any
      const data = await igvxhr.loadString(this.config.url, options);
      if (!this.header) {
        const dataWrapper = getDataWrapper(data);
        this.header = await this.parser.parseHeader(dataWrapper);
      }
      const dataWrapper = getDataWrapper(data);
      const features = await this.parser.parseFeatures(dataWrapper);   // <= PARSING DONE HERE
      return features;
    }
  }

  async loadFeaturesWithIndex(chr, start, end) {

    //console.log("Using index"
    const config = this.config;
    const parser = this.parser;
    const tabix = this.index.tabix;
    const refId = tabix ? this.index.sequenceIndexMap[chr] : chr;
    if (refId === undefined) {
      return [];
    }

    const genome = this.genome;
    const blocks = this.index.blocksForRange(refId, start, end);
    if (!blocks || blocks.length === 0) {
      return [];
    } else {
      const allFeatures = [];
      for (let block of blocks) {

        const startPos = block.minv.block;
        const startOffset = block.minv.offset;
        const endOffset = block.maxv.offset;
        let endPos;

        if (tabix) {
          let lastBlockSize = 0;
          if (endOffset > 0) {
            const bsizeOptions = buildOptions$1(config, {
              range: {
                start: block.maxv.block,
                size: 26
              }
            });
            const abuffer = await igvxhr.loadArrayBuffer(config.url, bsizeOptions);
            lastBlockSize = bgzBlockSize(abuffer);
          }
          endPos = block.maxv.block + lastBlockSize;
        } else {
          endPos = block.maxv.block;
        }

        const options = buildOptions$1(config, {
          range: {
            start: startPos,
            size: endPos - startPos + 1
          }
        });

        let inflated;
        if (tabix) {
          const data = await igvxhr.loadArrayBuffer(config.url, options);
          inflated = unbgzf(data);
        } else {
          inflated = await igvxhr.loadString(config.url, options);
        }

        const slicedData = startOffset ? inflated.slice(startOffset) : inflated;
        const dataWrapper = getDataWrapper(slicedData);
        const slicedFeatures = await parser.parseFeatures(dataWrapper);

        // Filter features not in requested range.
        let inInterval = false;
        for (let i = 0; i < slicedFeatures.length; i++) {
          const f = slicedFeatures[i];
          const canonicalChromosome = genome ? genome.getChromosomeName(f.chr) : f.chr;
          if (canonicalChromosome !== chr) {
            if (allFeatures.length === 0) {
              continue;  //adjacent chr to the left
            } else {
              break; //adjacent chr to the right
            }
          }
          if (f.start > end) {
            allFeatures.push(f);  // First feature beyond interval
            break;
          }
          if (f.end >= start && f.start <= end) {
            if (!inInterval) {
              inInterval = true;
              if (i > 0) {
                allFeatures.push(slicedFeatures[i - 1]);
              }
            }
            allFeatures.push(f);
          }
        }

      }
      allFeatures.sort(function (a, b) {
        return a.start - b.start;
      });

      return allFeatures;
    }
  }

  async getIndex() {
    if (this.index || !this.config.indexURL) {
      return this.index;
    } else {
      this.index = await this.loadIndex();
      return this.index;
    }
  }

  /**
   * Return a Promise for the async loaded index
   */
  async loadIndex() {
    const indexURL = this.config.indexURL;
    return loadIndex(indexURL, this.config, this.genome);
  }

  async loadFeaturesFromDataURI() {

    if (this.features) {
      // An optimization hack for non-indexed files, features are temporarily cached when header is read.
      const tmp = this.features;
      delete this.features;
      return tmp;
    } else {
      const plain = decodeDataURI(this.dataURI);
      let dataWrapper = getDataWrapper(plain);
      this.header = await this.parser.parseHeader(dataWrapper);
      if (this.header instanceof String && this.header.startsWith("##gff-version 3")) {
        this.format = 'gff3';
      }

      dataWrapper = getDataWrapper(plain);
      this.features = await this.parser.parseFeatures(dataWrapper);
      return this.features;
    }
  }

}

/*
* The MIT License (MIT)
*
* Copyright (c) 2016 University of California San Diego
* Author: Jim Robinson
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

/**
* Created by jrobinson on 4/7/16.
*/

const transcriptTypes = new Set(['transcript', 'primary_transcript', 'processed_transcript', 'mRNA', 'mrna']);
const cdsTypes = new Set(['CDS', 'cds']);
const codonTypes = new Set(['start_codon', 'stop_codon']);
const utrTypes = new Set(['5UTR', '3UTR', 'UTR', 'five_prime_UTR', 'three_prime_UTR', "3'-UTR", "5'-UTR"]);
const exonTypes = new Set(['exon', 'coding-exon']);
const intronType = 'intron';
const transcriptModelTypes = new Set();
for (let cltn of [transcriptTypes, cdsTypes, codonTypes, utrTypes, exonTypes]) {
  for (let t of cltn) {
    transcriptModelTypes.add(t);
  }
}


class GFFHelper {
  constructor(options) {
    this.format = options.format;
    this.filterTypes = options.filterTypes === undefined ?
      new Set(['chromosome']) :
      new Set(options.filterTypes);
  }

  combineFeatures(features) {
    let combinedFeatures;
    if ("gff3" === this.format) {
      const tmp = this.combineFeaturesById(features);
      combinedFeatures = this.combineFeaturesGFF(tmp);
    } else {
      combinedFeatures = this.combineFeaturesGTF(features);
    }
    combinedFeatures.sort(function (a, b) {
      return a.start - b.start;
    });
    return combinedFeatures;
  }

  combineFeaturesById(features) {
    const combinedFeatures = [];
    const chrIdHash = {};
    for (let f of features) {
      if (f.id === undefined) {
        combinedFeatures.push(f);
      } else {
        let idHash = chrIdHash[f.chr];
        if (!idHash) {
          idHash = {};
          chrIdHash[f.chr] = idHash;
        }
        if (idHash.hasOwnProperty(f.id)) {
          const sf = idHash[f.id];
          if (sf.hasOwnProperty("exons")) {
            sf.start = Math.min(sf.start, f.start);
            sf.end = Math.max(sf.end, f.end);
            sf.exons.push(f);
          } else {
            const cf = {
              id: f.id,
              type: f.type,
              chr: f.chr,
              strand: f.strand,
              start: Math.min(f.start, sf.start),
              end: Math.max(f.end, sf.end),
              exons: [sf, f]
            };
            if (f.parent && f.parent.trim() !== "") {
              cf.parent = f.parent;
            }
            idHash[f.id] = cf;
          }
        } else {
          idHash[f.id] = f;
        }
      }
    }
    for (let key of Object.keys(chrIdHash)) {
      const idHash = chrIdHash[key];
      for (let id of Object.keys(idHash)) {
        combinedFeatures.push(idHash[id]);
      }
    }
    return combinedFeatures;
  }

  combineFeaturesGTF(features) {

    const transcripts = Object.create(null);
    const combinedFeatures = [];
    const consumedFeatures = new Set();
    const filterTypes = this.filterTypes;

    features = features.filter(f => filterTypes === undefined || !filterTypes.has(f.type));

    // 1. Build dictionary of transcripts
    for (let f of features) {
      if (transcriptTypes.has(f.type)) {
        const transcriptId = f.id;
        if (undefined !== transcriptId) {
          const gffTranscript = new GFFTranscript(f);
          transcripts[transcriptId] = gffTranscript;
          combinedFeatures.push(gffTranscript);
          consumedFeatures.add(f);
        }
      }
    }

    // Add exons
    for (let f of features) {
      if (exonTypes.has(f.type)) {
        const id = f.id;   // transcript_id,  GTF groups all features with the same ID, does not have a parent/child hierarchy
        if (id) {
          let transcript = transcripts[id];
          if (transcript === undefined) {
            transcript = new GFFTranscript(f);    // GTF does not require an explicit transcript record
            transcripts[id] = transcript;
            combinedFeatures.push(transcript);
          }
          transcript.addExon(f);
          consumedFeatures.add(f);
        }
      }
    }

    // Apply CDS and UTR
    for (let f of features) {
      if (cdsTypes.has(f.type) || utrTypes.has(f.type) || codonTypes.has(f.type)) {
        const id = f.id;
        if (id) {
          let transcript = transcripts[id];
          if (transcript === undefined) {
            transcript = new GFFTranscript(f);
            transcripts[id] = transcript;
            combinedFeatures.push(transcript);
          }
          if (utrTypes.has(f.type)) {
            transcript.addUTR(f);
          } else if (cdsTypes.has(f.type)) {
            transcript.addCDS(f);
          } else if (codonTypes.has(f.type));
          consumedFeatures.add(f);
        }
      }
    }

    // Finish transcripts
    for (let f of combinedFeatures) {
      if (typeof f.finish === "function") {
        f.finish();
      }
    }

    // Add other features
    const others = features.filter(f => !consumedFeatures.has(f));
    for (let f of others) {
      combinedFeatures.push(f);
    }

    return combinedFeatures;

  }

  combineFeaturesGFF(features) {

    // Build dictionary of genes (optional)
    const genes = features.filter(f => "gene" === f.type);
    const geneMap = Object.create(null);
    for (let g of genes) {
      geneMap[g.id] = g;
    }

    // 1. Build dictionary of transcripts
    const transcripts = Object.create(null);
    const combinedFeatures = [];
    const consumedFeatures = new Set();
    const filterTypes = this.filterTypes;

    features = features.filter(f => filterTypes === undefined || !filterTypes.has(f.type));

    for (let f of features) {
      if (transcriptTypes.has(f.type)) {
        const transcriptId = f.id; // getAttribute(f.attributeString, "transcript_id", /\s+/);
        if (undefined !== transcriptId) {
          const gffTranscript = new GFFTranscript(f);
          transcripts[transcriptId] = gffTranscript;
          combinedFeatures.push(gffTranscript);
          consumedFeatures.add(f);
          const g = geneMap[f.parent];
          if (g) {
            gffTranscript.gene = geneMap[f.parent];
            consumedFeatures.add(g);
          }
        }
      }
    }

    // Remove assigned genes

    // Add exons
    for (let f of features) {
      if (exonTypes.has(f.type)) {
        const parents = getParents(f);
        if (parents) {
          for (let id of parents) {
            let transcript = transcripts[id];
            if (transcript !== undefined) {
              transcript.addExon(f);
              consumedFeatures.add(f);
            }
          }
        }
      }
    }

    // Apply CDS and UTR
    for (let f of features) {
      if (cdsTypes.has(f.type) || utrTypes.has(f.type) || codonTypes.has(f.type)) {
        const parents = getParents(f);
        if (parents) {
          for (let id of parents) {
            let transcript = transcripts[id];
            if (transcript !== undefined) {
              if (utrTypes.has(f.type)) {
                transcript.addUTR(f);
              } else if (cdsTypes.has(f.type)) {
                transcript.addCDS(f);
              } else if (codonTypes.has(f.type));
              consumedFeatures.add(f);
            }
          }
        }
      }
    }

    // Introns are ignored, but are consumed
    const introns = features.filter(f => intronType === f.type);
    for (let i of introns) {
      const parents = getParents(i);
      for (let id of parents) {
        if (transcripts[id]) {
          consumedFeatures.add(i);
          break;
        }
      }
    }

    // Finish transcripts
    combinedFeatures.forEach(function (f) {
      if (typeof f.finish === "function") {
        f.finish();
      }
    });

    // Add other features
    const others = features.filter(f => !consumedFeatures.has(f));
    for (let f of others) {
      combinedFeatures.push(f);
    }

    return combinedFeatures;

    function getParents(f) {
      if (f.parent && f.parent.trim() !== "") {
        return f.parent.trim().split(",");
      } else {
        return null;
      }
    }
  }
}

var GFFTranscript = function (feature) {
  Object.assign(this, feature);
  this.exons = [];
};

GFFTranscript.prototype.addExon = function (feature) {

  this.exons.push(feature);

  // Expand feature --  for transcripts not explicitly represented in the file
  this.start = Math.min(this.start, feature.start);
  this.end = Math.max(this.end, feature.end);
};

GFFTranscript.prototype.addCDS = function (cds) {

  let exon;
  const exons = this.exons;

  // Find exon containing CDS
  for (let i = 0; i < exons.length; i++) {
    if (exons[i].start <= cds.start && exons[i].end >= cds.end) {
      exon = exons[i];
      break;
    }
  }

  if (exon) {
    exon.cdStart = exon.cdStart ? Math.min(cds.start, exon.cdStart) : cds.start;
    exon.cdEnd = exon.cdEnd ? Math.max(cds.end, exon.cdEnd) : cds.end;
    if (!exon.children) {
      exon.children = [];
    }
    exon.children.push(cds);
  } else {
    cds.cdStart = cds.start;
    cds.cdEnd = cds.end;
    exons.push(cds);
  }

  // Expand feature --  for transcripts not explicitly represented in the file (gtf files)
  this.start = Math.min(this.start, cds.start);
  this.end = Math.max(this.end, cds.end);

  this.cdStart = this.cdStart ? Math.min(cds.start, this.cdStart) : cds.start;
  this.cdEnd = this.cdEnd ? Math.max(cds.end, this.cdEnd) : cds.end;
};

GFFTranscript.prototype.addUTR = function (utr) {

  let exon;
  const exons = this.exons;

  // Find exon containing CDS
  for (let i = 0; i < exons.length; i++) {
    if (exons[i].start <= utr.start && exons[i].end >= utr.end) {
      exon = exons[i];
      break;
    }
  }

  if (exon) {
    if (utr.start === exon.start && utr.end === exon.end) {
      exon.utr = true;
    } else {
      if (utr.end < exon.end) {
        exon.cdStart = utr.end;
      }
      if (utr.start > exon.start) {
        exon.cdEnd = utr.start;
      }
    }
    if (!exon.children) {
      exon.children = [];
    }
    exon.children.push(utr);

  } else {
    utr.utr = true;
    exons.push(utr);
  }

  // Expand feature --  for transcripts not explicitly represented in the file
  this.start = Math.min(this.start, utr.start);
  this.end = Math.max(this.end, utr.end);

};

GFFTranscript.prototype.finish = function () {

  var cdStart = this.cdStart;
  var cdEnd = this.cdEnd;

  this.exons.sort(function (a, b) {
    return a.start - b.start;
  });

  // Search for UTR exons that were not explicitly tagged
  if (cdStart) {
    this.exons.forEach(function (exon) {
      if (exon.end < cdStart || exon.start > cdEnd) exon.utr = true;
    });
  }
};

GFFTranscript.prototype.popupData = function (genomicLocation) {

  const kvs = this.attributeString.split(';');
  const pd = [];

  // If feature has an associated gene list its attributes first
  if (this.gene && typeof this.gene.popupData === 'function') {
    const gd = this.gene.popupData(genomicLocation);
    for (let e of gd) {
      pd.push(e);
    }
    pd.push("<hr>");
  }
  if (this.name) {
    pd.push({ name: 'name', value: this.name });
  }
  pd.push({ name: 'type', value: this.type });
  for (let kv of kvs) {
    var t = kv.trim().split(this.delim, 2);
    if (t.length === 2 && t[1] !== undefined) {
      const key = t[0].trim();
      if ('name' === key.toLowerCase()) continue;
      let value = t[1].trim();
      //Strip off quotes, if any
      if (value.startsWith('"') && value.endsWith('"')) {
        value = value.substr(1, value.length - 2);
      }
      pd.push({ name: key, value: value });
    }
  }
  pd.push({
    name: 'position',
    value: `${this.chr}:${numberFormatter(this.start + 1)}-${numberFormatter(this.end)}`
  });


  // If clicked over an exon add its attributes
  for (let exon of this.exons) {
    if (genomicLocation >= exon.start && genomicLocation < exon.end && typeof exon.popupData === 'function') {
      pd.push("<hr>");
      const exonData = exon.popupData(genomicLocation);
      for (let att of exonData) {
        pd.push(att);
      }

      if (exon.children) {
        for (let c of exon.children) {
          pd.push("<hr>");
          const exonData = c.popupData(genomicLocation);
          for (let att of exonData) {
            pd.push(att);
          }
        }
      }
    }
  }


  return pd;
};

const GenomicInterval = function (chr, start, end, features) {
  this.chr = chr;
  this.start = start;
  this.end = end;
  this.features = features;
};

GenomicInterval.prototype.contains = function (chr, start, end) {
  return this.chr === chr &&
    this.start <= start &&
    this.end >= end;
};

GenomicInterval.prototype.containsRange = function (range) {
  return this.chr === range.chr &&
    this.start <= range.start &&
    this.end >= range.end;
};

// Assigns a row # to each feature.  If the feature does not fit in any row and #rows == maxRows no
// row number is assigned.
function pack(featureList, maxRows) {

  maxRows = maxRows || Number.MAX_SAFE_INTEGER;
  const rows = [];
  featureList.sort(function (a, b) {
    return a.start - b.start;
  });
  rows.push(-1000);

  for (let feature of featureList) {
    let r = 0;
    const len = Math.min(rows.length, maxRows);
    for (r = 0; r < len; r++) {
      if (feature.start > rows[r]) {
        feature.row = r;
        rows[r] = feature.end;
        break;
      }
    }
    feature.row = r;
    rows[r] = feature.end;
  }
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014-2015 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/


/**
* feature source for "bed like" files (tab or whitespace delimited files with 1 feature per line: bed, gff, vcf, etc)
*
* @param config
* @constructor
*/
class TextFeatureSource {

  constructor(config, genome) {
    this.config = config || {};
    this.genome = genome;
    this.sourceType = (config.sourceType === undefined ? "file" : config.sourceType);
    this.visibilityWindow = config.visibilityWindow;

    const queryableFormats = new Set(["bigwig", "bw", "bigbed", "bb", "tdf"]);

    if (config.features && Array.isArray(config.features)) {
      let features = fixFeatures(config.features);
      packFeatures(features);
      if (config.mappings) {
        mapProperties(features, config.mappings);
      }
      this.queryable = false;
      this.featureCache = new FeatureCache(features, genome);
    } else if (config.reader) {
      this.reader = config.reader;
      this.queryable = config.queryable !== undefined ? config.queryable : true;
      this.expandQuery = config.expandQuery ? true : false;
    } else if (config.sourceType === "ga4gh") {
      this.reader = new Ga4ghVariantReader(config, genome);
      this.queryable = true;
    } else if (config.sourceType === "immvar") {
      this.reader = new ImmVarReader(config);
      this.queryable = true;
    } else if (config.type === "eqtl" && config.sourceType === "gtex-ws") {
      this.reader = new GtexReader(config);
      this.queryable = true;
      this.expandQuery = config.expandQuery ? true : false;
    } else if (config.sourceType === 'ucscservice') {
      this.reader = new UCSCServiceReader(config.source);
      this.queryable = true;
    } else if (config.sourceType === 'custom' || config.source !== undefined) {    // Second test for backward compatibility
      this.reader = new CustomServiceReader(config.source);
      this.queryable = config.source.queryable !== undefined ? config.source.queryable : true;
      this.expandQuery = config.expandQuery ? true : false;
    } else if ("civic-ws" === config.sourceType) {
      this.reader = new CivicReader(config);
      this.queryable = false;
      this.expandQuery = config.expandQuery ? true : false;
    } else {
      this.reader = new FeatureFileReader(config, genome);
      if (config.queryable !== undefined) {
        this.queryable = config.queryable;
      } else if (queryableFormats.has(config.format)) {
        this.queryable = queryableFormats.has(config.format) || this.reader.indexed;
      } else;
    }
  }

  supportsWholeGenome() {
    return !this.queryable && (this.visibilityWindow === undefined || this.visibilityWindow <= 0);
  }

  async trackType() {
    const header = await this.getHeader();
    if (header) {
      return header.type;
    } else {
      return undefined;    // Convention for unknown or unspecified
    }
  }

  async getHeader() {
    if (!this.header) {

      if (this.reader && typeof this.reader.readHeader === "function") {
        const header = await this.reader.readHeader();
        if (header) {
          this.header = header;
          if (header.format) {
            this.config.format = header.format;
          }
        } else {
          this.header = {};
        }
      } else {
        this.header = {};
      }
    }
    return this.header
  }

  /**
   * Required function for all data source objects.  Fetches features for the
   * range requested.
   *
   * This function is quite complex due to the variety of reader types backing it, some indexed, some queryable,
   * some not.  The whole scheme could use a refactoring.
   *
   * @param chr
   * @param start
   * @param end
   * @param bpPerPixel
   */
  async getFeatures({ chr, start, end, bpPerPixel, visibilityWindow }) {

    const genome = this.genome;
    const queryChr = genome ? genome.getChromosomeName(chr) : chr;
    const isWholeGenome = ("all" === queryChr.toLowerCase());

    // Various conditions that can create a feature load
    // * view is "whole genome" but no features are loaded
    // * cache is disabled
    // * cache does not contain requested range
    if ((isWholeGenome && !this.getWGFeatures) ||
      this.config.disableCache ||
      !this.featureCache ||
      !this.featureCache.containsRange(new GenomicInterval(queryChr, start, end))) {
      await this.loadFeatures(start, end, visibilityWindow, queryChr);
    }

    if (isWholeGenome) {
      if (!this.wgFeatures) {
        if (this.queryable) {   // queryable sources don't support whole genome view
          this.wgFeatures = [];
        } else {
          this.wgFeatures = this.getWGFeatures(this.featureCache.getAllFeatures());
        }
      }
      return this.wgFeatures;
    } else {
      return this.featureCache.queryFeatures(queryChr, start, end);
    }
  }


  async loadFeatures(start, end, visibilityWindow, queryChr) {

    const reader = this.reader;
    let intervalStart = start;
    let intervalEnd = end;

    // Use visibility window to potentially expand query interval.
    // This can save re-queries as we zoom out.  Visibility window <= 0 is a special case
    // indicating whole chromosome should be read at once.
    if ((!visibilityWindow || visibilityWindow <= 0) && this.expandQuery !== false) {
      // Whole chromosome
      const chromosome = this.genome ? this.genome.getChromosome(queryChr) : undefined;
      intervalStart = 0;
      intervalEnd = chromosome ? chromosome.bpLength : Number.MAX_SAFE_INTEGER;
    } else if (visibilityWindow > (end - start) && this.expandQuery !== false) {
      const expansionWindow = Math.min(4.1 * (end - start), visibilityWindow);
      intervalStart = Math.max(0, (start + end - expansionWindow) / 2);
      intervalEnd = start + expansionWindow;
    }

    let features = await reader.readFeatures(queryChr, intervalStart, intervalEnd);
    if (this.queryable === undefined) {
      this.queryable = reader.indexed;
    }

    const genomicInterval = this.queryable ?
      new GenomicInterval(queryChr, intervalStart, intervalEnd) :
      undefined;

    if (features) {

      if ("gtf" === this.config.format || "gff3" === this.config.format || "gff" === this.config.format) {
        features = (new GFFHelper(this.config)).combineFeatures(features);
      }

      // Assign overlapping features to rows
      if (this.config.format !== "wig" && this.config.type !== "junctions") {
        const maxRows = this.config.maxRows || Number.MAX_SAFE_INTEGER;
        packFeatures(features, maxRows);
      }

      // Note - replacing previous cache with new one.  genomicInterval is optional (might be undefined => includes all features)
      this.featureCache = new FeatureCache(features, this.genome, genomicInterval);

      // If track is marked "searchable"< cache features by name -- use this with caution, memory intensive
      if (this.config.searchable) {
        this.addFeaturesToDB(features);
      }
    } else {
      this.featureCache = new FeatureCache([], genomicInterval);     // Empty cache
    }
  }

  addFeaturesToDB(featureList) {
    for (let feature of featureList) {
      if (feature.name) {
        this.genome.featureDB[feature.name.toUpperCase()] = feature;
      }
      if (feature.gene && feature.gene.name) {
        this.genome.featureDB[feature.gene.name.toUpperCase()] = feature;
      }
    }
  }

  // TODO -- filter by pixel size
  getWGFeatures(allFeatures) {

    const genome = this.genome;
    const wgChromosomeNames = new Set(genome.wgChromosomeNames);
    const wgFeatures = [];

    for (let c of genome.wgChromosomeNames) {

      const features = allFeatures[c];

      if (features) {
        for (let f of features) {
          let queryChr = genome.getChromosomeName(f.chr);
          if (wgChromosomeNames.has(queryChr)) {

            const wg = Object.assign({}, f);

            wg.chr = "all";
            wg.start = genome.getGenomeCoordinate(f.chr, f.start);
            wg.end = genome.getGenomeCoordinate(f.chr, f.end);
            wg._f = f;

            // Don't draw exons in whole genome view
            if (wg["exons"]) delete wg["exons"];
            wg.popupData = function (genomeLocation) {
              if (typeof this._f.popupData === 'function') {
                return this._f.popupData();
              } else {
                return TrackBase.extractPopupData(this._f, genome.id);
              }
            };

            wgFeatures.push(wg);
          }
        }
      }
    }

    wgFeatures.sort(function (a, b) {
      return a.start - b.start;
    });

    return wgFeatures;

  }
}

function packFeatures(features, maxRows) {

  maxRows = maxRows || 1000;
  if (features == null || features.length === 0) {
    return;
  }
  // Segregate by chromosome
  const chrFeatureMap = {};
  const chrs = [];
  for (let feature of features) {
    const chr = feature.chr;
    let flist = chrFeatureMap[chr];
    if (!flist) {
      flist = [];
      chrFeatureMap[chr] = flist;
      chrs.push(chr);
    }
    flist.push(feature);
  }

  // Loop through chrosomosomes and pack features;
  for (let chr of chrs) {
    pack(chrFeatureMap[chr], maxRows);
  }
}

/**
* This function is used to apply properties normally added during parsing to  features supplied directly in the
* config as an array of objects.   At the moment the only application is bedpe type features.
* @param features
*/
function fixFeatures(features) {

  if (!features || features.length === 0) return;

  const isBedPE = features[0].chr === undefined && features[0].chr1 !== undefined;
  if (isBedPE) {
    const interChrFeatures = [];
    for (let feature of features) {
      // Set total extent of feature
      if (feature.chr1 === feature.chr2) {
        feature.chr = feature.chr1;
        feature.start = Math.min(feature.start1, feature.start2);
        feature.end = Math.max(feature.end1, feature.end2);
      } else {
        interChrFeatures.push(feature);
      }
    }
    // Make copies of inter-chr features, one for each chromosome
    for (let f1 of interChrFeatures) {
      const f2 = Object.assign({ dup: true }, f1);
      features.push(f2);

      f1.chr = f1.chr1;
      f1.start = f1.start1;
      f1.end = f1.end1;

      f2.chr = f2.chr2;
      f2.start = f2.start2;
      f2.end = f2.end2;
    }
  }

  return features;
}


function mapProperties(features, mappings) {
  let mappingKeys = Object.keys(mappings);
  features.forEach(function (f) {
    mappingKeys.forEach(function (key) {
      f[key] = f[mappings[key]];
    });
  });
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

class BufferedReader {

  constructor(config, contentLength, bufferSize) {
    this.path = config.url;
    this.bufferSize = bufferSize ? bufferSize : 512000;
    this.range = { start: -1, size: -1 };
    this.config = config;
  }

  /**
   *
   * @param requestedRange - byte rangeas {start, size}
   * @param fulfill - function to receive result
   * @param asUint8 - optional flag to return result as an UInt8Array
   */
  async dataViewForRange(requestedRange, asUint8) {

    const hasData = (this.data && (this.range.start <= requestedRange.start) &&
      ((this.range.start + this.range.size) >= (requestedRange.start + requestedRange.size)));

    if (!hasData) {
      let bufferSize;
      // If requested range size is specified, potentially expand buffer size
      if (requestedRange.size) {
        bufferSize = Math.max(this.bufferSize, requestedRange.size);
      } else {
        bufferSize = this.bufferSize;
      }
      const loadRange = { start: requestedRange.start, size: bufferSize };
      const arrayBuffer = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, { range: loadRange }));
      this.data = arrayBuffer;
      this.range = loadRange;
    }

    const len = this.data.byteLength;
    const bufferStart = requestedRange.start - this.range.start;
    return asUint8 ?
      new Uint8Array(this.data, bufferStart, len - bufferStart) :
      new DataView(this.data, bufferStart, len - bufferStart);
  }
}

//table chromatinInteract

function getDecoder(definedFieldCount, fieldCount, autoSql) {

  if (autoSql && 'chromatinInteract' === autoSql.table) {
    return decodeInteract;
  } else {
    const standardFieldCount = definedFieldCount - 3;
    return function (feature, tokens) {

      if (standardFieldCount > 0) {
        feature.name = tokens[0];
      }
      if (standardFieldCount > 1) {
        feature.score = parseFloat(tokens[1]);
      }
      if (standardFieldCount > 2) {
        feature.strand = tokens[2];
      }
      if (standardFieldCount > 3) {
        feature.cdStart = parseInt(tokens[3]);
      }
      if (standardFieldCount > 4) {
        feature.cdEnd = parseInt(tokens[4]);
      }
      if (standardFieldCount > 5) {
        if (tokens[5] !== "." && tokens[5] !== "0" && tokens[5] !== "-1") {
          const c = IGVColor.createColorString(tokens[5]);
          feature.color = c.startsWith("rgb") ? c : undefined;
        }
      }
      if (standardFieldCount > 8) {
        const exonCount = parseInt(tokens[6]);
        const exonSizes = tokens[7].split(',');
        const exonStarts = tokens[8].split(',');
        const exons = [];
        for (let i = 0; i < exonCount; i++) {
          const eStart = feature.start + parseInt(exonStarts[i]);
          const eEnd = eStart + parseInt(exonSizes[i]);
          exons.push({ start: eStart, end: eEnd });
        }
        feature.exons = exons;
      }

      if (autoSql) {
        // TODO -- these should be equal, validate?  fieldCount-definedFieldCount, as.fields.length, tokens.length-3
        const extraStart = definedFieldCount;
        for (let i = extraStart; i < fieldCount; i++) {
          if (i < autoSql.fields.length) {
            const name = autoSql.fields[i].name;
            const value = tokens[i - 3];
            feature[name] = value;
          }
        }
      }
    }
  }

  function decodeInteract(feature, tokens) {

    feature.chr1 = tokens[5];
    feature.start1 = Number.parseInt(tokens[6]);
    feature.end1 = Number.parseInt(tokens[7]);

    feature.chr2 = tokens[10];
    feature.start2 = Number.parseInt(tokens[11]);
    feature.end2 = Number.parseInt(tokens[12]);

    feature.name = tokens[0];
    feature.score = Number.parseFloat(tokens[1]);
    feature.value = Number.parseFloat(tokens[2]);
    feature.color = tokens[4] === '.' ? undefined : tokens[4] === "0" ? "rgb(0,0,0)" : tokens[4];

    return feature;
  }
}

function parseAutoSQL(str) {

  let table;
  const fields = [];
  let startDecoding = false;
  const lines = str.trim().split(/\s*[\r\n]+\s*/g);
  for (let line of lines) {
    if (line.startsWith('table')) {
      table = line.split(/\s+/)[1].trim();
    } else if (line.startsWith('(')) {
      startDecoding = true;
    } else if (line.startsWith(')')); else if (startDecoding) {
      if (line.length > 0) {
        const idx = line.indexOf(';');
        const tokens = line.substr(0, idx).split(/\s+/);
        const description = line.substr(idx + 1).replace(/"/g, '').trim();
        fields.push({
          type: tokens[0],
          name: tokens[1],
          description: description
        });
      }
    }
  }
  return {
    table: table,
    fields: fields
  }
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

let BIGWIG_MAGIC_LTH = 0x888FFC26; // BigWig Magic Low to High
let BIGWIG_MAGIC_HTL = 0x26FC8F66; // BigWig Magic High to Low
let BIGBED_MAGIC_LTH = 0x8789F2EB; // BigBed Magic Low to High
let BIGBED_MAGIC_HTL = 0xEBF28987; // BigBed Magic High to Low
let BBFILE_HEADER_SIZE = 64;
let RPTREE_HEADER_SIZE = 48;
let RPTREE_NODE_LEAF_ITEM_SIZE = 32;   // leaf item size
let RPTREE_NODE_CHILD_ITEM_SIZE = 24;  // child item size
let BUFFER_SIZE = 512000;     //  buffer

class BWReader {

  constructor(config, genome) {
    this.path = config.url;
    this.genome = genome;
    this.rpTreeCache = {};
    this.config = config;
  }

  async readWGFeatures(bpPerPixel, windowFunction) {
    await this.loadHeader();
    const chrIdx1 = 0;
    const chrIdx2 = this.chromTree.idToChrom.length - 1;
    const chr1 = this.chromTree.idToChrom[chrIdx1];
    const chr2 = this.chromTree.idToChrom[chrIdx2];
    return this.readFeatures(chr1, 0, chr2, Number.MAX_VALUE, bpPerPixel, windowFunction);
  }

  async readFeatures(chr1, bpStart, chr2, bpEnd, bpPerPixel, windowFunction) {

    await this.loadHeader();
    const chrIdx1 = this.chromTree.chromToID[chr1];
    const chrIdx2 = this.chromTree.chromToID[chr2];
    if (chrIdx1 === undefined || chrIdx2 === undefined) {
      return [];
    }

    let treeOffset;
    let decodeFunction;
    if (this.type === "bigwig") {
      // Select a biwig "zoom level" appropriate for the current resolution.
      const zoomLevelHeaders = await this.getZoomHeaders();
      let zoomLevelHeader = bpPerPixel ? zoomLevelForScale$1(bpPerPixel, zoomLevelHeaders) : undefined;
      if (zoomLevelHeader) {
        treeOffset = zoomLevelHeader.indexOffset;
        decodeFunction = decodeZoomData;
      } else {
        treeOffset = this.header.fullIndexOffset;
        decodeFunction = decodeWigData;
      }
    } else {
      // bigbed, zoom data is not currently used in igv for bed type features
      treeOffset = this.header.fullIndexOffset;
      decodeFunction = getBedDataDecoder.call(this);
    }


    // Load the R Tree and fine leaf items
    const rpTree = await this.loadRPTree(treeOffset);
    const leafItems = await rpTree.findLeafItemsOverlapping(chrIdx1, bpStart, chrIdx2, bpEnd);
    if (!leafItems || leafItems.length === 0) {
      return [];
    } else {

      // Consolidate leaf items and get all data at once
      let start = Number.MAX_VALUE;
      let end = 0;
      for (let item of leafItems) {
        start = Math.min(start, item.dataOffset);
        end = Math.max(end, item.dataOffset + item.dataSize);
      }
      const size = end - start;
      const arrayBuffer = await igvxhr.loadArrayBuffer(this.config.url, buildOptions$1(this.config, {
        range: {
          start: start,
          size: size
        }
      }));

      // Parse data and return features
      const allFeatures = [];
      const buffer = new Uint8Array(arrayBuffer);
      for (let item of leafItems) {
        const uint8Array = buffer.subarray(item.dataOffset - start, item.dataOffset + item.dataSize);
        let plain;
        const isCompressed = this.header.uncompressBuffSize > 0;
        if (isCompressed) {
          const inflate = new Zlib$2.Inflate(uint8Array);
          plain = inflate.decompress();
        } else {
          plain = uint8Array;
        }
        decodeFunction.call(this, new DataView(plain.buffer), chrIdx1, bpStart, chrIdx2, bpEnd, allFeatures, this.chromTree.idToChrom, windowFunction);
      }

      allFeatures.sort(function (a, b) {
        return a.start - b.start;
      });

      return allFeatures;
    }
  }

  async getZoomHeaders() {
    if (this.zoomLevelHeaders) {
      return this.zoomLevelHeaders;
    } else {
      await this.loadHeader();
      return this.zoomLevelHeaders;
    }
  }

  async loadHeader() {

    if (this.header) {
      return this.header;
    } else {
      let data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
        range: {
          start: 0,
          size: BBFILE_HEADER_SIZE
        }
      }));

      let header;

      // Assume low-to-high unless proven otherwise
      this.littleEndian = true;

      let binaryParser = new BinaryParser$1(new DataView(data));
      let magic = binaryParser.getUInt();
      if (magic === BIGWIG_MAGIC_LTH) {
        this.type = "bigwig";
      } else if (magic === BIGBED_MAGIC_LTH) {
        this.type = "bigbed";
      } else {
        //Try big endian order
        this.littleEndian = false;

        binaryParser.littleEndian = false;
        binaryParser.position = 0;
        let magic = binaryParser.getUInt();

        if (magic === BIGWIG_MAGIC_HTL) {
          this.type = "bigwig";
        } else if (magic === BIGBED_MAGIC_HTL) {
          this.type = "bigbed";
        } else;
      }
      // Table 5  "Common header for bigwig and bigbed files"
      header = {
        bwVersion: binaryParser.getUShort(),
        nZoomLevels: binaryParser.getUShort(),
        chromTreeOffset: binaryParser.getLong(),
        fullDataOffset: binaryParser.getLong(),
        fullIndexOffset: binaryParser.getLong(),
        fieldCount: binaryParser.getUShort(),
        definedFieldCount: binaryParser.getUShort(),
        autoSqlOffset: binaryParser.getLong(),
        totalSummaryOffset: binaryParser.getLong(),
        uncompressBuffSize: binaryParser.getInt(),
        extensionOffset: binaryParser.getLong()
      };

      ///////////

      const startOffset = BBFILE_HEADER_SIZE;
      let range = { start: startOffset, size: (header.fullDataOffset - startOffset + 5) };
      data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, { range: range }));

      const nZooms = header.nZoomLevels;
      binaryParser = new BinaryParser$1(new DataView(data));

      this.zoomLevelHeaders = [];
      this.firstZoomDataOffset = Number.MAX_SAFE_INTEGER;
      for (let i = 1; i <= nZooms; i++) {
        const zoomNumber = nZooms - i;
        const zlh = new ZoomLevelHeader(zoomNumber, binaryParser);
        this.firstZoomDataOffset = Math.min(zlh.dataOffset, this.firstZoomDataOffset);
        this.zoomLevelHeaders[zoomNumber] = zlh;
      }

      // Autosql
      if (header.autoSqlOffset > 0) {
        binaryParser.position = header.autoSqlOffset - startOffset;
        const autoSqlString = binaryParser.getString();
        if (autoSqlString) {
          this.autoSql = parseAutoSQL(autoSqlString);
        }
      }

      // Total summary
      if (header.totalSummaryOffset > 0) {
        binaryParser.position = header.totalSummaryOffset - startOffset;
        this.totalSummary = new BWTotalSummary(binaryParser);
      }

      // Chrom data index
      if (header.chromTreeOffset > 0) {
        binaryParser.position = header.chromTreeOffset - startOffset;
        this.chromTree = new BPTree(binaryParser, startOffset, this.genome);
      } else {
        // TODO -- this is an error, not expected
        throw "BigWig chromosome tree offset <= 0";
      }

      //Finally total data count
      binaryParser.position = header.fullDataOffset - startOffset;
      header.dataCount = binaryParser.getInt();
      ///////////

      this.setDefaultVisibilityWindow(header);

      this.header = header;
      return this.header;

    }
  }

  async loadRPTree(offset) {

    let rpTree = this.rpTreeCache[offset];
    if (rpTree) {
      return rpTree;
    } else {
      rpTree = new RPTree(offset, this.config, this.littleEndian);
      await rpTree.load();
      this.rpTreeCache[offset] = rpTree;
      return rpTree;
    }
  }

  async getType() {
    await this.loadHeader();
    return this.type;
  }

  async getTrackType() {
    await this.loadHeader();
    if (this.type === "bigwig") {
      return "wig";
    } else {
      return this.autoSql && this.autoSql.table === "chromatinInteract" ? "interact" : "annotation";
    }
  }

  setDefaultVisibilityWindow(header) {
    if (this.type === "bigwig") {
      this.visibilityWindow = -1;
    } else {
      // bigbed
      let genomeSize = this.genome ? this.genome.getGenomeLength() : 3088286401;
      // Estimate window size to return ~ 1,000 features, assuming even distribution across the genome
      this.visibilityWindow = header.dataCount < 1000 ? -1 : 1000 * (genomeSize / header.dataCount);

    }
  }
}


class ZoomLevelHeader {
  constructor(index, byteBuffer) {
    this.index = index;
    this.reductionLevel = byteBuffer.getInt();
    this.reserved = byteBuffer.getInt();
    this.dataOffset = byteBuffer.getLong();
    this.indexOffset = byteBuffer.getLong();
  }
}

class RPTree {

  constructor(fileOffset, config, littleEndian) {

    this.config = config;
    this.fileOffset = fileOffset; // File offset to beginning of tree
    this.path = config.url;
    this.littleEndian = littleEndian;
  }

  async load() {
    const rootNodeOffset = this.fileOffset + RPTREE_HEADER_SIZE;
    const bufferedReader = new BufferedReader(this.config, BUFFER_SIZE);
    this.rootNode = await this.readNode(rootNodeOffset, bufferedReader);
    return this;
  }

  async readNode(filePosition, bufferedReader) {

    let dataView = await bufferedReader.dataViewForRange({ start: filePosition, size: 4 }, false);
    let binaryParser = new BinaryParser$1(dataView, this.littleEndian);
    const type = binaryParser.getByte();
    const isLeaf = (type === 1);
    binaryParser.getByte();
    const count = binaryParser.getUShort();
    filePosition += 4;

    let bytesRequired = count * (isLeaf ? RPTREE_NODE_LEAF_ITEM_SIZE : RPTREE_NODE_CHILD_ITEM_SIZE);
    let range2 = { start: filePosition, size: bytesRequired };
    dataView = await bufferedReader.dataViewForRange(range2, false);
    const items = new Array(count);
    binaryParser = new BinaryParser$1(dataView);

    if (isLeaf) {
      for (let i = 0; i < count; i++) {
        let item = {
          isLeaf: true,
          startChrom: binaryParser.getInt(),
          startBase: binaryParser.getInt(),
          endChrom: binaryParser.getInt(),
          endBase: binaryParser.getInt(),
          dataOffset: binaryParser.getLong(),
          dataSize: binaryParser.getLong()
        };
        items[i] = item;

      }
      return new RPTreeNode(items);
    } else { // non-leaf
      for (let i = 0; i < count; i++) {

        let item = {
          isLeaf: false,
          startChrom: binaryParser.getInt(),
          startBase: binaryParser.getInt(),
          endChrom: binaryParser.getInt(),
          endBase: binaryParser.getInt(),
          childOffset: binaryParser.getLong()
        };
        items[i] = item;
      }

      return new RPTreeNode(items);
    }

  }

  async findLeafItemsOverlapping(chrIdx1, startBase, chrIdx2, endBase) {

    let self = this;

    return new Promise(function (fulfill, reject) {

      let leafItems = [],
        processing = new Set(),
        bufferedReader = new BufferedReader(self.config, BUFFER_SIZE);

      processing.add(0);  // Zero represents the root node
      findLeafItems(self.rootNode, 0);

      function findLeafItems(node, nodeId) {

        if (overlaps(node, chrIdx1, startBase, chrIdx2, endBase)) {

          let items = node.items;

          items.forEach(function (item) {

            if (overlaps(item, chrIdx1, startBase, chrIdx2, endBase)) {

              if (item.isLeaf) {
                leafItems.push(item);
              } else {
                if (item.childNode) {
                  findLeafItems(item.childNode);
                } else {
                  processing.add(item.childOffset);  // Represent node to-be-loaded by its file position

                  self.readNode(item.childOffset, bufferedReader)
                    .then(function (node) {
                      item.childNode = node;
                      findLeafItems(node, item.childOffset);
                    })
                    .catch(reject);
                }
              }
            }
          });

        }

        if (nodeId !== undefined) processing.delete(nodeId);

        // Wait until all nodes are processed
        if (processing.size === 0) {
          fulfill(leafItems);
        }
      }
    });
  }
}

class RPTreeNode {

  constructor(items) {

    this.items = items;

    let minChromId = Number.MAX_SAFE_INTEGER,
      maxChromId = 0,
      minStartBase = Number.MAX_SAFE_INTEGER,
      maxEndBase = 0,
      i,
      item;

    for (i = 0; i < items.length; i++) {
      item = items[i];
      minChromId = Math.min(minChromId, item.startChrom);
      maxChromId = Math.max(maxChromId, item.endChrom);
      minStartBase = Math.min(minStartBase, item.startBase);
      maxEndBase = Math.max(maxEndBase, item.endBase);
    }

    this.startChrom = minChromId;
    this.endChrom = maxChromId;
    this.startBase = minStartBase;
    this.endBase = maxEndBase;
  }
}

class BPTree {

  constructor(binaryParser, startOffset, genome) {

    let magic = binaryParser.getInt();
    let blockSize = binaryParser.getInt();
    let keySize = binaryParser.getInt();
    let valSize = binaryParser.getInt();
    let itemCount = binaryParser.getLong();
    let reserved = binaryParser.getLong();
    let chromToId = {};
    let idToChrom = [];

    this.header = {
      magic: magic,
      blockSize: blockSize,
      keySize: keySize,
      valSize: valSize,
      itemCount: itemCount,
      reserved: reserved
    };
    this.chromToID = chromToId;
    this.idToChrom = idToChrom;

    // Recursively walk tree to populate dictionary
    readTreeNode(binaryParser, -1);


    function readTreeNode(byteBuffer, offset) {

      if (offset >= 0) byteBuffer.position = offset;

      let type = byteBuffer.getByte();
      byteBuffer.getByte();
      let count = byteBuffer.getUShort(),
        i,
        key,
        chromId,
        childOffset,
        bufferOffset,
        currOffset;


      if (type === 1) {

        for (i = 0; i < count; i++) {

          key = byteBuffer.getFixedLengthTrimmedString(keySize);
          chromId = byteBuffer.getInt();
          byteBuffer.getInt();

          if (genome) key = genome.getChromosomeName(key);  // Translate to canonical chr name
          chromToId[key] = chromId;
          idToChrom[chromId] = key;

        }
      } else { // non-leaf

        for (i = 0; i < count; i++) {

          key = byteBuffer.getFixedLengthTrimmedString(keySize);
          childOffset = byteBuffer.getLong();
          bufferOffset = childOffset - startOffset;
          currOffset = byteBuffer.position;
          readTreeNode(byteBuffer, bufferOffset);
          byteBuffer.position = currOffset;
        }
      }

    }
  }
}

/**
* Return true if {chrIdx1:startBase-chrIdx2:endBase} overlaps item's interval
* @returns {boolean}
*/
function overlaps(item, chrIdx1, startBase, chrIdx2, endBase) {

  if (!item) {
    console.log("null item for " + chrIdx1 + " " + startBase + " " + endBase);
    return false;
  }

  return ((chrIdx2 > item.startChrom) || (chrIdx2 === item.startChrom && endBase >= item.startBase)) &&
    ((chrIdx1 < item.endChrom) || (chrIdx1 === item.endChrom && startBase <= item.endBase));


}

class BWTotalSummary {

  constructor(byteBuffer) {
    if (byteBuffer) {
      this.basesCovered = byteBuffer.getLong();
      this.minVal = byteBuffer.getDouble();
      this.maxVal = byteBuffer.getDouble();
      this.sumData = byteBuffer.getDouble();
      this.sumSquares = byteBuffer.getDouble();
      computeStats.call(this);
    } else {
      this.basesCovered = 0;
      this.minVal = 0;
      this.maxVal = 0;
      this.sumData = 0;
      this.sumSquares = 0;
      this.mean = 0;
      this.stddev = 0;
    }
  }
}

function computeStats() {
  let n = this.basesCovered;
  if (n > 0) {
    this.mean = this.sumData / n;
    this.stddev = Math.sqrt(this.sumSquares / (n - 1));

    let min = this.minVal < 0 ? this.mean - 2 * this.stddev : 0,
      max = this.maxVal > 0 ? this.mean + 2 * this.stddev : 0;

    this.defaultRange = {
      min: min,
      max: max
    };
  }
}

function zoomLevelForScale$1(bpPerPixel, zoomLevelHeaders) {
  let level;
  for (let i = 0; i < zoomLevelHeaders.length; i++) {
    const zl = zoomLevelHeaders[i];
    if (zl.reductionLevel < bpPerPixel) {
      level = zl;
      break;
    }
  }
  return level;
}


function decodeWigData(data, chrIdx1, bpStart, chrIdx2, bpEnd, featureArray, chrDict) {

  const binaryParser = new BinaryParser$1(data);
  const chromId = binaryParser.getInt();
  let chromStart = binaryParser.getInt();
  let chromEnd = binaryParser.getInt();
  const itemStep = binaryParser.getInt();
  const itemSpan = binaryParser.getInt();
  const type = binaryParser.getByte();
  binaryParser.getByte();
  let itemCount = binaryParser.getUShort();

  if (chromId >= chrIdx1 && chromId <= chrIdx2) {

    while (itemCount-- > 0) {
      let value;
      switch (type) {
        case 1:
          chromStart = binaryParser.getInt();
          chromEnd = binaryParser.getInt();
          value = binaryParser.getFloat();
          break;
        case 2:
          chromStart = binaryParser.getInt();
          value = binaryParser.getFloat();
          chromEnd = chromStart + itemSpan;
          break;
        case 3:  // Fixed step
          value = binaryParser.getFloat();
          chromEnd = chromStart + itemSpan;
          chromStart += itemStep;
          break;
      }

      if (chromId < chrIdx1 || (chromId === chrIdx1 && chromEnd < bpStart)) continue;
      else if (chromId > chrIdx2 || (chromId === chrIdx2 && chromStart >= bpEnd)) break;

      if (Number.isFinite(value)) {
        const chr = chrDict[chromId];
        featureArray.push({ chr: chr, start: chromStart, end: chromEnd, value: value });

      }
    }
  }
}

function getBedDataDecoder() {

  const minSize = 3 * 4 + 1;   // Minimum # of bytes required for a bed record
  const decoder = getDecoder(this.header.definedFieldCount, this.header.fieldCount, this.autoSql);
  return function (data, chrIdx1, bpStart, chrIdx2, bpEnd, featureArray, chrDict) {
    const binaryParser = new BinaryParser$1(data);
    while (binaryParser.remLength() >= minSize) {

      const chromId = binaryParser.getInt();
      const chr = chrDict[chromId];
      const chromStart = binaryParser.getInt();
      const chromEnd = binaryParser.getInt();
      const rest = binaryParser.getString();
      if (chromId < chrIdx1 || (chromId === chrIdx1 && chromEnd < bpStart)) continue;
      else if (chromId > chrIdx2 || (chromId === chrIdx2 && chromStart >= bpEnd)) break;

      if (chromEnd > 0) {
        const feature = { chr: chr, start: chromStart, end: chromEnd };
        featureArray.push(feature);
        const tokens = rest.split("\t");
        decoder(feature, tokens);
      }
    }
  }
}


function decodeZoomData(data, chrIdx1, bpStart, chrIdx2, bpEnd, featureArray, chrDict, windowFunction) {

  const binaryParser = new BinaryParser$1(data);
  const minSize = 8 * 4;  // Minimum # of bytes required for a zoom record


  while (binaryParser.remLength() >= minSize) {
    const chromId = binaryParser.getInt();
    const chr = chrDict[chromId];
    const chromStart = binaryParser.getInt();
    const chromEnd = binaryParser.getInt();
    const validCount = binaryParser.getInt();
    const minVal = binaryParser.getFloat();
    const maxVal = binaryParser.getFloat();
    const sumData = binaryParser.getFloat();
    binaryParser.getFloat();
    let value;
    switch (windowFunction) {
      case "min":
        value = minVal;
        break;
      case "max":
        value = maxVal;
        break;
      default:
        value = validCount === 0 ? 0 : sumData / validCount;
    }

    if (chromId < chrIdx1 || (chromId === chrIdx1 && chromEnd < bpStart)) continue;
    else if (chromId > chrIdx2 || (chromId === chrIdx2 && chromStart >= bpEnd)) break;


    if (Number.isFinite(value)) {
      featureArray.push({ chr: chr, start: chromStart, end: chromEnd, value: value });


    }
  }
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

class BWSource {

  constructor(config, genome) {
    this.reader = new BWReader(config, genome);
    this.genome = genome;
    this.format = config.format || "bigwig";
    this.wgValues = {};
  }

  async getFeatures({ chr, start, end, bpPerPixel, windowFunction }) {

    const features = (chr.toLowerCase() === "all") ?
      await this.getWGValues(windowFunction) :
      await this.reader.readFeatures(chr, start, chr, end, bpPerPixel, windowFunction);

    const isBigWig = this.reader.type === "bigwig";
    if (!isBigWig) {
      pack(features);
    }
    return features;
  }

  async getHeader() {
    return this.reader.loadHeader();
  }

  getDefaultRange() {
    if (this.reader.totalSummary !== undefined) {
      return this.reader.totalSummary.defaultRange;
    } else {
      return undefined;
    }
  }

  async defaultVisibilityWindow() {
    return this.reader.defaultVisibilityWindow;
  }

  async getWGValues(windowFunction) {

    const nominalScreenWidth = 1000;      // This doesn't need to be precise
    const genome = this.genome;

    if (this.wgValues[windowFunction]) {
      return this.wgValues[windowFunction];
    } else {

      const bpPerPixel = genome.getGenomeLength() / nominalScreenWidth;
      const features = await this.reader.readWGFeatures(bpPerPixel, windowFunction);
      let wgValues = [];
      for (let f of features) {
        const chr = f.chr;
        const offset = genome.getCumulativeOffset(chr);
        const wgFeature = Object.assign({}, f);
        wgFeature.chr = "all";
        wgFeature.start = offset + f.start;
        wgFeature.end = offset + f.end;
        wgValues.push(wgFeature);
      }
      this.wgValues[windowFunction] = wgValues;
      return wgValues;
    }
  }

  supportsWholeGenome() {
    return this.reader.type === "bigwig" || this.defaultVisibilityWindow() <= 0;
  }

  async trackType() {
    return this.reader.getTrackType();
  }
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2016 University of California San Diego
* Author: Jim Robinson
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

const GZIP_FLAG = 0x1;

class TDFReader {

  constructor(config, genome) {
    this.config = config;
    this.genome = genome;
    this.path = config.url;
    this.groupCache = {};
    this.datasetCache = {};
  }


  async readHeader() {

    if (this.magic !== undefined) {
      return this;   // Already read
    }

    let data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, { range: { start: 0, size: 64000 } }));
    let binaryParser = new BinaryParser$1(new DataView(data));
    this.magic = binaryParser.getInt();
    this.version = binaryParser.getInt();
    this.indexPos = binaryParser.getLong();
    this.indexSize = binaryParser.getInt();
    binaryParser.getInt();


    if (this.version >= 2) {
      let nWindowFunctions = binaryParser.getInt();
      this.windowFunctions = [];
      while (nWindowFunctions-- > 0) {
        this.windowFunctions.push(binaryParser.getString());
      }
    }

    this.trackType = binaryParser.getString();
    this.trackLine = binaryParser.getString();

    let nTracks = binaryParser.getInt();
    this.trackNames = [];
    while (nTracks-- > 0) {
      this.trackNames.push(binaryParser.getString());
    }
    this.genomeID = binaryParser.getString();
    this.flags = binaryParser.getInt();
    this.compressed = (this.flags & GZIP_FLAG) !== 0;

    // Now read index
    data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
      range: {
        start: this.indexPos,
        size: this.indexSize
      }
    }));
    binaryParser = new BinaryParser$1(new DataView(data));
    this.datasetIndex = {};
    let nEntries = binaryParser.getInt();
    while (nEntries-- > 0) {
      const name = binaryParser.getString();
      const pos = binaryParser.getLong();
      const size = binaryParser.getInt();
      this.datasetIndex[name] = { position: pos, size: size };
    }

    this.groupIndex = {};
    nEntries = binaryParser.getInt();
    while (nEntries-- > 0) {
      const name = binaryParser.getString();
      const pos = binaryParser.getLong();
      const size = binaryParser.getInt();
      this.groupIndex[name] = { position: pos, size: size };
    }

    return this;
  }

  async readDataset(chr, windowFunction, zoom) {

    const key = chr + "_" + windowFunction + "_" + zoom;

    if (this.datasetCache[key]) {
      return this.datasetCache[key];

    } else {
      await this.readHeader();
      const wf = (this.version < 2) ? "" : "/" + windowFunction;
      const zoomString = (chr.toLowerCase() === "all" || zoom === undefined) ? "0" : zoom.toString();

      let dsName;
      if (windowFunction === "raw") {
        dsName = "/" + chr + "/raw";
      } else {
        dsName = "/" + chr + "/z" + zoomString + wf;
      }
      const indexEntry = this.datasetIndex[dsName];

      if (indexEntry === undefined) {
        return undefined;
      }

      const data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
        range: {
          start: indexEntry.position,
          size: indexEntry.size
        }
      }));

      if (!data) {
        return undefined;
      }

      const binaryParser = new BinaryParser$1(new DataView(data));
      let nAttributes = binaryParser.getInt();
      const attributes = {};
      while (nAttributes-- > 0) {
        attributes[binaryParser.getString()] = binaryParser.getString();
      }
      const dataType = binaryParser.getString();
      const tileWidth = binaryParser.getFloat();
      let nTiles = binaryParser.getInt();
      const tiles = [];
      while (nTiles-- > 0) {
        tiles.push({ position: binaryParser.getLong(), size: binaryParser.getInt() });
      }

      const dataset = {
        name: dsName,
        attributes: attributes,
        dataType: dataType,
        tileWidth: tileWidth,
        tiles: tiles
      };

      this.datasetCache[key] = dataset;
      return dataset;
    }
  }

  async readRootGroup() {

    const genome = this.genome;
    const rootGroup = this.groupCache["/"];
    if (rootGroup) {
      return rootGroup;
    } else {

      const group = await this.readGroup("/");
      const names = group["chromosomes"];
      const maxZoomString = group["maxZoom"];

      // Now parse out interesting attributes.
      if (maxZoomString) {
        this.maxZoom = Number(maxZoomString);
      }

      const totalCountString = group["totalCount"];
      if (totalCountString) {
        group.totalCount = Number.parseFloat(totalCountString);
      }

      // Chromosome names
      const chrAliasTable = {};
      if (names) {
        names.split(",").forEach(function (chr) {
          const canonicalName = genome.getChromosomeName(chr);
          chrAliasTable[canonicalName] = chr;
        });
      }
      this.chrAliasTable = chrAliasTable;

      this.groupCache["/"] = group;
      return group;
    }
  }

  async readGroup(name) {

    const group = this.groupCache[name];
    if (group) {
      return group;
    } else {

      await this.readHeader();
      const indexEntry = this.groupIndex[name];
      if (indexEntry === undefined) {
        return undefined;
      }

      const data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
        range: {
          start: indexEntry.position,
          size: indexEntry.size
        }
      }));

      if (!data) {
        return undefined;
      }

      const binaryParser = new BinaryParser$1(new DataView(data));
      const group = { name: name };
      let nAttributes = binaryParser.getInt();
      while (nAttributes-- > 0) {
        const key = binaryParser.getString();
        const value = binaryParser.getString();
        group[key] = value;
      }
      this.groupCache[name] = group;
      return group;
    }
  }


  async readTiles(tileIndeces, nTracks) {

    tileIndeces.sort(function (a, b) {
      return a.position - b.position;
    });

    tileIndeces = tileIndeces.filter(function (idx) {
      return idx.size > 0;
    });

    if (tileIndeces.length === 0) {
      return Promise.resolve([]);
    }

    const firstEntry = tileIndeces[0];
    const lastEntry = tileIndeces[tileIndeces.length - 1];
    const position = firstEntry.position;
    const size = (lastEntry.position + lastEntry.size) - position;
    const data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
      range: {
        start: position,
        size: size
      }
    }));

    const tiles = [];

    // Loop through and decode tiles
    for (let indexEntry of tileIndeces) {
      const start = indexEntry.position - position;
      const size = indexEntry.size;
      if (size > 0) {
        let tileData;
        if (this.compressed) {
          const inflate = new Zlib$2.Inflate(new Uint8Array(data, start, size));
          const plain = inflate.decompress();
          tileData = plain.buffer;
        } else {
          tileData = data.slice(start, start + size);
        }

        const binaryParser = new BinaryParser$1(new DataView(tileData));
        const type = binaryParser.getString();
        let tile;
        switch (type) {
          case "fixedStep":
            tile = createFixedStep(binaryParser, nTracks);
            break;
          case "variableStep":
            tile = createVariableStep(binaryParser, nTracks);
            break;
          case "bed":
          case "bedWithName":
            tile = createBed(binaryParser, nTracks, type);
            break;
          default:
            throw "Unknown tile type: " + type;
        }
        tiles.push(tile);
      }
    }
    return tiles;
  }

  async readTile(indexEntry, nTracks) {

    let data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
      range: {
        start: indexEntry.position,
        size: indexEntry.size
      }
    }));

    if (this.compressed) {
      const inflate = new Zlib$2.Inflate(new Uint8Array(data));
      const plain = inflate.decompress();
      data = plain.buffer;
    }

    const binaryParser = new BinaryParser$1(new DataView(data));
    const type = binaryParser.getString();
    switch (type) {
      case "fixedStep":
        return createFixedStep(binaryParser, nTracks);
      case "variableStep":
        return createVariableStep(binaryParser, nTracks);
      case "bed":
      case "bedWithName":
        return createBed(binaryParser, nTracks, type);
      default:
        throw "Unknown tile type: " + type;
    }
  }

}

function createFixedStep(binaryParser, nTracks) {
  const nPositions = binaryParser.getInt();
  const start = binaryParser.getInt();
  const span = binaryParser.getFloat();

  const data = [];
  let nt = nTracks;
  while (nt-- > 0) {
    let np = nPositions;
    const dtrack = [];
    while (np-- > 0) {
      dtrack.push(binaryParser.getFloat());
    }
    data.push(dtrack);
  }

  return {
    type: "fixedStep",
    start: start,
    span: span,
    data: data,
    nTracks: nTracks,
    nPositions: nPositions
  }
}

function createVariableStep(binaryParser, nTracks) {

  const tileStart = binaryParser.getInt();
  const span = binaryParser.getFloat();
  const nPositions = binaryParser.getInt();
  const start = [];

  let np = nPositions;
  while (np-- > 0) {
    start.push(binaryParser.getInt());
  }
  binaryParser.getInt();  // # of samples, ignored but should === nTracks

  const data = [];
  let nt = nTracks;
  while (nt-- > 0) {
    np = nPositions;
    const dtrack = [];
    while (np-- > 0) {
      dtrack.push(binaryParser.getFloat());
    }
    data.push(dtrack);
  }

  return {
    type: "variableStep",
    tileStart: tileStart,
    span: span,
    start: start,
    data: data,
    nTracks: nTracks,
    nPositions: nPositions
  }
}

function createBed(binaryParser, nTracks, type) {

  const nPositions = binaryParser.getInt();

  let n = nPositions;
  const start = [];
  while (n-- > 0) {
    start.push(binaryParser.getInt());
  }

  n = nPositions;
  const end = [];
  while (n-- > 0) {
    end.push(binaryParser.getInt());
  }

  binaryParser.getInt();  // # of samples, ignored but should === nTracks
  const data = [];
  let nt = nTracks;
  while (nt-- > 0) {
    let np = nPositions;
    const dtrack = [];
    while (np-- > 0) {
      dtrack.push(binaryParser.getFloat());
    }
    data.push(dtrack);
  }

  if (type === "bedWithName") {
    n = nPositions;
    const name = [];
    while (n-- > 0) {
      name.push(binaryParser.getString());
    }
  }

  return {
    type: type,
    start: start,
    end: end,
    data: data,
    nTracks: nTracks,
    nPositions: nPositions
  }

}

/*
* The MIT License (MIT)
*
* Copyright (c) 2016 University of California San Diego
* Author: Jim Robinson
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

class TDFSource {

  constructor(config, genome) {
    this.genome = genome;
    this.windowFunction = config.windowFunction || "mean";
    this.reader = new TDFReader(config, genome);
  }

  async getFeatures({ chr, start, end, bpPerPixel }) {

    const genomicInterval = new GenomicInterval(chr, start, end);
    const genome = this.genome;


    if (!this.rootGroup) {
      this.rootGroup = await this.reader.readRootGroup();
      if (!this.normalizationFactor) {
        const totalCount = this.rootGroup.totalCount;
        if (totalCount) {
          this.normalizationFactor = 1.0e6 / totalCount;
        }
      }
    }

    if (chr.toLowerCase() === "all") {
      return [];      // Whole genome view not yet supported
    }

    genomicInterval.bpPerPixel = bpPerPixel;
    const zoom = zoomLevelForScale(chr, bpPerPixel, genome);
    let queryChr = this.reader.chrAliasTable[chr];
    let maxZoom = this.reader.maxZoom;
    if (queryChr === undefined) queryChr = chr;
    if (maxZoom === undefined) maxZoom = -1;

    const wf = zoom > maxZoom ? "raw" : this.windowFunction;
    const dataset = await this.reader.readDataset(queryChr, wf, zoom);
    if (dataset == null) {
      return [];
    }

    const tileWidth = dataset.tileWidth;
    const startTile = Math.floor(start / tileWidth);
    const endTile = Math.floor(end / tileWidth);
    const NTRACKS = 1;   // TODO read this
    const tiles = await this.reader.readTiles(dataset.tiles.slice(startTile, endTile + 1), NTRACKS);
    const features = [];
    for (let tile of tiles) {
      switch (tile.type) {
        case "bed":
          decodeBedTile(tile, chr, start, end, bpPerPixel, features);
          break;
        case "variableStep":
          decodeVaryTile(tile, chr, start, end, bpPerPixel, features);
          break;
        case "fixedStep":
          decodeFixedTile(tile, chr, start, end, bpPerPixel, features);
          break;
        default:
          throw ("Unknown tile type: " + tile.type);
      }
    }
    features.sort(function (a, b) {
      return a.start - b.start;
    });

    return features;
  }

  supportsWholeGenome() {
    return false;
  }
}

function decodeBedTile(tile, chr, bpStart, bpEnd, bpPerPixel, features) {

  const nPositions = tile.nPositions;
  const starts = tile.start;
  const ends = tile.end;
  const data = tile.data[0];   // Single track for now
  for (let i = 0; i < nPositions; i++) {
    const s = starts[i];
    const e = ends[i];
    if (e < bpStart) continue;
    if (s > bpEnd) break;
    features.push({
      chr: chr,
      start: s,
      end: e,
      value: data[i]
    });
  }
}

function decodeVaryTile(tile, chr, bpStart, bpEnd, bpPerPixel, features) {

  const nPositions = tile.nPositions;
  const starts = tile.start;
  const span = tile.span;
  const data = tile.data[0];   // Single track for now
  for (let i = 0; i < nPositions; i++) {
    const s = starts[i];
    const e = s + span;
    if (e < bpStart) continue;
    if (s > bpEnd) break;
    features.push({
      chr: chr,
      start: s,
      end: e,
      value: data[i]
    });
  }
}

function decodeFixedTile(tile, chr, bpStart, bpEnd, bpPerPixel, features) {

  const nPositions = tile.nPositions;
  let s = tile.start;
  const span = tile.span;
  const data = tile.data[0];   // Single track for now

  for (let i = 0; i < nPositions; i++) {
    const e = s + span;
    if (s > bpEnd) break;
    if (e >= bpStart) {
      if (!Number.isNaN(data[i])) {
        features.push({
          chr: chr,
          start: s,
          end: e,
          value: data[i]
        });
      }
    }
    s = e;
  }
}


var log2 = Math.log(2);

function zoomLevelForScale(chr, bpPerPixel, genome) {

  // Convert bpPerPixel to IGV "zoom" level.   This is a bit convoluted,  IGV computes zoom levels assuming
  // display in a 700 pixel window.  The fully zoomed out view of a chromosome is zoom level "0".
  // Zoom level 1 is magnified 2X,  and so forth

  var chrSize = genome.getChromosome(chr).bpLength;

  return Math.ceil(Math.log(Math.max(0, (chrSize / (bpPerPixel * 700)))) / log2);
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014-2015 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/


function FeatureSource(config, genome) {

  const format = config.format ? config.format.toLowerCase() : undefined;
  if ('bigwig' === format || 'bigbed' === format || 'bb' === format) {
    return new BWSource(config, genome);
  } else if ("tdf" === format) {
    return new TDFSource(config, genome);
  } else {
    return new TextFeatureSource(config, genome);
  }
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of ctx software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and ctx permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/


const IGVGraphics = {
  setProperties: function (ctx, properties) {
    ctx.imageSmoothingEnabled = false;
    for (var key in properties) {
      if (properties.hasOwnProperty(key)) {
        var value = properties[key];
        ctx[key] = value;
      }
    }
  },

  strokeLine: function (ctx, x1, y1, x2, y2, properties) {


    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    x2 = Math.floor(x2) + 0.5;
    y2 = Math.floor(y2) + 0.5;

    if (properties) {
      ctx.save();
      IGVGraphics.setProperties(ctx, properties);
    }

    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    if (properties) ctx.restore();
  },

  fillRect: function (ctx, x, y, w, h, properties) {
    x = Math.round(x);
    y = Math.round(y);

    if (properties) {
      ctx.save();
      IGVGraphics.setProperties(ctx, properties);
    }

    ctx.fillRect(x, y, w, h);

    if (properties) ctx.restore();
  },

  fillPolygon: function (ctx, x, y, properties) {
    if (properties) {
      ctx.save();
      IGVGraphics.setProperties(ctx, properties);
    }
    doPath(ctx, x, y);
    ctx.fill();
    if (properties) ctx.restore();
  },

  strokePolygon: function (ctx, x, y, properties) {
    if (properties) {
      ctx.save();
      IGVGraphics.setProperties(ctx, properties);
    }
    doPath(ctx, x, y);
    ctx.stroke();
    if (properties) ctx.restore();
  },

  fillText: function (ctx, text, x, y, properties, transforms) {

    if (properties || transforms) {
      ctx.save();
    }

    if (properties) {
      IGVGraphics.setProperties(ctx, properties);
    }

    if (transforms) {
      // Slow path with context saving and extra translate
      ctx.translate(x, y);

      for (var transform in transforms) {
        var value = transforms[transform];

        // TODO: Add error checking for robustness
        if (transform === 'translate') {
          ctx.translate(value['x'], value['y']);
        }
        if (transform === 'rotate') {
          ctx.rotate(value['angle'] * Math.PI / 180);
        }
      }

      ctx.fillText(text, 0, 0);
    } else {
      ctx.fillText(text, x, y);
    }

    if (properties || transforms) ctx.restore();
  },

  strokeText: function (ctx, text, x, y, properties, transforms) {


    if (properties || transforms) {
      ctx.save();
    }

    if (properties) {
      IGVGraphics.setProperties(ctx, properties);
    }

    if (transforms) {
      ctx.translate(x, y);

      for (var transform in transforms) {
        var value = transforms[transform];

        // TODO: Add error checking for robustness
        if (transform === 'translate') {
          ctx.translate(value['x'], value['y']);
        }
        if (transform === 'rotate') {
          ctx.rotate(value['angle'] * Math.PI / 180);
        }
      }

      ctx.strokeText(text, 0, 0);
    } else {
      ctx.strokeText(text, x, y);
    }

    if (properties || transforms) ctx.restore();
  },

  strokeCircle: function (ctx, x, y, radius, properties) {
    if (properties) {
      ctx.save();
      IGVGraphics.setProperties(ctx, properties);
    }
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, 2 * Math.PI);
    ctx.stroke();
    if (properties) ctx.restore();
  },

  fillCircle: function (ctx, x, y, radius, properties) {
    if (properties) {
      ctx.save();
      IGVGraphics.setProperties(ctx, properties);
    }
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, 2 * Math.PI);
    ctx.fill();
    if (properties) ctx.restore();
  },

  drawArrowhead: function (ctx, x, y, size, lineWidth) {

    ctx.save();
    if (!size) {
      size = 5;
    }
    if (lineWidth) {
      ctx.lineWidth = lineWidth;
    }
    ctx.beginPath();
    ctx.moveTo(x, y - size / 2);
    ctx.lineTo(x, y + size / 2);
    ctx.lineTo(x + size, y);
    ctx.lineTo(x, y - size / 2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  },

  dashedLine: function (ctx, x1, y1, x2, y2, dashLen, properties = {}) {
    console.log(1);
    if (dashLen === undefined) dashLen = 2;
    ctx.setLineDash([dashLen, dashLen]);
    IGVGraphics.strokeLine(ctx, x1, y1, x2, y2, properties);
    ctx.setLineDash([]);
  },

  roundRect: function (ctx, x, y, width, height, radius, fill, stroke) {

    if (typeof stroke == "undefined") {
      stroke = true;
    }
    if (typeof radius === "undefined") {
      radius = 5;
    }
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    if (stroke) {
      ctx.stroke();
    }
    if (fill) {
      ctx.fill();
    }
  },
  polygon: function (ctx, x, y, fill, stroke) {

    if (typeof stroke == "undefined") {
      stroke = true;
    }

    ctx.beginPath();
    var len = x.length;
    ctx.moveTo(x[0], y[0]);
    for (var i = 1; i < len; i++) {
      ctx.lineTo(x[i], y[i]);
      // this.moveTo(x[i], y[i]);
    }

    ctx.closePath();
    if (stroke) {
      ctx.stroke();
    }
    if (fill) {
      ctx.fill();
    }
  }


};

function doPath(ctx, x, y) {


  var i, len = x.length;
  for (i = 0; i < len; i++) {
    x[i] = Math.round(x[i]);
    y[i] = Math.round(y[i]);
  }

  ctx.beginPath();
  ctx.moveTo(x[0], y[0]);
  for (i = 1; i < len; i++) {
    ctx.lineTo(x[i], y[i]);
  }
  ctx.closePath();
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/


let JUNCTION_MOTIF_PALETTE = new PaletteColorTable("Dark2");

// Lock in color-to-motif mapping so it's independent of data loading order. This list may not include all possible
// motif values as this varies depending on the RNA-seq pipeline. The current list is based on STAR v2.4 docs.
const someMotifValues = ['GT/AG', 'CT/AC', 'GC/AG', 'CT/GC', 'AT/AC', 'GT/AT', 'non-canonical'];
someMotifValues.forEach(motif => {
  JUNCTION_MOTIF_PALETTE.getColor(motif);
});

// rendering context with values that only need to be computed once per render, rather than for each splice junction
const junctionRenderingContext = {};

class FeatureTrack extends TrackBase {

  constructor(config, browser) {

    super(config, browser);

    // Set maxRows -- protects against pathological feature packing cases (# of rows of overlapping feaures)
    this.maxRows = config.maxRows === undefined ? 1000 : config.maxRows;
    this.displayMode = config.displayMode || "COLLAPSED";    // COLLAPSED | EXPANDED | SQUISHED
    this.labelDisplayMode = config.labelDisplayMode;

    if (config._featureSource) {
      this.featureSource = config._featureSource;
      delete config._featureSource;
    } else {
      this.featureSource = config.featureSource ?
        config.featureSource :
        FeatureSource(config, browser.genome);
    }

    // Set default heights
    this.autoHeight = config.autoHeight;
    this.margin = config.margin === undefined ? 10 : config.margin;

    this.featureHeight = config.featureHeight || 14;

    if ("FusionJuncSpan" === config.type) {
      this.squishedRowHeight = config.squishedRowHeight || 50;
      this.expandedRowHeight = config.expandedRowHeight || 50;
      this.height = config.height || this.margin + 2 * this.expandedRowHeight;
    } else if ('snp' === config.type) {
      this.expandedRowHeight = config.expandedRowHeight || 10;
      this.squishedRowHeight = config.squishedRowHeight || 5;
      this.height = config.height || 30;
    } else {
      this.squishedRowHeight = config.squishedRowHeight || 15;
      this.expandedRowHeight = config.expandedRowHeight || 30;
      this.height = config.height || this.margin + 2 * this.expandedRowHeight;
    }

    if (this.height === undefined || !this.height) {
      this.height = 100;
    }

    //set defaults
    if (('spliceJunctions' === config.type)
      && config.colorByNumReadsThreshold === undefined) {
      config.colorByNumReadsThreshold = 5;
    }

    // Set the render function.  This can optionally be passed in the config
    if (config.render) {
      this.render = config.render;
    } else if ("FusionJuncSpan" === config.type) {
      this.render = renderFusionJuncSpan;
    } else if ('spliceJunctions' === config.type) {
      this.render = renderJunctions;
      this.displayMode = "COLLAPSED";  // needed for this.clickedFeatures(..) to work
    } else if ('snp' === config.type) {
      this.render = renderSnp;
      // colors ordered based on priority least to greatest
      this.snpColors = ['rgb(0,0,0)', 'rgb(0,0,255)', 'rgb(0,255,0)', 'rgb(255,0,0)'];
      this.colorBy = 'function';
    } else {
      this.render = renderFeature;
      this.arrowSpacing = 30;
      // adjust label positions to make sure they're always visible
      monitorTrackDrag(this);
    }

    //UCSC useScore option
    this.useScore = config.useScore;

  }

  async postInit() {

    if (typeof this.featureSource.getHeader === "function") {
      this.header = await this.featureSource.getHeader();
    }

    // Set properties from track line
    if (this.header) {
      this.setTrackProperties(this.header);
    }

    if (this.visibilityWindow === undefined && typeof this.featureSource.defaultVisibilityWindow === 'function') {
      this.visibilityWindow = await this.featureSource.defaultVisibilityWindow();
      this.featureSource.visibilityWindow = this.visibilityWindow;   // <- this looks odd
    }

    return this;

  }

  supportsWholeGenome() {
    return (this.config.indexed === false || !this.config.indexURL) && this.config.supportsWholeGenome !== false
  }

  async getFeatures(chr, start, end, bpPerPixel) {
    const visibilityWindow = this.visibilityWindow;
    return this.featureSource.getFeatures({ chr, start, end, bpPerPixel, visibilityWindow });
  };


  /**
   * The required height in pixels required for the track content.   This is not the visible track height, which
   * can be smaller (with a scrollbar) or larger.
   *
   * @param features
   * @returns {*}
   */
  computePixelHeight(features) {

    if (this.type === 'spliceJunctions') {
      return this.height;
    } else if (this.displayMode === "COLLAPSED") {
      return this.margin + this.expandedRowHeight;
    } else {
      let maxRow = 0;
      if (features && (typeof features.forEach === "function")) {
        for (let feature of features) {
          if (feature.row && feature.row > maxRow) {
            maxRow = feature.row;
          }
        }
      }

      const height = this.margin + (maxRow + 1) * ("SQUISHED" === this.displayMode ? this.squishedRowHeight : this.expandedRowHeight);
      return height;

    }
  };

  draw(options) {

    const featureList = options.features;
    const ctx = options.context;
    const bpPerPixel = options.bpPerPixel;
    const bpStart = options.bpStart;
    const pixelWidth = options.pixelWidth;
    const pixelHeight = options.pixelHeight;
    const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;


    if (!this.config.isMergedTrack) {
      IGVGraphics.fillRect(ctx, 0, options.pixelTop, pixelWidth, pixelHeight, { 'fillStyle': "rgb(255, 255, 255)" });
    }

    if (featureList) {

      const rowFeatureCount = [];
      options.rowLastX = [];
      for (let feature of featureList) {
        const row = feature.row || 0;
        if (rowFeatureCount[row] === undefined) {
          rowFeatureCount[row] = 1;
        } else {
          rowFeatureCount[row]++;
        }
        options.rowLastX[row] = -Number.MAX_SAFE_INTEGER;
      }

      if (this.config.type == 'spliceJunctions') {
        junctionRenderingContext.referenceFrame = options.viewport.referenceFrame;
        junctionRenderingContext.referenceFrameStart = junctionRenderingContext.referenceFrame.start;
        junctionRenderingContext.referenceFrameEnd = junctionRenderingContext.referenceFrameStart + junctionRenderingContext.referenceFrame.toBP($(options.viewport.contentDiv).width());

        // For a given viewport, records where features that are < 2px in width have been rendered already.
        // This prevents wasteful rendering of multiple such features onto the same pixels.
        junctionRenderingContext.featureZoomOutTracker = {};
      }

      let lastPxEnd = [];
      for (let feature of featureList) {
        if (feature.end < bpStart) continue;
        if (feature.start > bpEnd) break;

        const row = this.displayMode === 'COLLAPSED' ? 0 : feature.row;
        const featureDensity = pixelWidth / rowFeatureCount[row];
        options.drawLabel = options.labelAllFeatures || featureDensity > 10;
        const pxEnd = Math.ceil((feature.end - bpStart) / bpPerPixel);
        const last = lastPxEnd[row];
        if (!last || pxEnd > last || this.config.type === 'spliceJunctions') {
          this.render.call(this, feature, bpStart, bpPerPixel, pixelHeight, ctx, options);

          if (this.config.type !== 'spliceJunctions') {
            // Ensure a visible gap between features
            const pxStart = Math.floor((feature.start - bpStart) / bpPerPixel);
            if (last && pxStart - last <= 0) {
              ctx.globalAlpha = 0.5;
              IGVGraphics.strokeLine(ctx, pxStart, 0, pxStart, pixelHeight, { 'strokeStyle': "rgb(255, 255, 255)" });
              ctx.globalAlpha = 1.0;
            }
            lastPxEnd[row] = pxEnd;
          }
        }
      }

    } else {
      console.log("No feature list");
    }

  };

  clickedFeatures(clickState) {

    const y = clickState.y - this.margin;
    const allFeatures = super.clickedFeatures(clickState);

    let row;
    switch (this.displayMode) {
      case 'SQUISHED':
        row = Math.floor(y / this.squishedRowHeight);
        break;
      case 'EXPANDED':
        row = Math.floor(y / this.expandedRowHeight);
        break;
      default:
        row = undefined;
    }

    return allFeatures.filter(function (feature) {
      return (row === undefined || feature.row === undefined || row === feature.row);
    })
  }

  /**
   * Return "popup data" for feature @ genomic location.  Data is an array of key-value pairs
   */
  popupData(clickState, features) {

    if (!features) features = this.clickedFeatures(clickState);
    const genomicLocation = clickState.genomicLocation;

    const data = [];
    for (let feature of features) {
      if (this.config.type === 'spliceJunctions') {
        if (!feature.isVisible || !feature.attributes) {
          continue
        }
      }
      const featureData = (typeof feature.popupData === "function") ?
        feature.popupData(genomicLocation) :
        TrackBase.extractPopupData(feature, this.getGenomeId());

      if (featureData) {
        if (data.length > 0) {
          data.push("<HR>");
        }

        Array.prototype.push.apply(data, featureData);
      }
    }

    return data;

  }


  menuItemList() {

    const self = this;
    const menuItems = [];

    if (this.render === renderSnp) {
      (["function", "class"]).forEach(function (colorScheme) {
        menuItems.push({
          object: $(createCheckbox$1('Color by ' + colorScheme, colorScheme === self.colorBy)),
          click: function () {
            self.colorBy = colorScheme;
            self.trackView.repaintViews();
          }
        });
      });

      menuItems.push({ object: $('<div class="igv-track-menu-border-top">') });

    }

    return menuItems;
  }

  description() {

    // if('snp' === this.type) {
    if (renderSnp === this.render) {
      let desc = "<html>" + this.name + "<hr>";
      desc += '<em>Color By Function:</em><br>';
      desc += '<span style="color:red">Red</span>: Coding-Non-Synonymous, Splice Site<br>';
      desc += '<span style="color:green">Green</span>: Coding-Synonymous<br>';
      desc += '<span style="color:blue">Blue</span>: Untranslated<br>';
      desc += '<span style="color:black">Black</span>: Intron, Locus, Unknown<br><br>';
      desc += '<em>Color By Class:</em><br>';
      desc += '<span style="color:red">Red</span>: Deletion<br>';
      desc += '<span style="color:green">Green</span>: MNP<br>';
      desc += '<span style="color:blue">Blue</span>: Microsatellite, Named<br>';
      desc += '<span style="color:black">Black</span>: Indel, Insertion, SNP';
      desc += "</html>";
      return desc;
    } else {
      return this.name;
    }

  };

  /**
   * Called when the track is removed.  Do any needed cleanup here
   */
  dispose() {
    this.trackView = undefined;
  }
}

/**
* Monitors track drag events, updates label position to ensure that they're always visible.
* @param track
*/
function monitorTrackDrag(track) {

  if (track.browser.on) {
    track.browser.on('trackdragend', onDragEnd);
    track.browser.on('trackremoved', unSubscribe);
  }

  function onDragEnd() {
    if (!track.trackView || !track.trackView.tile || track.displayMode === "SQUISHED") {
      return;
    }
  }

  function unSubscribe(removedTrack) {
    if (track.browser.un && track === removedTrack) {
      track.browser.un('trackdrag', onDragEnd);
      track.browser.un('trackremoved', unSubscribe);
    }
  }

}

/**
* @param feature
* @param bpStart  genomic location of the left edge of the current canvas
* @param xScale  scale in base-pairs per pixel
* @returns {{px: number, px1: number, pw: number, h: number, py: number}}
*/
function calculateFeatureCoordinates(feature, bpStart, xScale) {
  let px = (feature.start - bpStart) / xScale;
  let px1 = (feature.end - bpStart) / xScale;
  //px = Math.round((feature.start - bpStart) / xScale),
  //px1 = Math.round((feature.end - bpStart) / xScale),
  let pw = px1 - px;

  if (pw < 3) {
    pw = 3;
    px -= 1.5;
  }

  return {
    px: px,
    px1: px1,
    pw: pw
  };
}

/**
* Return color for feature.  Called in the context of a FeatureTrack instance.
* @param feature
* @returns {string}
*/
function getColorForFeature(feature) {
  let color;
  if (this.altColor && "-" === feature.strand) {
    color = this.altColor;
  } else if (this.color) {
    color = this.color;   // Explicit setting via menu, or possibly track line if !config.color
  } else if (this.config.colorBy) {
    const colorByValue = feature[this.config.colorBy.field];
    if (colorByValue) {
      color = this.config.colorBy.pallete[colorByValue];  // This is an undocumented option, and its not clear if its used
    }
  } else if (feature.color) {
    color = feature.color;   // Explicit color for feature
  } else {
    color = this.defaultColor;   // Track default
  }

  if (feature.alpha && feature.alpha !== 1) {
    color = IGVColor.addAlpha(color, feature.alpha);
  } else if (this.useScore && feature.score && !Number.isNaN(feature.score)) {
    // UCSC useScore option, for scores between 0-1000.  See https://genome.ucsc.edu/goldenPath/help/customTrack.html#TRACK
    const min = this.config.min ? this.config.min : 0; //getViewLimitMin(track);
    const max = this.config.max ? this.config.max : 1000; //getViewLimitMax(track);
    const alpha = getAlpha(min, max, feature.score);
    feature.alpha = alpha;    // Avoid computing again
    color = IGVColor.addAlpha(color, alpha);
  }


  function getAlpha(min, max, score) {
    const binWidth = (max - min) / 9;
    const binNumber = Math.floor((score - min) / binWidth);
    return Math.min(1.0, 0.2 + (binNumber * 0.8) / 9);
  }

  return color
}

/**
*
* @param feature
* @param bpStart  genomic location of the left edge of the current canvas
* @param xScale  scale in base-pairs per pixel
* @param pixelHeight  pixel height of the current canvas
* @param ctx  the canvas 2d context
* @param options  genomic state
*/
function renderFeature(feature, bpStart, xScale, pixelHeight, ctx, options) {

  this.browser;
  let color = getColorForFeature.call(this, feature);

  ctx.fillStyle = color;
  ctx.strokeStyle = color;

  let h;
  let py;
  if (this.displayMode === "SQUISHED" && feature.row !== undefined) {
    h = this.featureHeight / 2;
    py = this.margin + this.squishedRowHeight * feature.row;
  } else if (this.displayMode === "EXPANDED" && feature.row !== undefined) {
    h = this.featureHeight;
    py = this.margin + this.expandedRowHeight * feature.row;
  } else {  // collapsed
    h = this.featureHeight;
    py = this.margin;
  }

  const cy = py + h / 2;
  const h2 = h / 2;
  const py2 = cy - h2 / 2;

  const exonCount = feature.exons ? feature.exons.length : 0;
  const coord = calculateFeatureCoordinates(feature, bpStart, xScale);
  const step = this.arrowSpacing;
  const direction = feature.strand === '+' ? 1 : feature.strand === '-' ? -1 : 0;

  if (exonCount === 0) {
    // single-exon transcript
    ctx.fillRect(coord.px, py, coord.pw, h);

    // Arrows
    // Do not draw if strand is not +/-
    if (direction !== 0) {
      ctx.fillStyle = "white";
      ctx.strokeStyle = "white";
      for (let x = coord.px + step / 2; x < coord.px1; x += step) {
        // draw arrowheads along central line indicating transcribed orientation
        IGVGraphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);
        IGVGraphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);
      }
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
    }
  } else {
    // multi-exon transcript
    IGVGraphics.strokeLine(ctx, coord.px + 1, cy, coord.px1 - 1, cy); // center line for introns

    const pixelWidth = options.pixelWidth;

    const xLeft = Math.max(0, coord.px) + step / 2;
    const xRight = Math.min(pixelWidth, coord.px1);
    for (let x = xLeft; x < xRight; x += step) {
      // draw arrowheads along central line indicating transcribed orientation
      IGVGraphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);
      IGVGraphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);
    }
    for (let e = 0; e < exonCount; e++) {
      // draw the exons
      const exon = feature.exons[e];
      let ePx = Math.round((exon.start - bpStart) / xScale);
      let ePx1 = Math.round((exon.end - bpStart) / xScale);
      let ePw = Math.max(1, ePx1 - ePx);
      let ePxU;

      if (ePx + ePw < 0) {
        continue;  // Off the left edge
      }
      if (ePx > pixelWidth) {
        break; // Off the right edge
      }

      if (exon.utr) {
        ctx.fillRect(ePx, py2, ePw, h2); // Entire exon is UTR
      } else {
        if (exon.cdStart) {
          ePxU = Math.round((exon.cdStart - bpStart) / xScale);
          ctx.fillRect(ePx, py2, ePxU - ePx, h2); // start is UTR
          ePw -= (ePxU - ePx);
          ePx = ePxU;

        }
        if (exon.cdEnd) {
          ePxU = Math.round((exon.cdEnd - bpStart) / xScale);
          ctx.fillRect(ePxU, py2, ePx1 - ePxU, h2); // start is UTR
          ePw -= (ePx1 - ePxU);
          ePx1 = ePxU;
        }

        ctx.fillRect(ePx, py, ePw, h);

        // Arrows
        if (ePw > step + 5 && direction !== 0) {
          ctx.fillStyle = "white";
          ctx.strokeStyle = "white";
          for (let x = ePx + step / 2; x < ePx1; x += step) {
            // draw arrowheads along central line indicating transcribed orientation
            IGVGraphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);
            IGVGraphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);
          }
          ctx.fillStyle = color;
          ctx.strokeStyle = color;

        }
      }
    }
  }

  const windowX = Math.round(options.viewportContainerX);
  // const nLoci = browser.referenceFrameList ? browser.referenceFrameList.length : 1
  // const windowX1 = windowX + options.viewportContainerWidth / nLoci;
  const windowX1 = windowX + options.viewportWidth;

  if (options.drawLabel) {
    renderFeatureLabel.call(this, ctx, feature, coord.px, coord.px1, py, windowX, windowX1, options.referenceFrame, options);
  }
}

/**
* @param ctx       the canvas 2d context
* @param feature
* @param featureX  feature start x-coordinate
* @param featureX1 feature end x-coordinate
* @param featureY  feature y-coordinate
* @param windowX   visible window start x-coordinate
* @param windowX1  visible window end x-coordinate
* @param referenceFrame  genomic state
* @param options  options
*/
function renderFeatureLabel(ctx, feature, featureX, featureX1, featureY, windowX, windowX1, referenceFrame, options) {


  let name = feature.name;
  if (name === undefined && feature.gene) name = feature.gene.name;
  if (name === undefined) name = feature.id || feature.ID;
  if (!name || name === '.') return;

  // feature outside of viewable window
  let boxX;
  let boxX1;
  if (featureX1 < windowX || featureX > windowX1) {
    boxX = featureX;
    boxX1 = featureX1;
  } else {
    // center label within visible portion of the feature
    boxX = Math.max(featureX, windowX);
    boxX1 = Math.min(featureX1, windowX1);
  }

  let color = getColorForFeature.call(this, feature);
  let geneColor;
  let gtexSelection = false;
  if (referenceFrame.selection && GtexUtils.gtexLoaded) {
    // TODO -- for gtex, figure out a better way to do this
    gtexSelection = true;
    geneColor = referenceFrame.selection.colorForGene(name);
  }


  if (this.displayMode !== "SQUISHED") {
    const geneFontStyle = {
      textAlign: "SLANT" === this.labelDisplayMode ? undefined : 'center',
      fillStyle: geneColor || color,
      strokeStyle: geneColor || color
    };

    let transform;
    if (this.displayMode === "COLLAPSED" && this.labelDisplayMode === "SLANT") {
      transform = { rotate: { angle: 45 } };
    }

    const labelX = boxX + ((boxX1 - boxX) / 2);
    const labelY = getFeatureLabelY(featureY, transform);

    const textBox = ctx.measureText(name);
    const xleft = labelX - textBox.width / 2;
    const xright = labelX + textBox.width / 2;
    if (options.labelAllFeatures || xleft > options.rowLastX[feature.row] || gtexSelection) {

      options.rowLastX[feature.row] = xright;

      // This is for compatibility with JuiceboxJS.
      if (options.labelTransform) {
        ctx.save();
        options.labelTransform(ctx, labelX);
        IGVGraphics.fillText(ctx, name, labelX, labelY, geneFontStyle, undefined);
        ctx.restore();

      } else {
        IGVGraphics.fillText(ctx, name, labelX, labelY, geneFontStyle, transform);
      }
    }
  }
}


function getFeatureLabelY(featureY, transform) {
  return transform ? featureY + 20 : featureY + 25;
}

/**
*
* @param feature
* @param bpStart  genomic location of the left edge of the current canvas
* @param xScale  scale in base-pairs per pixel
* @param pixelHeight  pixel height of the current canvas
* @param ctx  the canvas 2d context
*/
function renderFusionJuncSpan(feature, bpStart, xScale, pixelHeight, ctx) {

  var py;
  var rowHeight = (this.displayMode === "EXPANDED") ? this.expandedRowHeight : this.squishedRowHeight;

  if (this.display === "COLLAPSED") {
    py = this.margin;
  }

  if (this.displayMode === "SQUISHED" && feature.row !== undefined) {
    py = this.margin + rowHeight * feature.row;
  } else if (this.displayMode === "EXPANDED" && feature.row !== undefined) {
    py = this.margin + rowHeight * feature.row;
  }

  var cy = py + 0.5 * rowHeight;
  var topY = cy - 0.5 * rowHeight;
  var bottomY = cy + 0.5 * rowHeight;

  // draw the junction arc
  var junctionLeftPx = Math.round((feature.junction_left - bpStart) / xScale);
  var junctionRightPx = Math.round((feature.junction_right - bpStart) / xScale);

  ctx.beginPath();
  ctx.moveTo(junctionLeftPx, cy);
  ctx.bezierCurveTo(junctionLeftPx, topY, junctionRightPx, topY, junctionRightPx, cy);

  ctx.lineWidth = 1 + Math.log(feature.num_junction_reads) / Math.log(2);
  ctx.strokeStyle = 'blue';
  ctx.stroke();

  // draw the spanning arcs
  var spanningCoords = feature.spanning_frag_coords;
  for (var i = 0; i < spanningCoords.length; i++) {
    var spanningInfo = spanningCoords[i];

    var spanLeftPx = Math.round((spanningInfo.left - bpStart) / xScale);
    var spanRightPx = Math.round((spanningInfo.right - bpStart) / xScale);


    ctx.beginPath();
    ctx.moveTo(spanLeftPx, cy);
    ctx.bezierCurveTo(spanLeftPx, bottomY, spanRightPx, bottomY, spanRightPx, cy);

    ctx.lineWidth = 1;
    ctx.strokeStyle = 'purple';
    ctx.stroke();
  }
}


/**
*
* @param feature
* @param bpStart  genomic location of the left edge of the current canvas
* @param xScale  scale in base-pairs per pixel
* @param pixelHeight  pixel height of the current canvas
* @param ctx  the canvas 2d context
*/
function renderJunctions(feature, bpStart, xScale, pixelHeight, ctx) {
  // cache whether this junction is rendered or filtered out. Use later to exclude non-rendered junctions from click detection.
  feature.isVisible = false;

  const junctionLeftPx = Math.round((feature.start - bpStart) / xScale);
  const junctionRightPx = Math.round((feature.end - bpStart) / xScale);
  const junctionMiddlePx = (junctionLeftPx + junctionRightPx) / 2;
  if (junctionRightPx - junctionLeftPx <= 3) {
    if (junctionMiddlePx in junctionRenderingContext.featureZoomOutTracker) {
      return
    }
    junctionRenderingContext.featureZoomOutTracker[junctionMiddlePx] = true;
  }

  // TODO: cache filter and pixel calculations by doing them earlier when features are initially parsed?
  if (this.config.hideAnnotatedJunctions && feature.attributes.annotated_junction === "true") {
    return
  }
  if (this.config.hideUnannotatedJunctions && feature.attributes.annotated_junction === "false") {
    return
  }
  if (this.config.hideMotifs && this.config.hideMotifs.includes(feature.attributes.motif)) {
    return
  }
  if (this.config.hideStrand === feature.strand) {
    return
  }

  // check if splice junction is inside viewport
  if (this.config.minJunctionEndsVisible) {
    let numJunctionEndsVisible = 0;
    if (feature.start >= junctionRenderingContext.referenceFrameStart && feature.start <= junctionRenderingContext.referenceFrameEnd) {
      numJunctionEndsVisible += 1;
    }
    if (feature.end >= junctionRenderingContext.referenceFrameStart && feature.end <= junctionRenderingContext.referenceFrameEnd) {
      numJunctionEndsVisible += 1;
    }
    if (numJunctionEndsVisible < this.config.minJunctionEndsVisible) {
      return
    }
  }

  let uniquelyMappedReadCount;
  let multiMappedReadCount;
  let totalReadCount;
  if (feature.attributes.uniquely_mapped) {
    uniquelyMappedReadCount = parseInt(feature.attributes.uniquely_mapped);
    if (uniquelyMappedReadCount < this.config.minUniquelyMappedReads) {
      return
    }
    multiMappedReadCount = parseInt(feature.attributes.multi_mapped);
    totalReadCount = uniquelyMappedReadCount + multiMappedReadCount;
    if (totalReadCount < this.config.minTotalReads) {
      return
    }
    if (totalReadCount > 0 && multiMappedReadCount / totalReadCount > this.config.maxFractionMultiMappedReads) {
      return
    }
    if (feature.attributes.maximum_spliced_alignment_overhang && parseInt(feature.attributes.maximum_spliced_alignment_overhang) < this.config.minSplicedAlignmentOverhang) {
      return
    }
  }

  let numSamplesWithThisJunction;
  if (feature.attributes.num_samples_with_this_junction) {
    numSamplesWithThisJunction = parseInt(feature.attributes.num_samples_with_this_junction);
    if (this.config.minSamplesWithThisJunction && numSamplesWithThisJunction < this.config.minSamplesWithThisJunction) {
      return
    }
    if (this.config.maxSamplesWithThisJunction && numSamplesWithThisJunction > this.config.maxSamplesWithThisJunction) {
      return
    }
    if (feature.attributes.num_samples_total) {
      feature.attributes.percent_samples_with_this_junction = 100 * numSamplesWithThisJunction / parseFloat(feature.attributes.num_samples_total);
      if (this.config.minPercentSamplesWithThisJunction) {
        if (feature.attributes.percent_samples_with_this_junction < this.config.minPercentSamplesWithThisJunction ||
          feature.attributes.percent_samples_with_this_junction > this.config.maxPercentSamplesWithThisJunction) {
          return
        }
      }
    }
  }

  const py = this.margin;
  const rowHeight = this.height;

  const cy = py + 0.5 * rowHeight;
  let topY = py;
  const bottomY = py + rowHeight;
  const bezierBottomY = bottomY - 10;

  // draw the junction arc
  const bezierControlLeftPx = (junctionLeftPx + junctionMiddlePx) / 2;
  const bezierControlRightPx = (junctionMiddlePx + junctionRightPx) / 2;

  let lineWidth = 1;
  if (feature.attributes.line_width) {
    lineWidth = parseFloat(feature.attributes.line_width);
  } else {
    if (this.config.thicknessBasedOn === undefined || this.config.thicknessBasedOn === 'numUniqueReads') {
      lineWidth = uniquelyMappedReadCount;
    } else if (this.config.thicknessBasedOn === 'numReads') {
      lineWidth = totalReadCount;
    } else if (this.config.thicknessBasedOn === 'numSamplesWithThisJunction') {
      if (numSamplesWithThisJunction !== undefined) {
        lineWidth = numSamplesWithThisJunction;
      }
    }
    lineWidth = 1 + Math.log(lineWidth + 1) / Math.log(12);
  }

  let bounceHeight;
  if (this.config.bounceHeightBasedOn === undefined || this.config.bounceHeightBasedOn === 'random') {
    // randomly but deterministically stagger topY coordinates to reduce overlap
    bounceHeight = (feature.start + feature.end) % 7;
  } else if (this.config.bounceHeightBasedOn === 'distance') {
    bounceHeight = 6 * (feature.end - feature.start) / (junctionRenderingContext.referenceFrameEnd - junctionRenderingContext.referenceFrameStart);
  } else if (this.config.bounceHeightBasedOn === 'thickness') {
    bounceHeight = 2 * lineWidth;
  }
  topY += rowHeight * Math.max(7 - bounceHeight, 0) / 10;

  let color;
  if (feature.attributes.color) {
    color = feature.attributes.color;  // Explicit setting
  } else if (this.config.colorBy === undefined || this.config.colorBy === 'numUniqueReads') {
    color = uniquelyMappedReadCount > this.config.colorByNumReadsThreshold ? 'blue' : '#AAAAAA';  // color gradient?
  } else if (this.config.colorBy === 'numReads') {
    color = totalReadCount > this.config.colorByNumReadsThreshold ? 'blue' : '#AAAAAA';
  } else if (this.config.colorBy === 'isAnnotatedJunction') {
    color = feature.attributes.annotated_junction === "true" ? '#b0b0ec' : 'orange';
  } else if (this.config.colorBy === 'strand') {
    color = feature.strand === "+" ? '#b0b0ec' : '#ecb0b0';
  } else if (this.config.colorBy === 'motif') {
    color = JUNCTION_MOTIF_PALETTE.getColor(feature.attributes.motif);
  } else {
    color = '#AAAAAA';
  }

  let label = "";
  if (feature.attributes.label) {
    label = feature.attributes.label.replace(/_/g, " ");
  } else if (this.config.labelWith === undefined || this.config.labelWith === 'uniqueReadCount') {
    //default label
    label = uniquelyMappedReadCount;
  } else if (this.config.labelWith === 'totalReadCount') {
    label = totalReadCount;
  } else if (this.config.labelWith === 'numSamplesWithThisJunction') {
    if (numSamplesWithThisJunction !== undefined) {
      label = numSamplesWithThisJunction;
    }
  } else if (this.config.labelWith === 'percentSamplesWithThisJunction') {
    if (feature.attributes.percent_samples_with_this_junction !== undefined) {
      label = feature.attributes.percent_samples_with_this_junction.toFixed(0) + '%';
    }
  } else if (this.config.labelWith === 'motif') {
    if (feature.attributes.motif !== undefined) {
      label += feature.attributes.motif;
    }
  }

  if (this.config.labelWithInParen === 'uniqueReadCount') {
    label += ' (' + uniquelyMappedReadCount + ')';
  } else if (this.config.labelWithInParen === 'totalReadCount') {
    label += ' (' + totalReadCount + ')';
  } else if (this.config.labelWithInParen === 'multiMappedReadCount') {
    if (multiMappedReadCount > 0) {
      label += ' (+' + multiMappedReadCount + ')';
    }
  } else if (this.config.labelWithInParen === 'numSamplesWithThisJunction') {
    if (numSamplesWithThisJunction !== undefined) {
      label += ' (' + numSamplesWithThisJunction + ')';
    }
  } else if (this.config.labelWithInParen === 'percentSamplesWithThisJunction') {
    if (feature.attributes.percent_samples_with_this_junction !== undefined) {
      label += ' (' + feature.attributes.percent_samples_with_this_junction.toFixed(0) + '%)';
    }
  } else if (this.config.labelWithInParen === 'motif') {
    if (feature.attributes.motif !== undefined) {
      label += ` ${feature.attributes.motif}`;
    }
  }

  // data source: STAR splice junctions (eg. SJ.out.tab file converted to bed).
  // .bed "name" field used to store unique + multi-mapped read counts, so:
  // feature.score:  unique spanning read counts
  // feature.name:   unique + multi-mapped spanning read counts
  //example feature:  { chr: "chr17", start: 39662344, end: 39662803, name: "59", row: 0, score: 38, strand: "+"}
  feature.isVisible = true;
  ctx.beginPath();
  ctx.moveTo(junctionLeftPx, bezierBottomY);
  ctx.bezierCurveTo(bezierControlLeftPx, topY, bezierControlRightPx, topY, junctionRightPx, bezierBottomY);

  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = color;
  ctx.stroke();

  const drawArrowhead = (ctx, x, y, size) => {
    //TODO draw better arrow heads: https://stackoverflow.com/questions/21052972/curved-thick-arrows-on-canvas
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x - size / 2, y - size);
    ctx.lineTo(x + size / 2, y - size);
    ctx.lineTo(x, y);
    ctx.closePath();
    ctx.fill();
  };

  if (feature.attributes.left_shape || feature.attributes.right_shape) {
    ctx.fillStyle = color;
    const arrowSize = ctx.lineWidth > 2 ? 10 : 7;
    if (feature.attributes.left_shape) {
      drawArrowhead(ctx, junctionLeftPx, bezierBottomY, arrowSize);
    }
    if (feature.attributes.right_shape) {
      drawArrowhead(ctx, junctionRightPx, bezierBottomY, arrowSize);
    }
  }

  ctx.fillText(label, junctionMiddlePx - ctx.measureText(label).width / 2, (7 * topY + cy) / 8);
}

// SNP constants
const codingNonSynonSet = new Set(['nonsense', 'missense', 'stop-loss', 'frameshift', 'cds-indel']);
const codingSynonSet = new Set(['coding-synon']);
const spliceSiteSet = new Set(['splice-3', 'splice-5']);
const untranslatedSet = new Set(['untranslated-5', 'untranslated-3']);

/**
* Renderer for a UCSC snp track
*
* @param snp
* @param bpStart  genomic location of the left edge of the current canvas
* @param xScale  scale in base-pairs per pixel
* @param pixelHeight  pixel height of the current canvas
* @param ctx  the canvas 2d context
*/
function renderSnp(snp, bpStart, xScale, pixelHeight, ctx) {

  var coord = calculateFeatureCoordinates(snp, bpStart, xScale),
    py = this.margin,
    h,
    colorArrLength = this.snpColors.length,
    colorPriority;

  h = this.displayMode === "squished" ? this.squishedRowHeight : this.expandedRowHeight;

  switch (this.colorBy) {
    case 'function':
      colorPriority = colorByFunc(snp.func);
      break;
    case 'class':
      colorPriority = colorByClass(snp['class']);
  }

  ctx.fillStyle = this.snpColors[colorPriority];
  ctx.fillRect(coord.px, py, coord.pw, h);

  // Coloring functions, convert a value to a priority

  function colorByFunc(theFunc) {
    var priorities;
    var funcArray = theFunc.split(',');
    // possible func values


    priorities = funcArray.map(function (func) {
      if (codingNonSynonSet.has(func) || spliceSiteSet.has(func)) {
        return colorArrLength - 1;
      } else if (codingSynonSet.has(func)) {
        return colorArrLength - 2;
      } else if (untranslatedSet.has(func)) {
        return colorArrLength - 3;
      } else { // locusSet.has(func) || intronSet.has(func)
        return 0;
      }
    });

    return priorities.reduce(function (a, b) {
      return Math.max(a, b);
    });
  }

  function colorByClass(cls) {
    if (cls === 'deletion') {
      return colorArrLength - 1;
    } else if (cls === 'mnp') {
      return colorArrLength - 2;
    } else if (cls === 'microsatellite' || cls === 'named') {
      return colorArrLength - 3;
    } else { // cls === 'single' || cls === 'in-del' || cls === 'insertion'
      return 0;
    }
  }
}

function paintAxis(ctx, pixelWidth, pixelHeight) {

  var x1,
    x2,
    y1,
    y2,
    a,
    b,
    reference,
    shim,
    font = {
      'font': 'normal 10px Arial',
      'textAlign': 'right',
      'strokeStyle': "black"
    };

  if (undefined === this.dataRange || undefined === this.dataRange.max || undefined === this.dataRange.min) {
    return;
  }

  IGVGraphics.fillRect(ctx, 0, 0, pixelWidth, pixelHeight, { 'fillStyle': "rgb(255, 255, 255)" });

  reference = 0.95 * pixelWidth;
  x1 = reference - 8;
  x2 = reference;

  //shim = 0.5 * 0.125;
  shim = .01;
  y1 = y2 = shim * pixelHeight;

  a = { x: x2, y: y1 };

  // tick
  IGVGraphics.strokeLine(ctx, x1, y1, x2, y2, font);
  IGVGraphics.fillText(ctx, prettyPrint(this.dataRange.max), x1 + 4, y1 + 12, font);

  //shim = 0.25 * 0.125;
  y1 = y2 = (1.0 - shim) * pixelHeight;

  b = { x: x2, y: y1 };

  // tick
  IGVGraphics.strokeLine(ctx, x1, y1, x2, y2, font);
  IGVGraphics.fillText(ctx, prettyPrint(this.dataRange.min), x1 + 4, y1 - 4, font);

  IGVGraphics.strokeLine(ctx, a.x, a.y, b.x, b.y, font);

  function prettyPrint(number) {
    // if number >= 100, show whole number
    // if >= 1 show 1 significant digits
    // if <  1 show 2 significant digits

    if (number === 0) {
      return "0";
    } else if (Math.abs(number) >= 10) {
      return number.toFixed();
    } else if (Math.abs(number) >= 1) {
      return number.toFixed(1);
    } else {
      return number.toFixed(2);
    }
  }
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
* Author: Jim Robinson
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*
* This class uses icons from Font Awesome
* Font Awesome Free 5.0.8 by @fontawesome - https://fontawesome.com
* License - https://fontawesome.com/license (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
*/

function createCheckbox(name, initialState) {

  let $container = $('<div>', { class: 'igv-menu-popup-check-container' });

  let $div = $('<div>');
  $container.append($div);

  let $svg = iconMarkup$1('check', (true === initialState ? '#444' : 'transparent'));
  $div.append($svg);

  let $label = $('<div>'/*, { class: 'igv-some-label-class' }*/);
  $label.text(name);
  $container.append($label);

  return $container;
}

function createIcon$1(name, color) {
  return $(iconMarkup$1(name, color));
}

function iconMarkup$1(name, color) {

  color = color || "currentColor";

  let icon = icons$1[name];

  if (!icon) {
    console.error(`No icon named: ${name}`);
    icon = icons$1["question"];
  }
  let svg = '<svg ' + 'viewBox="0 0 ' + icon[0] + ' ' + icon[1] + '">';
  svg += '<path fill="' + color + '" ' + 'd="' + icon[4] + '">' + '</path>';
  svg += '</svg>';
  return svg;

}

const icons$1 = {
  "check": [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"],
  "cog": [512, 512, [], "f013", "M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z"],
  "exclamation": [192, 512, [], "f12a", "M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z"],
  "exclamation-circle": [512, 512, [], "f06a", "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
  "exclamation-triangle": [576, 512, [], "f071", "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
  "minus": [448, 512, [], "f068", "M424 318.2c13.3 0 24-10.7 24-24v-76.4c0-13.3-10.7-24-24-24H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h400z"],
  "minus-circle": [512, 512, [], "f056", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z"],
  "minus-square": [448, 512, [], "f146", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM92 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H92z"],
  "plus": [448, 512, [], "f067", "M448 294.2v-76.4c0-13.3-10.7-24-24-24H286.2V56c0-13.3-10.7-24-24-24h-76.4c-13.3 0-24 10.7-24 24v137.8H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h137.8V456c0 13.3 10.7 24 24 24h76.4c13.3 0 24-10.7 24-24V318.2H424c13.3 0 24-10.7 24-24z"],
  "plus-circle": [512, 512, [], "f055", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
  "plus-square": [448, 512, [], "f0fe", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-32 252c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92H92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
  "question": [384, 512, [], "f128", "M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"],
  "save": [448, 512, [], "f0c7", "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"],
  "search": [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"],
  "share": [512, 512, [], "f064", "M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z"],
  "spinner": [512, 512, [], "f110", "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"],
  "square": [448, 512, [], "f0c8", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z"],
  "square-full": [512, 512, [], "f45c", "M512 512H0V0h512v512z"],
  "times": [384, 512, [], "f00d", "M323.1 441l53.9-53.9c9.4-9.4 9.4-24.5 0-33.9L279.8 256l97.2-97.2c9.4-9.4 9.4-24.5 0-33.9L323.1 71c-9.4-9.4-24.5-9.4-33.9 0L192 168.2 94.8 71c-9.4-9.4-24.5-9.4-33.9 0L7 124.9c-9.4 9.4-9.4 24.5 0 33.9l97.2 97.2L7 353.2c-9.4 9.4-9.4 24.5 0 33.9L60.9 441c9.4 9.4 24.5 9.4 33.9 0l97.2-97.2 97.2 97.2c9.3 9.3 24.5 9.3 33.9 0z"],
  "times-circle": [512, 512, [], "f057", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"],
  "wrench": [512, 512, [], "f0ad", "M481.156 200c9.3 0 15.12 10.155 10.325 18.124C466.295 259.992 420.419 288 368 288c-79.222 0-143.501-63.974-143.997-143.079C223.505 65.469 288.548-.001 368.002 0c52.362.001 98.196 27.949 123.4 69.743C496.24 77.766 490.523 88 481.154 88H376l-40 56 40 56h105.156zm-171.649 93.003L109.255 493.255c-24.994 24.993-65.515 24.994-90.51 0-24.993-24.994-24.993-65.516 0-90.51L218.991 202.5c16.16 41.197 49.303 74.335 90.516 90.503zM104 432c0-13.255-10.745-24-24-24s-24 10.745-24 24 10.745 24 24 24 24-10.745 24-24z"],
};

/**
* Configure item list for track "gear" menu.
* @param trackRenderer
*/
const MenuUtils = {

  trackMenuItemList: function (trackPair) {


    let menuItems = [];

    menuItems.push(trackRenameMenuItem(trackPair));
    menuItems.push("<hr/>");
    menuItems.push(colorPickerMenuItem({ trackRenderer: trackPair, label: "Set color", option: "color" }));
    menuItems.push(unsetColorMenuItem({ trackRenderer: trackPair, label: "Unset color" }));

    const trackMenuItems = trackPair.track.menuItemList();
    if (trackMenuItems && trackMenuItems.length > 0) {
      menuItems.push('<hr/>');
      menuItems.push.apply(menuItems, trackMenuItems);
    }


    // const vizWindowTypes = new Set(['alignment', 'annotation', 'variant', 'eqtl', 'snp']);
    // const hasVizWindow = trackRenderer.track.config && trackRenderer.track.config.visibilityWindow !== undefined;
    // if (hasVizWindow || vizWindowTypes.has(trackRenderer.track.config.type)) {
    //     menuItems.push('<hr/>');
    //     menuItems.push(visibilityWindowMenuItem(trackRenderer));
    // }

    if (trackPair.track.removable !== false) {
      menuItems.push('<hr/>');
      menuItems.push(trackRemovalMenuItem(trackPair));
    }

    return menuItems;
  },

  numericDataMenuItems: function (trackPair) {

    const menuItems = [];

    // Data range
    const $e = $('<div>');

    $e.text('Set data range');
    const clickHandler = function () {
      const currentDataRange = trackPair.track.dataRange;
      trackPair.dataRangeDialog.show({
        min: currentDataRange.min || 0,
        max: currentDataRange.max,
      });
    };

    menuItems.push({ object: $e, click: clickHandler });

    if (trackPair.track.logScale !== undefined) {
      menuItems.push({
        object: createCheckbox("Log scale", trackPair.track.logScale),
        click: () => {
          trackPair.track.logScale = !trackPair.track.logScale;
          trackPair.repaintViews();
        }
      }
      );
    }

    menuItems.push({
      object: createCheckbox("Autoscale", trackPair.track.autoscale),
      click: () => {
        trackPair.track.autoscale = !trackPair.track.autoscale;
        trackPair.repaintViews();
      }
    }
    );

    return menuItems;
  }

};


function trackRemovalMenuItem(trackRenderer) {

  var $e, menuClickHandler;
  $e = $('<div>');
  $e.text('Remove track');

  menuClickHandler = function menuClickHandler() {
    var browser = trackRenderer.browser;
    browser.layoutController.removeTrackXYPair(trackRenderer);
  };

  return { object: $e, click: menuClickHandler };

}

function colorPickerMenuItem({ trackRenderer, label, option }) {
  var $e,
    clickHandler;

  $e = $('<div>');
  $e.text(label);

  clickHandler = function () {
    trackRenderer.colorPicker.show();
  };

  return { object: $e, click: clickHandler };
}

function unsetColorMenuItem({ trackRenderer, label }) {

  const $e = $('<div>');
  $e.text(label);

  return {
    object: $e,
    click: () => {
      trackRenderer.track.color = undefined;
      trackRenderer.repaintViews();
    }
  }
}

function trackRenameMenuItem(trackRenderer) {
  const click = e => {
    const callback = (value) => {
      value = value.trim();
      value = ('' === value || undefined === value) ? 'untitled' : value;
      trackRenderer.setTrackName(value);
    };
    trackRenderer.browser.inputDialog.present({ label: 'Track Name', value: trackRenderer.track.name, callback }, e);
  };
  const object = $('<div>');
  object.text('Set track name');
  return { object, click };
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

const DEFAULT_COLOR = "rgb(150,150,150)";

class WigTrack extends TrackBase {

  constructor(config, browser) {

    super(config, browser);

    this.type = "wig";
    this.height = config.height || 50;
    this.featureType = 'numeric';

    const format = config.format ? config.format.toLowerCase() : config.format;
    if ("bigwig" === format) {
      this.featureSource = new BWSource(config, browser.genome);
    } else if ("tdf" === format) {
      this.featureSource = new TDFSource(config, browser.genome);
    } else {
      this.featureSource = FeatureSource(config, browser.genome);
    }

    this.autoscale = config.autoscale || config.max === undefined;
    if (!this.autoscale) {
      this.dataRange = {
        min: config.min || 0,
        max: config.max
      };
    }

    this.windowFunction = config.windowFunction || "mean";
    this.paintAxis = paintAxis;
    this.graphType = config.graphType || "bar";
    this.normalize = config.normalize;  // boolean, for use with "TDF" files
    this.scaleFactor = config.scaleFactor;  // optional scale factor, ignored if normalize === true;

  }

  async postInit() {
    const header = await this.getHeader();
    if (header) this.setTrackProperties(header);
  }

  async getFeatures(chr, start, end, bpPerPixel) {

    const features = await this.featureSource.getFeatures({ chr, start, end, bpPerPixel, windowFunction: this.windowFunction });
    if (this.normalize && this.featureSource.normalizationFactor) {
      const scaleFactor = this.featureSource.normalizationFactor;
      for (let f of features) {
        f.value *= scaleFactor;
      }
    }
    if (this.scaleFactor) {
      const scaleFactor = this.scaleFactor;
      for (let f of features) {
        f.value *= scaleFactor;
      }
    }
    return features;
  }

  menuItemList() {
    return MenuUtils.numericDataMenuItems(this.trackView)
  }

  async getHeader() {

    if (typeof this.featureSource.getHeader === "function") {
      this.header = await this.featureSource.getHeader();
    }
    return this.header;
  }

  draw(options) {

    const features = options.features;
    const ctx = options.context;
    const bpPerPixel = options.bpPerPixel;
    const bpStart = options.bpStart;
    const pixelWidth = options.pixelWidth;
    const pixelHeight = options.pixelHeight;
    const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
    let lastPixelEnd = -1;
    let lastValue = -1;
    let lastNegValue = 1;
    const posColor = this.color || DEFAULT_COLOR;

    let baselineColor;
    if (typeof posColor === "string" && posColor.startsWith("rgb(")) {
      baselineColor = IGVColor.addAlpha(posColor, 0.1);
    }

    const yScale = (yValue) => {
      return ((this.dataRange.max - yValue) / (this.dataRange.max - this.dataRange.min)) * pixelHeight
    };

    if (features && features.length > 0) {

      if (this.dataRange.min === undefined) this.dataRange.min = 0;

      // Max can be less than min if config.min is set but max left to autoscale.   If that's the case there is
      // nothing to paint.
      if (this.dataRange.max > this.dataRange.min) {

        const y0 = this.dataRange.min == 0 ? pixelHeight : yScale(0);
        for (let f of features) {

          if (f.end < bpStart) continue;
          if (f.start > bpEnd) break;

          const x = Math.floor((f.start - bpStart) / bpPerPixel);
          if (isNaN(x)) continue;

          let y = yScale(f.value);

          const rectEnd = Math.ceil((f.end - bpStart) / bpPerPixel);
          const width = Math.max(1, rectEnd - x);

          let c = (f.value < 0 && this.altColor) ? this.altColor : posColor;
          const color = (typeof c === "function") ? c(f.value) : c;

          if (this.graphType === "points") {
            const pointSize = this.config.pointSize || 3;
            const px = x + width / 2;
            IGVGraphics.fillCircle(ctx, px, y, pointSize / 2, { "fillStyle": color, "strokeStyle": color });

          } else {
            let height = y - y0;
            if ((Math.abs(height)) < 1) {
              height = height < 0 ? -1 : 1;
            }
            const pixelEnd = x + width;
            if (pixelEnd > lastPixelEnd || (f.value >= 0 && f.value > lastValue) || (f.value < 0 && f.value < lastNegValue)) {
              IGVGraphics.fillRect(ctx, x, y0, width, height, { fillStyle: color });
            }
            lastValue = f.value;
            lastPixelEnd = pixelEnd;
          }
        }

        // If the track includes negative values draw a baseline
        if (this.dataRange.min < 0) {
          const basepx = (this.dataRange.max / (this.dataRange.max - this.dataRange.min)) * options.pixelHeight;
          IGVGraphics.strokeLine(ctx, 0, basepx, options.pixelWidth, basepx, { strokeStyle: baselineColor });
        }
      }
    }

    // Draw guidelines
    if (this.config.hasOwnProperty('guideLines')) {
      for (let line of this.config.guideLines) {
        if (line.hasOwnProperty('color') && line.hasOwnProperty('y') && line.hasOwnProperty('dotted')) {
          let y = yScale(line.y);
          let props = {
            'strokeStyle': line['color'],
            'strokeWidth': 2
          };
          if (line['dotted']) IGVGraphics.dashedLine(options.context, 0, y, options.pixelWidth, y, 5, props);
          else IGVGraphics.strokeLine(options.context, 0, y, options.pixelWidth, y, props);
        }
      }
    }
  }

  popupData(clickState, features) {

    // We use the featureCache property rather than method to avoid async load.  If the
    // feature is not already loaded this won't work,  but the user wouldn't be mousing over it either.

    if (!features) features = this.clickedFeatures(clickState);

    if (features && features.length > 0) {

      let genomicLocation = clickState.genomicLocation;
      let referenceFrame = clickState.viewport.referenceFrame;
      let popupData = [];

      // We need some tolerance around genomicLocation, start with +/- 2 pixels
      let tolerance = 2 * referenceFrame.bpPerPixel;
      let selectedFeature = binarySearch(features, genomicLocation, tolerance);

      if (selectedFeature) {
        let posString = (selectedFeature.end - selectedFeature.start) === 1 ?
          numberFormatter(selectedFeature.start + 1)
          : numberFormatter(selectedFeature.start + 1) + "-" + numberFormatter(selectedFeature.end);
        popupData.push({ name: "Position:", value: posString });
        popupData.push({
          name: "Value:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",
          value: numberFormatter(selectedFeature.value)
        });
      }

      return popupData;


    } else {
      return [];
    }
  }

  supportsWholeGenome() {
    if (typeof this.featureSource.supportsWholeGenome === 'function') {
      return this.featureSource.supportsWholeGenome();
    } else {
      return false;
    }
  }

  /**
   * Called when the track is removed.  Do any needed cleanup here
   */
  dispose() {
    this.trackView = undefined;
  }
}

/**
* Return the closest feature to the genomic position +/- the specified tolerance.  Closest is defined
* by the minimum of the distance between position and start or end of the feature.
*
* @param features
* @param position
* @returns {*}
*/
function binarySearch(features, position, tolerance) {
  var startIndex = 0,
    stopIndex = features.length - 1,
    index = (startIndex + stopIndex) >> 1,
    candidateFeature,
    tmp;


  // Use binary search to get the index of at least 1 feature in the click tolerance bounds
  while (!test(features[index], position, tolerance) && startIndex < stopIndex) {
    if (position < features[index].start) {
      stopIndex = index - 1;
    } else if (position > features[index].end) {
      startIndex = index + 1;
    }

    index = (startIndex + stopIndex) >> 1;
  }

  if (test(features[index], position, tolerance)) {

    candidateFeature = features[index];
    if (test(candidateFeature, position, 0)) return candidateFeature;

    // Else, find closest feature to click
    tmp = index;
    while (tmp-- >= 0) {
      if (!test(features[tmp]), tolerance) {
        break;
      }
      if (test(features[tmp], position, 0)) {
        return features[tmp];
      }
      if (delta(features[tmp], position) < delta(candidateFeature, position)) {
        candidateFeature = features[tmp];
      }

      tmp = index;
      while (tmp++ < features.length) {
        if (!test(features[tmp]), tolerance) {
          break;
        }
        if (test(features[tmp], position, 0)) {
          return features[tmp];
        }
        if (delta(features[tmp], position) < delta(candidateFeature, position)) {
          candidateFeature = features[tmp];
        }
      }
    }
    return candidateFeature;

  } else {
    console.log(position + ' not found!');
    return undefined;
  }

  function test(feature, position, tolerance) {
    return position >= (feature.start - tolerance) && position <= (feature.end + tolerance);
  }

  function delta(feature, position) {
    return Math.min(Math.abs(feature.start - position), Math.abs(feature.end - position));
  }
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2016 University of California San Diego
* Author: Jim Robinson
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

const isString = isString$2;


const DEFAULT_VISIBILITY_WINDOW = 1000000;
const topMargin = 10;

class VariantTrack extends TrackBase {

  constructor(config, browser) {

    super(config, browser);

    this.visibilityWindow = config.visibilityWindow;
    this.displayMode = config.displayMode || "EXPANDED";    // COLLAPSED | EXPANDED | SQUISHED
    this.labelDisplayMode = config.labelDisplayMode;
    this.variantHeight = config.variantHeight || 10;
    this.squishedCallHeight = config.squishedCallHeight || 1;
    this.expandedCallHeight = config.expandedCallHeight || 10;
    this.expandedVGap = config.expandedVGap !== undefined ? config.expandedVGap : 2;
    this.squishedVGap = config.squishedVGap !== undefined ? config.squishedVGap : 1;
    this.expandedGroupGap = config.expandedGroupGap || 10;
    this.squishedGroupGap = config.squishedGroupGap || 5;
    this.featureHeight = config.featureHeight || 14;
    this.visibilityWindow = config.visibilityWindow;
    this.featureSource = FeatureSource(config, browser.genome);
    this.noCallColor = config.noCallColor || "rgb(245, 245, 245)";
    this.nonRefColor = config.nonRefColor || "rgb(200, 200, 215)";
    this.mixedColor = config.mixedColor || "rgb(200, 220, 200)";
    this.homrefColor = config.homrefColor || "rgb(200, 200, 200)";
    this.homvarColor = config.homvarColor || "rgb(17,248,254)";
    this.hetvarColor = config.hetvarColor || "rgb(34,12,253)";
    this.sortDirection = "ASC";
    this.type = config.type || "variant";

    this.nRows = 1;  // Computed dynamically

  }

  async postInit() {

    await this.getHeader();   // cricital, don't remove'
    if (undefined === this.visibilityWindow && this.config.indexed !== false) {
      const fn = isFile(this.config.url) ? this.config.url.name : this.config.url;
      if (isString(fn) && fn.toLowerCase().includes("gnomad")) {
        this.visibilityWindow = 1000;  // these are known to be very dense
      } else if (this.callSets) {
        const length = this.callSets.length;
        this.visibilityWindow = Math.max(1000, DEFAULT_VISIBILITY_WINDOW - length * (DEFAULT_VISIBILITY_WINDOW / 100));
      } else {
        this.visibilityWindow = DEFAULT_VISIBILITY_WINDOW;
      }
    }
    return this;

  }

  supportsWholeGenome() {
    return this.config.indexed === false && this.config.supportsWholeGenome !== false
  }

  async getHeader() {

    if (this.header) {
      return this.header;
    } else if (typeof this.featureSource.getHeader === "function") {
      const header = await this.featureSource.getHeader();
      if (header) {
        this.callSets = header.callSets || [];
      }
      this.header = header;
      return header;
    } else {
      this.callSets = [];
      return undefined;
    }

  }

  getCallsetsLength() {
    return this.callSets.length;
  }

  async getFeatures(chr, start, end, bpPerPixel) {

    if (this.header === undefined) {
      this.header = await this.getHeader();
    }
    return this.featureSource.getFeatures({ chr, start, end, bpPerPixel, visibilityWindow: this.visibilityWindow });

  }

  /**
   * The required height in pixels required for the track content.   This is not the visible track height, which
   * can be smaller (with a scrollbar) or larger.
   *
   * @param features
   * @returns {*}
   */
  computePixelHeight(features) {

    if (this.displayMode === "COLLAPSED") {
      this.nRows = 1;
      return topMargin + this.variantHeight;
    } else {

      var maxRow = 0;
      if (features) {
        for (let feature of features) {
          if (feature.row && feature.row > maxRow) maxRow = feature.row;
        }
      }
      const vGap = (this.displayMode === 'EXPANDED') ? this.expandedVGap : this.squishedVGap;
      this.nRows = maxRow + 1;
      const h = topMargin + this.nRows * (this.variantHeight + vGap);
      this.variantBandHeight = h;

      const callHeight = (this.displayMode === "EXPANDED" ? this.expandedCallHeight : this.squishedCallHeight);
      const nCalls = this.getCallsetsLength() * this.nRows;
      return h + vGap + (nCalls + 1) * (callHeight + vGap);

    }

  };

  draw(options) {

    const ctx = options.context;
    const callSets = this.callSets;
    const nCalls = this.getCallsetsLength();
    const pixelWidth = options.pixelWidth;
    const pixelHeight = options.pixelHeight;
    const callHeight = ("EXPANDED" === this.displayMode ? this.expandedCallHeight : this.squishedCallHeight);
    const bpPerPixel = options.bpPerPixel;
    const bpStart = options.bpStart;
    const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
    IGVGraphics.fillRect(ctx, 0, options.pixelTop, pixelWidth, pixelHeight, { 'fillStyle': "rgb(255, 255, 255)" });

    const vGap = (this.displayMode === 'EXPANDED') ? this.expandedVGap : this.squishedVGap;

    if (callSets && nCalls > 0 && "COLLAPSED" !== this.displayMode) {
      IGVGraphics.strokeLine(ctx, 0, this.variantBandHeight, pixelWidth, this.variantBandHeight, { strokeStyle: 'rgb(224,224,224) ' });
    }

    const featureList = options.features;

    if (featureList) {
      for (let variant of featureList) {
        if (variant.end < bpStart) continue;
        if (variant.start > bpEnd) break;

        const py = topMargin + ("COLLAPSED" === this.displayMode ? 0 : variant.row * (this.variantHeight + vGap));
        const vh = this.variantHeight;

        // Compute pixel width.   Minimum width is 3 pixels,  if > 5 pixels create gap between variants
        let px = Math.round((variant.start - bpStart) / bpPerPixel);
        let px1 = Math.round((variant.end - bpStart) / bpPerPixel);
        let pw = Math.max(1, px1 - px);
        if (pw < 3) {
          pw = 3;
          px -= 1;
        } else if (pw > 5) {
          px += 1;
          pw -= 2;
        }

        if ("NONVARIANT" === variant.type) {
          ctx.fillStyle = this.nonRefColor;
        } else if ("MIXED" === variant.type) {
          ctx.fillStyle = this.mixedColor;
        } else {
          ctx.fillStyle = this.color || this.defaultColor;
        }

        ctx.fillRect(px, py, pw, vh);

        if (nCalls > 0 && variant.calls && "COLLAPSED" !== this.displayMode) {

          let callsDrawn = 0;

          for (let callSet of callSets) {
            const call = variant.calls[callSet.id];
            if (call) {
              const py = this.variantBandHeight + vGap + (callsDrawn + variant.row) * (callHeight + vGap);
              let allVar = true;  // until proven otherwise
              let allRef = true;
              let noCall = false;
              for (let g of call.genotype) {
                if ('.' === g) {
                  noCall = true;
                  break;
                } else {
                  if (g !== 0) allRef = false;
                  if (g === 0) allVar = false;
                }
              }

              if (noCall) {
                ctx.fillStyle = this.noCallColor;
              } else if (allRef) {
                ctx.fillStyle = this.homrefColor;
              } else if (allVar) {
                ctx.fillStyle = this.homvarColor;
              } else {
                ctx.fillStyle = this.hetvarColor;
              }

              ctx.fillRect(px, py, pw, callHeight);

            }
            callsDrawn++;
          }

        }
      }
    } else {
      console.log("No feature list");
    }
  };

  /**
   * Return "popup data" for feature @ genomic location.  Data is an array of key-value pairs
   */
  popupData(clickState, featureList) {

    if (!featureList) featureList = this.clickedFeatures(clickState);

    const genomicLocation = clickState.genomicLocation;
    const genomeID = this.browser.genome.id;
    const popupData = [];
    const sampleInformation = this.browser.sampleInformation;

    for (let variant of featureList) {

      if (popupData.length > 0) {
        popupData.push('<HR>');
      }

      if ("COLLAPSED" === this.displayMode) {
        Array.prototype.push.apply(popupData, variant.popupData(genomicLocation, this.type));
      } else {
        const yOffset = clickState.y;
        const vGap = (this.displayMode === 'EXPANDED') ? this.expandedVGap : this.squishedVGap;

        if (yOffset <= this.variantBandHeight) {  // Variant
          const row = (Math.floor)((yOffset - topMargin) / (this.variantHeight + vGap));
          if (variant.row === row) {
            Array.prototype.push.apply(popupData, variant.popupData(genomicLocation, genomeID), this.type);
          }
        } else { // Genotype

          const callSets = this.callSets;
          if (callSets && variant.calls) {
            const callHeight = this.nRows * ("SQUISHED" === this.displayMode ? this.squishedCallHeight : this.expandedCallHeight);
            const row = Math.floor((yOffset - this.variantBandHeight) / (callHeight + vGap));
            if (row >= 0 && row < callSets.length) {
              const cs = callSets[row];
              const call = variant.calls[cs.id];
              Array.prototype.push.apply(popupData, extractGenotypePopupData(call, variant, genomeID, sampleInformation));
            }
          }
        }
      }

    }

    return popupData;

    /**
     * Genotype popup text.
     * @param call
     * @param variant
     * @returns {Array}
     */
    function extractGenotypePopupData(call, variant, genomeId, sampleInformation) {

      let gt = '';
      const altArray = variant.alternateBases.split(",");
      for (let allele of call.genotype) {
        if ('.' === allele) {
          gt += 'No Call';
          break;
        } else if (allele === 0) {
          gt += variant.referenceBases;
        } else {
          let alt = altArray[allele - 1].replace("<", "&lt;");
          gt += alt;
        }
      }

      let popupData = [];
      if (call.callSetName !== undefined) {
        popupData.push({ name: 'Name', value: call.callSetName });
      }
      popupData.push({ name: 'Genotype', value: gt });
      if (call.phaseset !== undefined) {
        popupData.push({ name: 'Phase set', value: call.phaseset });
      }
      if (call.genotypeLikelihood !== undefined) {
        popupData.push({ name: 'genotypeLikelihood', value: call.genotypeLikelihood.toString() });
      }

      if (sampleInformation) {
        var attr = sampleInformation.getAttributes(call.callSetName);
        if (attr) {
          Object.keys(attr).forEach(function (attrName) {
            var displayText = attrName.replace(/([A-Z])/g, " $1");
            displayText = displayText.charAt(0).toUpperCase() + displayText.slice(1);
            popupData.push({ name: displayText, value: attr[attrName] });
          });
        }
      }

      var infoKeys = Object.keys(call.info);
      if (infoKeys.length) {
        popupData.push("<hr>");
      }
      infoKeys.forEach(function (key) {
        popupData.push({ name: key, value: call.info[key] });
      });

      let cravatLinks = [];                   // TODO -- where do these get calculated?
      if (cravatLinks.length > 0) {
        popupData.push("<HR/>");
        popupData = popupData.concat(cravatLinks);
      }

      return popupData;
    }

  }


  // VariantTrack.prototype.contextMenuItemList = function (clickState) {
  //
  //     const self = this;
  //     const menuItems = [];
  //
  //     const featureList = this.clickedFeatures(clickState);
  //
  //     if (this.callSets && featureList && featureList.length > 0) {
  //
  //         featureList.forEach(function (variant) {
  //
  //             if ('str' === variant.type) {
  //
  //                 menuItems.push({
  //                     label: 'Sort by allele length',
  //                     click: function () {
  //                         sortCallSetsByAlleleLength(self.callSets, variant, self.sortDirection);
  //                         self.sortDirection = (self.sortDirection === "ASC") ? "DESC" : "ASC";
  //                         self.trackView.repaintViews();
  //                     }
  //                 });
  //
  //             }
  //
  //         });
  //     }
  //
  //
  //     function sortCallSetsByAlleleLength(callSets, variant, direction) {
  //         var d = (direction === "DESC") ? 1 : -1;
  //         Object.keys(callSets).forEach(function (property) {
  //             callSets[property].sort(function (a, b) {
  //                 var aNan = isNaN(variant.calls[a.id].genotype[0]);
  //                 var bNan = isNaN(variant.calls[b.id].genotype[0]);
  //                 if (aNan && bNan) {
  //                     return 0;
  //                 } else if (aNan) {
  //                     return 1;
  //                 } else if (bNan) {
  //                     return -1;
  //                 } else {
  //                     var a0 = getAlleleString(variant.calls[a.id], variant, 0);
  //                     var a1 = getAlleleString(variant.calls[a.id], variant, 1);
  //                     var b0 = getAlleleString(variant.calls[b.id], variant, 0);
  //                     var b1 = getAlleleString(variant.calls[b.id], variant, 1);
  //                     var result = Math.max(b0.length, b1.length) - Math.max(a0.length, a1.length);
  //                     if (result === 0) {
  //                         result = Math.min(b0.length, b1.length) - Math.min(a0.length, a1.length);
  //                     }
  //                     return d * result;
  //                 }
  //             });
  //         });
  //     }
  //
  //
  //     return menuItems;
  //
  // };

  menuItemList() {

    var self = this,
      menuItems = [];


    menuItems.push({ object: $('<div class="igv-track-menu-border-top">') });

    ["COLLAPSED", "SQUISHED", "EXPANDED"].forEach(function (displayMode) {
      var lut =
      {
        "COLLAPSED": "Collapse",
        "SQUISHED": "Squish",
        "EXPANDED": "Expand"
      };

      menuItems.push(
        {
          object: createCheckbox(lut[displayMode], displayMode === self.displayMode),
          click: function () {
            self.displayMode = displayMode;
            self.trackView.checkContentHeight();
            self.trackView.repaint();
          }
        });
    });


    return menuItems;

  }
}

const tracks = {

  'feature': (config, browser) => {
    return new FeatureTrack(config, browser);
  },

  'wig': (config, browser) => {
    return new WigTrack(config, browser);
  },
  'variant': (config, browser) => {
    return new VariantTrack(config, browser);
  }
};

const addTrack = function (name, track) {
  this.tracks[name] = track;
};

const getTrack = function (name) {
  return this.tracks[name];
};

var TrackFactory = {
  tracks,
  addTrack,
  getTrack
};

/*
* @author Jim Robinson Dec-2020
*/

const igv = {

  async createTrack(config, browser) {

    // Resolve function and promise urls
    let url = await resolveURL(config.url);
    if (isString$2(url)) {
      url = url.trim();
    }

    if (url) {
      if (config.format) {
        config.format = config.format.toLowerCase();
      } else {
        let filename = config.filename;
        if (!filename) {
          filename = await getFilename(url);
        }
        config.format = inferFileFormat(filename);
      }
    }

    let type = config.type;
    if (type && "bedtype" !== type) {
      type = type.toLowerCase();
    } else {
      type = inferTrackType(config);
      if ("bedtype" === type) {
        // Bed files must be read to determine track type
        const featureSource = FeatureSource(config, browser.genome);
        config._featureSource = featureSource;    // This is a temp variable, bit of a hack
        const trackType = await featureSource.trackType();
        if (trackType) {
          type = trackType;
        } else {
          type = "annotation";
        }
        // Record in config to make type persistent in session
        config.type = type;
      }
    }


    let track;
    switch (type) {
      case "annotation":
      case "genes":
      case "fusionjuncspan":
      case "junctions":
      case "splicejunctions":
      case "snp":
        track = TrackFactory.getTrack("feature")(config, browser);
        break;
      default:
        if (TrackFactory.tracks.hasOwnProperty(type)) {
          track = TrackFactory.getTrack(type)(config, browser);
        } else {
          track = undefined;
        }
    }

    if (config.roi && track) {
      track.roi = [];
      for (let r of config.roi) {
        track.roi.push(new ROI(r, browser.genome));
      }
    }

    return track

  }
};

function div(options) {
  return create("div", options);
}

function create(tag, options) {
  const elem = document.createElement(tag);
  if (options) {
    if (options.class) {
      elem.classList.add(options.class);
    }
    if (options.id) {
      elem.id = options.id;
    }
    if (options.style) {
      applyStyle(elem, options.style);
    }
  }
  return elem;
}

function hide(elem) {
  const cssStyle = getComputedStyle(elem);
  if (cssStyle.display !== "none") {
    elem._initialDisplay = cssStyle.display;
  }
  elem.style.display = "none";
}

function show(elem) {
  const currentDisplay = getComputedStyle(elem).display;
  if (currentDisplay === "none") {
    const d = elem._initialDisplay || "block";
    elem.style.display = d;
  }
}

function offset(elem) {
  // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
  // Support: IE <=11 only
  // Running getBoundingClientRect on a
  // disconnected node in IE throws an error
  if (!elem.getClientRects().length) {
    return { top: 0, left: 0 };
  }

  // Get document-relative position by adding viewport scroll to viewport-relative gBCR
  const rect = elem.getBoundingClientRect();
  const win = elem.ownerDocument.defaultView;
  return {
    top: rect.top + win.pageYOffset,
    left: rect.left + win.pageXOffset
  };
}

function pageCoordinates(e) {

  if (e.type.startsWith("touch")) {
    const touch = e.touches[0];
    return { x: touch.pageX, y: touch.pageY };
  } else {
    return { x: e.pageX, y: e.pageY }
  }
}

function applyStyle(elem, style) {
  for (let key of Object.keys(style)) {
    elem.style[key] = style[key];
  }
}

function createIcon(name, color) {
  return iconMarkup(name, color);
}

function iconMarkup(name, color) {
  color = color || "currentColor";
  let icon = icons[name];
  if (!icon) {
    console.error(`No icon named: ${name}`);
    icon = icons["question"];
  }

  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttributeNS(null, 'viewBox', '0 0 ' + icon[0] + ' ' + icon[1]);
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttributeNS(null, 'fill', color);
  path.setAttributeNS(null, 'd', icon[4]);
  svg.appendChild(path);
  return svg;
}

const icons = {
  "check": [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"],
  "cog": [512, 512, [], "f013", "M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z"],
  "exclamation": [192, 512, [], "f12a", "M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z"],
  "exclamation-circle": [512, 512, [], "f06a", "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
  "exclamation-triangle": [576, 512, [], "f071", "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
  "minus": [448, 512, [], "f068", "M424 318.2c13.3 0 24-10.7 24-24v-76.4c0-13.3-10.7-24-24-24H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h400z"],
  "minus-circle": [512, 512, [], "f056", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z"],
  "minus-square": [448, 512, [], "f146", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM92 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H92z"],
  "plus": [448, 512, [], "f067", "M448 294.2v-76.4c0-13.3-10.7-24-24-24H286.2V56c0-13.3-10.7-24-24-24h-76.4c-13.3 0-24 10.7-24 24v137.8H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h137.8V456c0 13.3 10.7 24 24 24h76.4c13.3 0 24-10.7 24-24V318.2H424c13.3 0 24-10.7 24-24z"],
  "plus-circle": [512, 512, [], "f055", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
  "plus-square": [448, 512, [], "f0fe", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-32 252c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92H92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
  "question": [384, 512, [], "f128", "M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"],
  "save": [448, 512, [], "f0c7", "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"],
  "search": [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"],
  "share": [512, 512, [], "f064", "M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z"],
  "spinner": [512, 512, [], "f110", "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"],
  "square": [448, 512, [], "f0c8", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z"],
  "square-full": [512, 512, [], "f45c", "M512 512H0V0h512v512z"],
  "times": [384, 512, [], "f00d", "M323.1 441l53.9-53.9c9.4-9.4 9.4-24.5 0-33.9L279.8 256l97.2-97.2c9.4-9.4 9.4-24.5 0-33.9L323.1 71c-9.4-9.4-24.5-9.4-33.9 0L192 168.2 94.8 71c-9.4-9.4-24.5-9.4-33.9 0L7 124.9c-9.4 9.4-9.4 24.5 0 33.9l97.2 97.2L7 353.2c-9.4 9.4-9.4 24.5 0 33.9L60.9 441c9.4 9.4 24.5 9.4 33.9 0l97.2-97.2 97.2 97.2c9.3 9.3 24.5 9.3 33.9 0z"],
  "times-circle": [512, 512, [], "f057", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"],
  "wrench": [512, 512, [], "f0ad", "M481.156 200c9.3 0 15.12 10.155 10.325 18.124C466.295 259.992 420.419 288 368 288c-79.222 0-143.501-63.974-143.997-143.079C223.505 65.469 288.548-.001 368.002 0c52.362.001 98.196 27.949 123.4 69.743C496.24 77.766 490.523 88 481.154 88H376l-40 56 40 56h105.156zm-171.649 93.003L109.255 493.255c-24.994 24.993-65.515 24.994-90.51 0-24.993-24.994-24.993-65.516 0-90.51L218.991 202.5c16.16 41.197 49.303 74.335 90.516 90.503zM104 432c0-13.255-10.745-24-24-24s-24 10.745-24 24 10.745 24 24 24 24-10.745 24-24z"],
};

function attachDialogCloseHandlerWithParent(parent, closeHandler) {

  var container = document.createElement("div");
  parent.appendChild(container);
  container.appendChild(createIcon("times"));
  container.addEventListener('click', function (e) {
    e.preventDefault;
    e.stopPropagation();
    closeHandler();
  });
}

/**
* @fileoverview Zlib namespace. Zlib の仕様に準拠した圧縮は Zlib.Deflate で実装
* されている. これは Inflate との共存を考慮している為.
*/
const ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE$1 = 65000;

var Zlib$1 = {
  Huffman: {},
  Util: {},
  CRC32: {}
};


/**
* Compression Method
* @enum {number}
*/
Zlib$1.CompressionMethod = {
  DEFLATE: 8,
  RESERVED: 15
};




/**
* @param {Object=} opt_params options.
* @constructor
*/
Zlib$1.Zip = function (opt_params) {
  opt_params = opt_params || {};
  /** @type {Array.<{
   *   buffer: !(Array.<number>|Uint8Array),
   *   option: Object,
   *   compressed: boolean,
   *   encrypted: boolean,
   *   size: number,
   *   crc32: number
   * }>} */
  this.files = [];
  /** @type {(Array.<number>|Uint8Array)} */
  this.comment = opt_params['comment'];
  /** @type {(Array.<number>|Uint8Array)} */
  this.password;
};


/**
* @enum {number}
*/
Zlib$1.Zip.CompressionMethod = {
  STORE: 0,
  DEFLATE: 8
};

/**
* @enum {number}
*/
Zlib$1.Zip.OperatingSystem = {
  MSDOS: 0,
  UNIX: 3,
  MACINTOSH: 7
};

/**
* @enum {number}
*/
Zlib$1.Zip.Flags = {
  ENCRYPT: 0x0001,
  DESCRIPTOR: 0x0008,
  UTF8: 0x0800
};

/**
* @type {Array.<number>}
* @const
*/
Zlib$1.Zip.FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];

/**
* @type {Array.<number>}
* @const
*/
Zlib$1.Zip.LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];

/**
* @type {Array.<number>}
* @const
*/
Zlib$1.Zip.CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];

/**
* @param {Array.<number>|Uint8Array} input
* @param {Object=} opt_params options.
*/
Zlib$1.Zip.prototype.addFile = function (input, opt_params) {
  opt_params = opt_params || {};
  /** @type {string} */
  opt_params['filename'];
  /** @type {boolean} */
  var compressed;
  /** @type {number} */
  var size = input.length;
  /** @type {number} */
  var crc32 = 0;

  if (input instanceof Array) {
    input = new Uint8Array(input);
  }

  // default
  if (typeof opt_params['compressionMethod'] !== 'number') {
    opt_params['compressionMethod'] = Zlib$1.Zip.CompressionMethod.DEFLATE;
  }

  // その場で圧縮する場合
  if (opt_params['compress']) {
    switch (opt_params['compressionMethod']) {
      case Zlib$1.Zip.CompressionMethod.STORE:
        break;
      case Zlib$1.Zip.CompressionMethod.DEFLATE:
        crc32 = Zlib$1.CRC32.calc(input);
        input = this.deflateWithOption(input, opt_params);
        compressed = true;
        break;
      default:
        throw new Error('unknown compression method:' + opt_params['compressionMethod']);
    }
  }

  this.files.push({
    buffer: input,
    option: opt_params,
    compressed: compressed,
    encrypted: false,
    size: size,
    crc32: crc32
  });
};

/**
* @param {(Array.<number>|Uint8Array)} password
*/
Zlib$1.Zip.prototype.setPassword = function (password) {
  this.password = password;
};

Zlib$1.Zip.prototype.compress = function () {
  /** @type {Array.<{
   *   buffer: !(Array.<number>|Uint8Array),
   *   option: Object,
   *   compressed: boolean,
   *   encrypted: boolean,
   *   size: number,
   *   crc32: number
   * }>} */
  var files = this.files;
  /** @type {{
   *   buffer: !(Array.<number>|Uint8Array),
   *   option: Object,
   *   compressed: boolean,
   *   encrypted: boolean,
   *   size: number,
   *   crc32: number
   * }} */
  var file;
  /** @type {!(Array.<number>|Uint8Array)} */
  var output;
  /** @type {number} */
  var op1;
  /** @type {number} */
  var op2;
  /** @type {number} */
  var op3;
  /** @type {number} */
  var localFileSize = 0;
  /** @type {number} */
  var centralDirectorySize = 0;
  /** @type {number} */
  var endOfCentralDirectorySize;
  /** @type {number} */
  var offset;
  /** @type {number} */
  var needVersion;
  /** @type {number} */
  var flags;
  /** @type {Zlib.Zip.CompressionMethod} */
  var compressionMethod;
  /** @type {Date} */
  var date;
  /** @type {number} */
  var crc32;
  /** @type {number} */
  var size;
  /** @type {number} */
  var plainSize;
  /** @type {number} */
  var filenameLength;
  /** @type {number} */
  var extraFieldLength;
  /** @type {number} */
  var commentLength;
  /** @type {(Array.<number>|Uint8Array)} */
  var filename;
  /** @type {(Array.<number>|Uint8Array)} */
  var extraField;
  /** @type {(Array.<number>|Uint8Array)} */
  var comment;
  /** @type {(Array.<number>|Uint8Array)} */
  var buffer;
  /** @type {*} */
  var tmp;
  /** @type {Array.<number>|Uint32Array|Object} */
  var key;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;
  /** @type {number} */
  var j;
  /** @type {number} */
  var jl;

  // ファイルの圧縮
  for (i = 0, il = files.length; i < il; ++i) {
    file = files[i];
    filenameLength =
      (file.option['filename']) ? file.option['filename'].length : 0;
    extraFieldLength =
      (file.option['extraField']) ? file.option['extraField'].length : 0;
    commentLength =
      (file.option['comment']) ? file.option['comment'].length : 0;

    // 圧縮されていなかったら圧縮
    if (!file.compressed) {
      // 圧縮前に CRC32 の計算をしておく
      file.crc32 = Zlib$1.CRC32.calc(file.buffer);

      switch (file.option['compressionMethod']) {
        case Zlib$1.Zip.CompressionMethod.STORE:
          break;
        case Zlib$1.Zip.CompressionMethod.DEFLATE:
          file.buffer = this.deflateWithOption(file.buffer, file.option);
          file.compressed = true;
          break;
        default:
          throw new Error('unknown compression method:' + file.option['compressionMethod']);
      }
    }

    // encryption
    if (file.option['password'] !== void 0 || this.password !== void 0) {
      // init encryption
      key = this.createEncryptionKey(file.option['password'] || this.password);

      // add header
      buffer = file.buffer;
      {
        tmp = new Uint8Array(buffer.length + 12);
        tmp.set(buffer, 12);
        buffer = tmp;
      }

      for (j = 0; j < 12; ++j) {
        buffer[j] = this.encode(
          key,
          i === 11 ? (file.crc32 & 0xff) : (Math.random() * 256 | 0)
        );
      }

      // data encryption
      for (jl = buffer.length; j < jl; ++j) {
        buffer[j] = this.encode(key, buffer[j]);
      }
      file.buffer = buffer;
    }

    // 必要バッファサイズの計算
    localFileSize +=
      // local file header
      30 + filenameLength +
      // file data
      file.buffer.length;

    centralDirectorySize +=
      // file header
      46 + filenameLength + commentLength;
  }

  // end of central directory
  endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);
  output = new (Uint8Array)(
    localFileSize + centralDirectorySize + endOfCentralDirectorySize
  );
  op1 = 0;
  op2 = localFileSize;
  op3 = op2 + centralDirectorySize;

  // ファイルの圧縮
  for (i = 0, il = files.length; i < il; ++i) {
    file = files[i];
    filenameLength =
      file.option['filename'] ? file.option['filename'].length : 0;
    extraFieldLength = 0; // TODO
    commentLength =
      file.option['comment'] ? file.option['comment'].length : 0;

    //-------------------------------------------------------------------------
    // local file header & file header
    //-------------------------------------------------------------------------

    offset = op1;

    // signature
    // local file header
    output[op1++] = Zlib$1.Zip.LocalFileHeaderSignature[0];
    output[op1++] = Zlib$1.Zip.LocalFileHeaderSignature[1];
    output[op1++] = Zlib$1.Zip.LocalFileHeaderSignature[2];
    output[op1++] = Zlib$1.Zip.LocalFileHeaderSignature[3];
    // file header
    output[op2++] = Zlib$1.Zip.FileHeaderSignature[0];
    output[op2++] = Zlib$1.Zip.FileHeaderSignature[1];
    output[op2++] = Zlib$1.Zip.FileHeaderSignature[2];
    output[op2++] = Zlib$1.Zip.FileHeaderSignature[3];

    // compressor info
    needVersion = 20;
    output[op2++] = needVersion & 0xff;
    output[op2++] =
      /** @type {Zlib.Zip.OperatingSystem} */
      (file.option['os']) ||
      Zlib$1.Zip.OperatingSystem.MSDOS;

    // need version
    output[op1++] = output[op2++] = needVersion & 0xff;
    output[op1++] = output[op2++] = (needVersion >> 8) & 0xff;

    // general purpose bit flag
    flags = 0;
    if (file.option['password'] || this.password) {
      flags |= Zlib$1.Zip.Flags.ENCRYPT;
    }
    output[op1++] = output[op2++] = flags & 0xff;
    output[op1++] = output[op2++] = (flags >> 8) & 0xff;

    // compression method
    compressionMethod =
      /** @type {Zlib.Zip.CompressionMethod} */
      (file.option['compressionMethod']);
    output[op1++] = output[op2++] = compressionMethod & 0xff;
    output[op1++] = output[op2++] = (compressionMethod >> 8) & 0xff;

    // date
    date = /** @type {(Date|undefined)} */(file.option['date']) || new Date();
    output[op1++] = output[op2++] =
      ((date.getMinutes() & 0x7) << 5) |
      (date.getSeconds() / 2 | 0);
    output[op1++] = output[op2++] =
      (date.getHours() << 3) |
      (date.getMinutes() >> 3);
    //
    output[op1++] = output[op2++] =
      ((date.getMonth() + 1 & 0x7) << 5) |
      (date.getDate());
    output[op1++] = output[op2++] =
      ((date.getFullYear() - 1980 & 0x7f) << 1) |
      (date.getMonth() + 1 >> 3);

    // CRC-32
    crc32 = file.crc32;
    output[op1++] = output[op2++] = crc32 & 0xff;
    output[op1++] = output[op2++] = (crc32 >> 8) & 0xff;
    output[op1++] = output[op2++] = (crc32 >> 16) & 0xff;
    output[op1++] = output[op2++] = (crc32 >> 24) & 0xff;

    // compressed size
    size = file.buffer.length;
    output[op1++] = output[op2++] = size & 0xff;
    output[op1++] = output[op2++] = (size >> 8) & 0xff;
    output[op1++] = output[op2++] = (size >> 16) & 0xff;
    output[op1++] = output[op2++] = (size >> 24) & 0xff;

    // uncompressed size
    plainSize = file.size;
    output[op1++] = output[op2++] = plainSize & 0xff;
    output[op1++] = output[op2++] = (plainSize >> 8) & 0xff;
    output[op1++] = output[op2++] = (plainSize >> 16) & 0xff;
    output[op1++] = output[op2++] = (plainSize >> 24) & 0xff;

    // filename length
    output[op1++] = output[op2++] = filenameLength & 0xff;
    output[op1++] = output[op2++] = (filenameLength >> 8) & 0xff;

    // extra field length
    output[op1++] = output[op2++] = extraFieldLength & 0xff;
    output[op1++] = output[op2++] = (extraFieldLength >> 8) & 0xff;

    // file comment length
    output[op2++] = commentLength & 0xff;
    output[op2++] = (commentLength >> 8) & 0xff;

    // disk number start
    output[op2++] = 0;
    output[op2++] = 0;

    // internal file attributes
    output[op2++] = 0;
    output[op2++] = 0;

    // external file attributes
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;

    // relative offset of local header
    output[op2++] = offset & 0xff;
    output[op2++] = (offset >> 8) & 0xff;
    output[op2++] = (offset >> 16) & 0xff;
    output[op2++] = (offset >> 24) & 0xff;

    // filename
    filename = file.option['filename'];
    if (filename) {
      {
        output.set(filename, op1);
        output.set(filename, op2);
        op1 += filenameLength;
        op2 += filenameLength;
      }
    }

    // extra field
    extraField = file.option['extraField'];
    if (extraField) {
      {
        output.set(extraField, op1);
        output.set(extraField, op2);
        op1 += extraFieldLength;
        op2 += extraFieldLength;
      }
    }

    // comment
    comment = file.option['comment'];
    if (comment) {
      {
        output.set(comment, op2);
        op2 += commentLength;
      }
    }

    //-------------------------------------------------------------------------
    // file data
    //-------------------------------------------------------------------------

    {
      output.set(file.buffer, op1);
      op1 += file.buffer.length;
    }
  }

  //-------------------------------------------------------------------------
  // end of central directory
  //-------------------------------------------------------------------------

  // signature
  output[op3++] = Zlib$1.Zip.CentralDirectorySignature[0];
  output[op3++] = Zlib$1.Zip.CentralDirectorySignature[1];
  output[op3++] = Zlib$1.Zip.CentralDirectorySignature[2];
  output[op3++] = Zlib$1.Zip.CentralDirectorySignature[3];

  // number of this disk
  output[op3++] = 0;
  output[op3++] = 0;

  // number of the disk with the start of the central directory
  output[op3++] = 0;
  output[op3++] = 0;

  // total number of entries in the central directory on this disk
  output[op3++] = il & 0xff;
  output[op3++] = (il >> 8) & 0xff;

  // total number of entries in the central directory
  output[op3++] = il & 0xff;
  output[op3++] = (il >> 8) & 0xff;

  // size of the central directory
  output[op3++] = centralDirectorySize & 0xff;
  output[op3++] = (centralDirectorySize >> 8) & 0xff;
  output[op3++] = (centralDirectorySize >> 16) & 0xff;
  output[op3++] = (centralDirectorySize >> 24) & 0xff;

  // offset of start of central directory with respect to the starting disk number
  output[op3++] = localFileSize & 0xff;
  output[op3++] = (localFileSize >> 8) & 0xff;
  output[op3++] = (localFileSize >> 16) & 0xff;
  output[op3++] = (localFileSize >> 24) & 0xff;

  // .ZIP file comment length
  commentLength = this.comment ? this.comment.length : 0;
  output[op3++] = commentLength & 0xff;
  output[op3++] = (commentLength >> 8) & 0xff;

  // .ZIP file comment
  if (this.comment) {
    {
      output.set(this.comment, op3);
      op3 += commentLength;
    }
  }

  return output;
};

/**
* @param {!(Array.<number>|Uint8Array)} input
* @param {Object=} opt_params options.
* @return {!(Array.<number>|Uint8Array)}
*/
Zlib$1.Zip.prototype.deflateWithOption = function (input, opt_params) {
  /** @type {Zlib.RawDeflate} */
  var deflator = new Zlib$1.RawDeflate(input, opt_params['deflateOption']);

  return deflator.compress();
};

/**
* @param {(Array.<number>|Uint32Array)} key
* @return {number}
*/
Zlib$1.Zip.prototype.getByte = function (key) {
  /** @type {number} */
  var tmp = ((key[2] & 0xffff) | 2);

  return ((tmp * (tmp ^ 1)) >> 8) & 0xff;
};

/**
* @param {(Array.<number>|Uint32Array|Object)} key
* @param {number} n
* @return {number}
*/
Zlib$1.Zip.prototype.encode = function (key, n) {
  /** @type {number} */
  var tmp = this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));

  this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);

  return tmp ^ n;
};

/**
* @param {(Array.<number>|Uint32Array)} key
* @param {number} n
*/
Zlib$1.Zip.prototype.updateKeys = function (key, n) {
  key[0] = Zlib$1.CRC32.single(key[0], n);
  key[1] =
    (((((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681) >>> 0) + 1) >>> 0;
  key[2] = Zlib$1.CRC32.single(key[2], key[1] >>> 24);
};

/**
* @param {(Array.<number>|Uint8Array)} password
* @return {!(Array.<number>|Uint32Array|Object)}
*/
Zlib$1.Zip.prototype.createEncryptionKey = function (password) {
  /** @type {!(Array.<number>|Uint32Array)} */
  var key = [305419896, 591751049, 878082192];
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  {
    key = new Uint32Array(key);
  }

  for (i = 0, il = password.length; i < il; ++i) {
    this.updateKeys(key, password[i] & 0xff);
  }

  return key;
};



/**
* build huffman table from length list.
* @param {!(Array.<number>|Uint8Array)} lengths length list.
* @return {!Array} huffman table.
*/
Zlib$1.Huffman.buildHuffmanTable = function (lengths) {
  /** @type {number} length list size. */
  var listSize = lengths.length;
  /** @type {number} max code length for table size. */
  var maxCodeLength = 0;
  /** @type {number} min code length for table size. */
  var minCodeLength = Number.POSITIVE_INFINITY;
  /** @type {number} table size. */
  var size;
  /** @type {!(Array|Uint8Array)} huffman code table. */
  var table;
  /** @type {number} bit length. */
  var bitLength;
  /** @type {number} huffman code. */
  var code;
  /**
   * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.
   * @type {number} skip length for table filling.
   */
  var skip;
  /** @type {number} reversed code. */
  var reversed;
  /** @type {number} reverse temp. */
  var rtemp;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limit. */
  var il;
  /** @type {number} loop counter. */
  var j;
  /** @type {number} table value. */
  var value;

  // Math.max は遅いので最長の値は for-loop で取得する
  for (i = 0, il = listSize; i < il; ++i) {
    if (lengths[i] > maxCodeLength) {
      maxCodeLength = lengths[i];
    }
    if (lengths[i] < minCodeLength) {
      minCodeLength = lengths[i];
    }
  }

  size = 1 << maxCodeLength;
  table = new (Uint32Array)(size);

  // ビット長の短い順からハフマン符号を割り当てる
  for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {
    for (i = 0; i < listSize; ++i) {
      if (lengths[i] === bitLength) {
        // ビットオーダーが逆になるためビット長分並びを反転する
        for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {
          reversed = (reversed << 1) | (rtemp & 1);
          rtemp >>= 1;
        }

        // 最大ビット長をもとにテーブルを作るため、
        // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる
        // そのどちらでも良い場所は同じ値で埋めることで
        // 本来のビット長以上のビット数取得しても問題が起こらないようにする
        value = (bitLength << 16) | i;
        for (j = reversed; j < size; j += skip) {
          table[j] = value;
        }

        ++code;
      }
    }

    // 次のビット長へ
    ++bitLength;
    code <<= 1;
    skip <<= 1;
  }

  return [table, maxCodeLength, minCodeLength];
};




//-----------------------------------------------------------------------------

/** @define {number} buffer block size. */
var ZLIB_RAW_INFLATE_BUFFER_SIZE$1 = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]

//-----------------------------------------------------------------------------


var buildHuffmanTable$1 = Zlib$1.Huffman.buildHuffmanTable;

/**
* @constructor
* @param {!(Uint8Array|Array.<number>)} input input buffer.
* @param {Object} opt_params option parameter.
*
* opt_params は以下のプロパティを指定する事ができます。
*   - index: input buffer の deflate コンテナの開始位置.
*   - blockSize: バッファのブロックサイズ.
*   - bufferType: Zlib.RawInflate.BufferType の値によってバッファの管理方法を指定する.
*   - resize: 確保したバッファが実際の大きさより大きかった場合に切り詰める.
*/
Zlib$1.RawInflate = function (input, opt_params) {
  /** @type {!(Array.<number>|Uint8Array)} inflated buffer */
  this.buffer;
  /** @type {!Array.<(Array.<number>|Uint8Array)>} */
  this.blocks = [];
  /** @type {number} block size. */
  this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE$1;
  /** @type {!number} total output buffer pointer. */
  this.totalpos = 0;
  /** @type {!number} input buffer pointer. */
  this.ip = 0;
  /** @type {!number} bit stream reader buffer. */
  this.bitsbuf = 0;
  /** @type {!number} bit stream reader buffer size. */
  this.bitsbuflen = 0;
  /** @type {!(Array.<number>|Uint8Array)} input buffer. */
  this.input = new Uint8Array(input);
  /** @type {!(Uint8Array|Array.<number>)} output buffer. */
  this.output;
  /** @type {!number} output buffer pointer. */
  this.op;
  /** @type {boolean} is final block flag. */
  this.bfinal = false;
  /** @type {Zlib.RawInflate.BufferType} buffer management. */
  this.bufferType = Zlib$1.RawInflate.BufferType.ADAPTIVE;
  /** @type {boolean} resize flag for memory size optimization. */
  this.resize = false;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (opt_params['index']) {
      this.ip = opt_params['index'];
    }
    if (opt_params['bufferSize']) {
      this.bufferSize = opt_params['bufferSize'];
    }
    if (opt_params['bufferType']) {
      this.bufferType = opt_params['bufferType'];
    }
    if (opt_params['resize']) {
      this.resize = opt_params['resize'];
    }
  }

  // initialize
  switch (this.bufferType) {
    case Zlib$1.RawInflate.BufferType.BLOCK:
      this.op = Zlib$1.RawInflate.MaxBackwardLength;
      this.output =
        new (Uint8Array)(
          Zlib$1.RawInflate.MaxBackwardLength +
          this.bufferSize +
          Zlib$1.RawInflate.MaxCopyLength
        );
      break;
    case Zlib$1.RawInflate.BufferType.ADAPTIVE:
      this.op = 0;
      this.output = new (Uint8Array)(this.bufferSize);
      break;
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
* @enum {number}
*/
Zlib$1.RawInflate.BufferType = {
  BLOCK: 0,
  ADAPTIVE: 1
};

/**
* decompress.
* @return {!(Uint8Array|Array.<number>)} inflated buffer.
*/
Zlib$1.RawInflate.prototype.decompress = function () {
  while (!this.bfinal) {
    this.parseBlock();
  }

  switch (this.bufferType) {
    case Zlib$1.RawInflate.BufferType.BLOCK:
      return this.concatBufferBlock();
    case Zlib$1.RawInflate.BufferType.ADAPTIVE:
      return this.concatBufferDynamic();
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
* @const
* @type {number} max backward length for LZ77.
*/
Zlib$1.RawInflate.MaxBackwardLength = 32768;

/**
* @const
* @type {number} max copy length for LZ77.
*/
Zlib$1.RawInflate.MaxCopyLength = 258;

/**
* huffman order
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib$1.RawInflate.Order = (function (table) {
  return new Uint16Array(table);
})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

/**
* huffman length code table.
* @const
* @type {!(Array.<number>|Uint16Array)}
*/
Zlib$1.RawInflate.LengthCodeTable = (function (table) {
  return new Uint16Array(table);
})([
  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,
  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,
  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,
  0x00e3, 0x0102, 0x0102, 0x0102
]);

/**
* huffman length extra-bits table.
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib$1.RawInflate.LengthExtraTable = (function (table) {
  return new Uint8Array(table);
})([
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 5, 0, 0, 0
]);

/**
* huffman dist code table.
* @const
* @type {!(Array.<number>|Uint16Array)}
*/
Zlib$1.RawInflate.DistCodeTable = (function (table) {
  return new Uint16Array(table);
})([
  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,
  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,
  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,
  0x3001, 0x4001, 0x6001
]);

/**
* huffman dist extra-bits table.
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib$1.RawInflate.DistExtraTable = (function (table) {
  return new Uint8Array(table);
})([
  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
  11, 12, 12, 13, 13
]);

/**
* fixed huffman length code table
* @const
* @type {!Array}
*/
Zlib$1.RawInflate.FixedLiteralLengthTable = (function (table) {
  return table;
})((function () {
  var lengths = new (Uint8Array)(288);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] =
      (i <= 143) ? 8 :
        (i <= 255) ? 9 :
          (i <= 279) ? 7 :
            8;
  }

  return buildHuffmanTable$1(lengths);
})());

/**
* fixed huffman distance code table
* @const
* @type {!Array}
*/
Zlib$1.RawInflate.FixedDistanceTable = (function (table) {
  return table;
})((function () {
  var lengths = new (Uint8Array)(30);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = 5;
  }

  return buildHuffmanTable$1(lengths);
})());

/**
* parse deflated block.
*/
Zlib$1.RawInflate.prototype.parseBlock = function () {
  /** @type {number} header */
  var hdr = this.readBits(3);

  // BFINAL
  if (hdr & 0x1) {
    this.bfinal = true;
  }

  // BTYPE
  hdr >>>= 1;
  switch (hdr) {
    // uncompressed
    case 0:
      this.parseUncompressedBlock();
      break;
    // fixed huffman
    case 1:
      this.parseFixedHuffmanBlock();
      break;
    // dynamic huffman
    case 2:
      this.parseDynamicHuffmanBlock();
      break;
    // reserved or other
    default:
      throw new Error('unknown BTYPE: ' + hdr);
  }
};

/**
* read inflate bits
* @param {number} length bits length.
* @return {number} read bits.
*/
Zlib$1.RawInflate.prototype.readBits = function (length) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} */
  var inputLength = input.length;
  /** @type {number} input and output byte. */
  var octet;

  // input byte
  if (ip + ((length - bitsbuflen + 7) >> 3) >= inputLength) {
    throw new Error('input buffer is broken');
  }

  // not enough buffer
  while (bitsbuflen < length) {
    bitsbuf |= input[ip++] << bitsbuflen;
    bitsbuflen += 8;
  }

  // output byte
  octet = bitsbuf & /* MASK */ ((1 << length) - 1);
  bitsbuf >>>= length;
  bitsbuflen -= length;

  this.bitsbuf = bitsbuf;
  this.bitsbuflen = bitsbuflen;
  this.ip = ip;

  return octet;
};

/**
* read huffman code using table
* @param {!(Array.<number>|Uint8Array|Uint16Array)} table huffman code table.
* @return {number} huffman code.
*/
Zlib$1.RawInflate.prototype.readCodeByTable = function (table) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} */
  var inputLength = input.length;
  /** @type {!(Array.<number>|Uint8Array)} huffman code table */
  var codeTable = table[0];
  /** @type {number} */
  var maxCodeLength = table[1];
  /** @type {number} code length & code (16bit, 16bit) */
  var codeWithLength;
  /** @type {number} code bits length */
  var codeLength;

  // not enough buffer
  while (bitsbuflen < maxCodeLength) {
    if (ip >= inputLength) {
      break;
    }
    bitsbuf |= input[ip++] << bitsbuflen;
    bitsbuflen += 8;
  }

  // read max length
  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];
  codeLength = codeWithLength >>> 16;

  if (codeLength > bitsbuflen) {
    throw new Error('invalid code length: ' + codeLength);
  }

  this.bitsbuf = bitsbuf >> codeLength;
  this.bitsbuflen = bitsbuflen - codeLength;
  this.ip = ip;

  return codeWithLength & 0xffff;
};

/**
* parse uncompressed block.
*/
Zlib$1.RawInflate.prototype.parseUncompressedBlock = function () {
  var input = this.input;
  var ip = this.ip;
  var output = this.output;
  var op = this.op;

  /** @type {number} */
  var inputLength = input.length;
  /** @type {number} block length */
  var len;
  /** @type {number} number for check block length */
  var nlen;
  /** @type {number} output buffer length */
  var olength = output.length;
  /** @type {number} copy counter */
  var preCopy;

  // skip buffered header bits
  this.bitsbuf = 0;
  this.bitsbuflen = 0;

  // len
  if (ip + 1 >= inputLength) {
    throw new Error('invalid uncompressed block header: LEN');
  }
  len = input[ip++] | (input[ip++] << 8);

  // nlen
  if (ip + 1 >= inputLength) {
    throw new Error('invalid uncompressed block header: NLEN');
  }
  nlen = input[ip++] | (input[ip++] << 8);

  // check len & nlen
  if (len === ~nlen) {
    throw new Error('invalid uncompressed block header: length verify');
  }

  // check size
  if (ip + len > input.length) { throw new Error('input buffer is broken'); }

  // expand buffer
  switch (this.bufferType) {
    case Zlib$1.RawInflate.BufferType.BLOCK:
      // pre copy
      while (op + len > output.length) {
        preCopy = olength - op;
        len -= preCopy;
        {
          output.set(input.subarray(ip, ip + preCopy), op);
          op += preCopy;
          ip += preCopy;
        }
        this.op = op;
        output = this.expandBufferBlock();
        op = this.op;
      }
      break;
    case Zlib$1.RawInflate.BufferType.ADAPTIVE:
      while (op + len > output.length) {
        output = this.expandBufferAdaptive({ fixRatio: 2 });
      }
      break;
    default:
      throw new Error('invalid inflate mode');
  }

  // copy
  {
    output.set(input.subarray(ip, ip + len), op);
    op += len;
    ip += len;
  }

  this.ip = ip;
  this.op = op;
  this.output = output;
};

/**
* parse fixed huffman block.
*/
Zlib$1.RawInflate.prototype.parseFixedHuffmanBlock = function () {
  switch (this.bufferType) {
    case Zlib$1.RawInflate.BufferType.ADAPTIVE:
      this.decodeHuffmanAdaptive(
        Zlib$1.RawInflate.FixedLiteralLengthTable,
        Zlib$1.RawInflate.FixedDistanceTable
      );
      break;
    case Zlib$1.RawInflate.BufferType.BLOCK:
      this.decodeHuffmanBlock(
        Zlib$1.RawInflate.FixedLiteralLengthTable,
        Zlib$1.RawInflate.FixedDistanceTable
      );
      break;
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
* parse dynamic huffman block.
*/
Zlib$1.RawInflate.prototype.parseDynamicHuffmanBlock = function () {
  /** @type {number} number of literal and length codes. */
  var hlit = this.readBits(5) + 257;
  /** @type {number} number of distance codes. */
  var hdist = this.readBits(5) + 1;
  /** @type {number} number of code lengths. */
  var hclen = this.readBits(4) + 4;
  /** @type {!(Uint8Array|Array.<number>)} code lengths. */
  var codeLengths =
    new (Uint8Array)(Zlib$1.RawInflate.Order.length);
  /** @type {!Array} code lengths table. */
  var codeLengthsTable;
  /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */
  var litlenTable;
  /** @type {!(Uint8Array|Array.<number>)} distance code table. */
  var distTable;
  /** @type {!(Uint8Array|Array.<number>)} code length table. */
  var lengthTable;
  /** @type {number} */
  var code;
  /** @type {number} */
  var prev;
  /** @type {number} */
  var repeat;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limit. */
  var il;

  // decode code lengths
  for (i = 0; i < hclen; ++i) {
    codeLengths[Zlib$1.RawInflate.Order[i]] = this.readBits(3);
  }

  // decode length table
  codeLengthsTable = buildHuffmanTable$1(codeLengths);
  lengthTable = new (Uint8Array)(hlit + hdist);
  for (i = 0, il = hlit + hdist; i < il;) {
    code = this.readCodeByTable(codeLengthsTable);
    switch (code) {
      case 16:
        repeat = 3 + this.readBits(2);
        while (repeat--) { lengthTable[i++] = prev; }
        break;
      case 17:
        repeat = 3 + this.readBits(3);
        while (repeat--) { lengthTable[i++] = 0; }
        prev = 0;
        break;
      case 18:
        repeat = 11 + this.readBits(7);
        while (repeat--) { lengthTable[i++] = 0; }
        prev = 0;
        break;
      default:
        lengthTable[i++] = code;
        prev = code;
        break;
    }
  }

  litlenTable = buildHuffmanTable$1(lengthTable.subarray(0, hlit))
    ;
  distTable = buildHuffmanTable$1(lengthTable.subarray(hlit))
    ;

  switch (this.bufferType) {
    case Zlib$1.RawInflate.BufferType.ADAPTIVE:
      this.decodeHuffmanAdaptive(litlenTable, distTable);
      break;
    case Zlib$1.RawInflate.BufferType.BLOCK:
      this.decodeHuffmanBlock(litlenTable, distTable);
      break;
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
* decode huffman code
* @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.
* @param {!(Array.<number>|Uint8Array)} dist distination code table.
*/
Zlib$1.RawInflate.prototype.decodeHuffmanBlock = function (litlen, dist) {
  var output = this.output;
  var op = this.op;

  this.currentLitlenTable = litlen;

  /** @type {number} output position limit. */
  var olength = output.length - Zlib$1.RawInflate.MaxCopyLength;
  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  var lengthCodeTable = Zlib$1.RawInflate.LengthCodeTable;
  var lengthExtraTable = Zlib$1.RawInflate.LengthExtraTable;
  var distCodeTable = Zlib$1.RawInflate.DistCodeTable;
  var distExtraTable = Zlib$1.RawInflate.DistExtraTable;

  while ((code = this.readCodeByTable(litlen)) !== 256) {
    // literal
    if (code < 256) {
      if (op >= olength) {
        this.op = op;
        output = this.expandBufferBlock();
        op = this.op;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = lengthCodeTable[ti];
    if (lengthExtraTable[ti] > 0) {
      codeLength += this.readBits(lengthExtraTable[ti]);
    }

    // dist code
    code = this.readCodeByTable(dist);
    codeDist = distCodeTable[code];
    if (distExtraTable[code] > 0) {
      codeDist += this.readBits(distExtraTable[code]);
    }

    // lz77 decode
    if (op >= olength) {
      this.op = op;
      output = this.expandBufferBlock();
      op = this.op;
    }
    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};

/**
* decode huffman code (adaptive)
* @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.
* @param {!(Array.<number>|Uint8Array)} dist distination code table.
*/
Zlib$1.RawInflate.prototype.decodeHuffmanAdaptive = function (litlen, dist) {
  var output = this.output;
  var op = this.op;

  this.currentLitlenTable = litlen;

  /** @type {number} output position limit. */
  var olength = output.length;
  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  var lengthCodeTable = Zlib$1.RawInflate.LengthCodeTable;
  var lengthExtraTable = Zlib$1.RawInflate.LengthExtraTable;
  var distCodeTable = Zlib$1.RawInflate.DistCodeTable;
  var distExtraTable = Zlib$1.RawInflate.DistExtraTable;

  while ((code = this.readCodeByTable(litlen)) !== 256) {
    // literal
    if (code < 256) {
      if (op >= olength) {
        output = this.expandBufferAdaptive();
        olength = output.length;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = lengthCodeTable[ti];
    if (lengthExtraTable[ti] > 0) {
      codeLength += this.readBits(lengthExtraTable[ti]);
    }

    // dist code
    code = this.readCodeByTable(dist);
    codeDist = distCodeTable[code];
    if (distExtraTable[code] > 0) {
      codeDist += this.readBits(distExtraTable[code]);
    }

    // lz77 decode
    if (op + codeLength > olength) {
      output = this.expandBufferAdaptive();
      olength = output.length;
    }
    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};

/**
* expand output buffer.
* @param {Object=} opt_param option parameters.
* @return {!(Array.<number>|Uint8Array)} output buffer.
*/
Zlib$1.RawInflate.prototype.expandBufferBlock = function (opt_param) {
  /** @type {!(Array.<number>|Uint8Array)} store buffer. */
  var buffer =
    new (Uint8Array)(
      this.op - Zlib$1.RawInflate.MaxBackwardLength
    );
  /** @type {number} backward base point */
  var backward = this.op - Zlib$1.RawInflate.MaxBackwardLength;

  var output = this.output;

  // copy to output buffer
  {
    buffer.set(output.subarray(Zlib$1.RawInflate.MaxBackwardLength, buffer.length));
  }

  this.blocks.push(buffer);
  this.totalpos += buffer.length;

  // copy to backward buffer
  {
    output.set(
      output.subarray(backward, backward + Zlib$1.RawInflate.MaxBackwardLength)
    );
  }

  this.op = Zlib$1.RawInflate.MaxBackwardLength;

  return output;
};

/**
* expand output buffer. (adaptive)
* @param {Object=} opt_param option parameters.
* @return {!(Array.<number>|Uint8Array)} output buffer pointer.
*/
Zlib$1.RawInflate.prototype.expandBufferAdaptive = function (opt_param) {
  /** @type {!(Array.<number>|Uint8Array)} store buffer. */
  var buffer;
  /** @type {number} expantion ratio. */
  var ratio = (this.input.length / this.ip + 1) | 0;
  /** @type {number} maximum number of huffman code. */
  var maxHuffCode;
  /** @type {number} new output buffer size. */
  var newSize;
  /** @type {number} max inflate size. */
  var maxInflateSize;

  var input = this.input;
  var output = this.output;

  if (opt_param) {
    if (typeof opt_param.fixRatio === 'number') {
      ratio = opt_param.fixRatio;
    }
    if (typeof opt_param.addRatio === 'number') {
      ratio += opt_param.addRatio;
    }
  }

  // calculate new buffer size
  if (ratio < 2) {
    maxHuffCode =
      (input.length - this.ip) / this.currentLitlenTable[2];
    maxInflateSize = (maxHuffCode / 2 * 258) | 0;
    newSize = maxInflateSize < output.length ?
      output.length + maxInflateSize :
      output.length << 1;
  } else {
    newSize = output.length * ratio;
  }

  // buffer expantion
  {
    buffer = new Uint8Array(newSize);
    buffer.set(output);
  }

  this.output = buffer;

  return this.output;
};

/**
* concat output buffer.
* @return {!(Array.<number>|Uint8Array)} output buffer.
*/
Zlib$1.RawInflate.prototype.concatBufferBlock = function () {
  /** @type {number} buffer pointer. */
  var pos = 0;
  /** @type {number} buffer pointer. */
  var limit = this.totalpos + (this.op - Zlib$1.RawInflate.MaxBackwardLength);
  /** @type {!(Array.<number>|Uint8Array)} output block array. */
  var output = this.output;
  /** @type {!Array} blocks array. */
  var blocks = this.blocks;
  /** @type {!(Array.<number>|Uint8Array)} output block array. */
  var block;
  /** @type {!(Array.<number>|Uint8Array)} output buffer. */
  var buffer = new (Uint8Array)(limit);
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limiter. */
  var il;
  /** @type {number} loop counter. */
  var j;
  /** @type {number} loop limiter. */
  var jl;

  // single buffer
  if (blocks.length === 0) {
    return this.output.subarray(Zlib$1.RawInflate.MaxBackwardLength, this.op);
  }

  // copy to buffer
  for (i = 0, il = blocks.length; i < il; ++i) {
    block = blocks[i];
    for (j = 0, jl = block.length; j < jl; ++j) {
      buffer[pos++] = block[j];
    }
  }

  // current buffer
  for (i = Zlib$1.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {
    buffer[pos++] = output[i];
  }

  this.blocks = [];
  this.buffer = buffer;

  return this.buffer;
};

/**
* concat output buffer. (dynamic)
* @return {!(Array.<number>|Uint8Array)} output buffer.
*/
Zlib$1.RawInflate.prototype.concatBufferDynamic = function () {
  /** @type {Array.<number>|Uint8Array} output buffer. */
  var buffer;
  var op = this.op;

  {
    if (this.resize) {
      buffer = new Uint8Array(op);
      buffer.set(this.output.subarray(0, op));
    } else {
      buffer = this.output.subarray(0, op);
    }
  }

  this.buffer = buffer;

  return this.buffer;
};




var buildHuffmanTable$1 = Zlib$1.Huffman.buildHuffmanTable;

/**
* @param {!(Uint8Array|Array.<number>)} input input buffer.
* @param {number} ip input buffer pointer.
* @param {number=} opt_buffersize buffer block size.
* @constructor
*/
Zlib$1.RawInflateStream = function (input, ip, opt_buffersize) {
  /** @type {!Array.<(Array|Uint8Array)>} */
  this.blocks = [];
  /** @type {number} block size. */
  this.bufferSize =
    opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE$1;
  /** @type {!number} total output buffer pointer. */
  this.totalpos = 0;
  /** @type {!number} input buffer pointer. */
  this.ip = ip === void 0 ? 0 : ip;
  /** @type {!number} bit stream reader buffer. */
  this.bitsbuf = 0;
  /** @type {!number} bit stream reader buffer size. */
  this.bitsbuflen = 0;
  /** @type {!(Array|Uint8Array)} input buffer. */
  this.input = new Uint8Array(input);
  /** @type {!(Uint8Array|Array)} output buffer. */
  this.output = new (Uint8Array)(this.bufferSize);
  /** @type {!number} output buffer pointer. */
  this.op = 0;
  /** @type {boolean} is final block flag. */
  this.bfinal = false;
  /** @type {number} uncompressed block length. */
  this.blockLength;
  /** @type {boolean} resize flag for memory size optimization. */
  this.resize = false;
  /** @type {Array} */
  this.litlenTable;
  /** @type {Array} */
  this.distTable;
  /** @type {number} */
  this.sp = 0; // stream pointer
  /** @type {Zlib.RawInflateStream.Status} */
  this.status = Zlib$1.RawInflateStream.Status.INITIALIZED;

  //
  // backup
  //
  /** @type {!number} */
  this.ip_;
  /** @type {!number} */
  this.bitsbuflen_;
  /** @type {!number} */
  this.bitsbuf_;
};

/**
* @enum {number}
*/
Zlib$1.RawInflateStream.BlockType = {
  UNCOMPRESSED: 0,
  FIXED: 1,
  DYNAMIC: 2
};

/**
* @enum {number}
*/
Zlib$1.RawInflateStream.Status = {
  INITIALIZED: 0,
  BLOCK_HEADER_START: 1,
  BLOCK_HEADER_END: 2,
  BLOCK_BODY_START: 3,
  BLOCK_BODY_END: 4,
  DECODE_BLOCK_START: 5,
  DECODE_BLOCK_END: 6
};

/**
* decompress.
* @return {!(Uint8Array|Array)} inflated buffer.
*/
Zlib$1.RawInflateStream.prototype.decompress = function (newInput, ip) {
  /** @type {boolean} */
  var stop = false;

  if (newInput !== void 0) {
    this.input = newInput;
  }

  if (ip !== void 0) {
    this.ip = ip;
  }

  // decompress
  while (!stop) {
    switch (this.status) {
      // block header
      case Zlib$1.RawInflateStream.Status.INITIALIZED:
      case Zlib$1.RawInflateStream.Status.BLOCK_HEADER_START:
        if (this.readBlockHeader() < 0) {
          stop = true;
        }
        break;
      // block body
      case Zlib$1.RawInflateStream.Status.BLOCK_HEADER_END: /* FALLTHROUGH */
      case Zlib$1.RawInflateStream.Status.BLOCK_BODY_START:
        switch (this.currentBlockType) {
          case Zlib$1.RawInflateStream.BlockType.UNCOMPRESSED:
            if (this.readUncompressedBlockHeader() < 0) {
              stop = true;
            }
            break;
          case Zlib$1.RawInflateStream.BlockType.FIXED:
            if (this.parseFixedHuffmanBlock() < 0) {
              stop = true;
            }
            break;
          case Zlib$1.RawInflateStream.BlockType.DYNAMIC:
            if (this.parseDynamicHuffmanBlock() < 0) {
              stop = true;
            }
            break;
        }
        break;
      // decode data
      case Zlib$1.RawInflateStream.Status.BLOCK_BODY_END:
      case Zlib$1.RawInflateStream.Status.DECODE_BLOCK_START:
        switch (this.currentBlockType) {
          case Zlib$1.RawInflateStream.BlockType.UNCOMPRESSED:
            if (this.parseUncompressedBlock() < 0) {
              stop = true;
            }
            break;
          case Zlib$1.RawInflateStream.BlockType.FIXED: /* FALLTHROUGH */
          case Zlib$1.RawInflateStream.BlockType.DYNAMIC:
            if (this.decodeHuffman() < 0) {
              stop = true;
            }
            break;
        }
        break;
      case Zlib$1.RawInflateStream.Status.DECODE_BLOCK_END:
        if (this.bfinal) {
          stop = true;
        } else {
          this.status = Zlib$1.RawInflateStream.Status.INITIALIZED;
        }
        break;
    }
  }

  return this.concatBuffer();
};

/**
* @const
* @type {number} max backward length for LZ77.
*/
Zlib$1.RawInflateStream.MaxBackwardLength = 32768;

/**
* @const
* @type {number} max copy length for LZ77.
*/
Zlib$1.RawInflateStream.MaxCopyLength = 258;

/**
* huffman order
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib$1.RawInflateStream.Order = (function (table) {
  return new Uint16Array(table);
})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

/**
* huffman length code table.
* @const
* @type {!(Array.<number>|Uint16Array)}
*/
Zlib$1.RawInflateStream.LengthCodeTable = (function (table) {
  return new Uint16Array(table);
})([
  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,
  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,
  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,
  0x00e3, 0x0102, 0x0102, 0x0102
]);

/**
* huffman length extra-bits table.
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib$1.RawInflateStream.LengthExtraTable = (function (table) {
  return new Uint8Array(table);
})([
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 5, 0, 0, 0
]);

/**
* huffman dist code table.
* @const
* @type {!(Array.<number>|Uint16Array)}
*/
Zlib$1.RawInflateStream.DistCodeTable = (function (table) {
  return new Uint16Array(table);
})([
  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,
  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,
  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,
  0x3001, 0x4001, 0x6001
]);

/**
* huffman dist extra-bits table.
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib$1.RawInflateStream.DistExtraTable = (function (table) {
  return new Uint8Array(table);
})([
  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
  11, 12, 12, 13, 13
]);

/**
* fixed huffman length code table
* @const
* @type {!Array}
*/
Zlib$1.RawInflateStream.FixedLiteralLengthTable = (function (table) {
  return table;
})((function () {
  var lengths = new (Uint8Array)(288);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] =
      (i <= 143) ? 8 :
        (i <= 255) ? 9 :
          (i <= 279) ? 7 :
            8;
  }

  return buildHuffmanTable$1(lengths);
})());

/**
* fixed huffman distance code table
* @const
* @type {!Array}
*/
Zlib$1.RawInflateStream.FixedDistanceTable = (function (table) {
  return table;
})((function () {
  var lengths = new (Uint8Array)(30);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = 5;
  }

  return buildHuffmanTable$1(lengths);
})());

/**
* parse deflated block.
*/
Zlib$1.RawInflateStream.prototype.readBlockHeader = function () {
  /** @type {number} header */
  var hdr;

  this.status = Zlib$1.RawInflateStream.Status.BLOCK_HEADER_START;

  this.save_();
  if ((hdr = this.readBits(3)) < 0) {
    this.restore_();
    return -1;
  }

  // BFINAL
  if (hdr & 0x1) {
    this.bfinal = true;
  }

  // BTYPE
  hdr >>>= 1;
  switch (hdr) {
    case 0: // uncompressed
      this.currentBlockType = Zlib$1.RawInflateStream.BlockType.UNCOMPRESSED;
      break;
    case 1: // fixed huffman
      this.currentBlockType = Zlib$1.RawInflateStream.BlockType.FIXED;
      break;
    case 2: // dynamic huffman
      this.currentBlockType = Zlib$1.RawInflateStream.BlockType.DYNAMIC;
      break;
    default: // reserved or other
      throw new Error('unknown BTYPE: ' + hdr);
  }

  this.status = Zlib$1.RawInflateStream.Status.BLOCK_HEADER_END;
};

/**
* read inflate bits
* @param {number} length bits length.
* @return {number} read bits.
*/
Zlib$1.RawInflateStream.prototype.readBits = function (length) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} input and output byte. */
  var octet;

  // not enough buffer
  while (bitsbuflen < length) {
    // input byte
    if (input.length <= ip) {
      return -1;
    }
    octet = input[ip++];

    // concat octet
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }

  // output byte
  octet = bitsbuf & /* MASK */ ((1 << length) - 1);
  bitsbuf >>>= length;
  bitsbuflen -= length;

  this.bitsbuf = bitsbuf;
  this.bitsbuflen = bitsbuflen;
  this.ip = ip;

  return octet;
};

/**
* read huffman code using table
* @param {Array} table huffman code table.
* @return {number} huffman code.
*/
Zlib$1.RawInflateStream.prototype.readCodeByTable = function (table) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {!(Array|Uint8Array)} huffman code table */
  var codeTable = table[0];
  /** @type {number} */
  var maxCodeLength = table[1];
  /** @type {number} input byte */
  var octet;
  /** @type {number} code length & code (16bit, 16bit) */
  var codeWithLength;
  /** @type {number} code bits length */
  var codeLength;

  // not enough buffer
  while (bitsbuflen < maxCodeLength) {
    if (input.length <= ip) {
      return -1;
    }
    octet = input[ip++];
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }

  // read max length
  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];
  codeLength = codeWithLength >>> 16;

  if (codeLength > bitsbuflen) {
    throw new Error('invalid code length: ' + codeLength);
  }

  this.bitsbuf = bitsbuf >> codeLength;
  this.bitsbuflen = bitsbuflen - codeLength;
  this.ip = ip;

  return codeWithLength & 0xffff;
};

/**
* read uncompressed block header
*/
Zlib$1.RawInflateStream.prototype.readUncompressedBlockHeader = function () {
  /** @type {number} block length */
  var len;
  /** @type {number} number for check block length */
  var nlen;

  var input = this.input;
  var ip = this.ip;

  this.status = Zlib$1.RawInflateStream.Status.BLOCK_BODY_START;

  if (ip + 4 >= input.length) {
    return -1;
  }

  len = input[ip++] | (input[ip++] << 8);
  nlen = input[ip++] | (input[ip++] << 8);

  // check len & nlen
  if (len === ~nlen) {
    throw new Error('invalid uncompressed block header: length verify');
  }

  // skip buffered header bits
  this.bitsbuf = 0;
  this.bitsbuflen = 0;

  this.ip = ip;
  this.blockLength = len;
  this.status = Zlib$1.RawInflateStream.Status.BLOCK_BODY_END;
};

/**
* parse uncompressed block.
*/
Zlib$1.RawInflateStream.prototype.parseUncompressedBlock = function () {
  var input = this.input;
  var ip = this.ip;
  var output = this.output;
  var op = this.op;
  var len = this.blockLength;

  this.status = Zlib$1.RawInflateStream.Status.DECODE_BLOCK_START;

  // copy
  // XXX: とりあえず素直にコピー
  while (len--) {
    if (op === output.length) {
      output = this.expandBuffer({ fixRatio: 2 });
    }

    // not enough input buffer
    if (ip >= input.length) {
      this.ip = ip;
      this.op = op;
      this.blockLength = len + 1; // コピーしてないので戻す
      return -1;
    }

    output[op++] = input[ip++];
  }

  if (len < 0) {
    this.status = Zlib$1.RawInflateStream.Status.DECODE_BLOCK_END;
  }

  this.ip = ip;
  this.op = op;

  return 0;
};

/**
* parse fixed huffman block.
*/
Zlib$1.RawInflateStream.prototype.parseFixedHuffmanBlock = function () {
  this.status = Zlib$1.RawInflateStream.Status.BLOCK_BODY_START;

  this.litlenTable = Zlib$1.RawInflateStream.FixedLiteralLengthTable;
  this.distTable = Zlib$1.RawInflateStream.FixedDistanceTable;

  this.status = Zlib$1.RawInflateStream.Status.BLOCK_BODY_END;

  return 0;
};

/**
* オブジェクトのコンテキストを別のプロパティに退避する.
* @private
*/
Zlib$1.RawInflateStream.prototype.save_ = function () {
  this.ip_ = this.ip;
  this.bitsbuflen_ = this.bitsbuflen;
  this.bitsbuf_ = this.bitsbuf;
};

/**
* 別のプロパティに退避したコンテキストを復元する.
* @private
*/
Zlib$1.RawInflateStream.prototype.restore_ = function () {
  this.ip = this.ip_;
  this.bitsbuflen = this.bitsbuflen_;
  this.bitsbuf = this.bitsbuf_;
};

/**
* parse dynamic huffman block.
*/
Zlib$1.RawInflateStream.prototype.parseDynamicHuffmanBlock = function () {
  /** @type {number} number of literal and length codes. */
  var hlit;
  /** @type {number} number of distance codes. */
  var hdist;
  /** @type {number} number of code lengths. */
  var hclen;
  /** @type {!(Uint8Array|Array)} code lengths. */
  var codeLengths =
    new (Uint8Array)(Zlib$1.RawInflateStream.Order.length);
  /** @type {!Array} code lengths table. */
  var codeLengthsTable;

  this.status = Zlib$1.RawInflateStream.Status.BLOCK_BODY_START;

  this.save_();
  hlit = this.readBits(5) + 257;
  hdist = this.readBits(5) + 1;
  hclen = this.readBits(4) + 4;
  if (hlit < 0 || hdist < 0 || hclen < 0) {
    this.restore_();
    return -1;
  }

  try {
    parseDynamicHuffmanBlockImpl.call(this);
  } catch (e) {
    this.restore_();
    return -1;
  }

  function parseDynamicHuffmanBlockImpl() {
    /** @type {number} */
    var bits;
    var code;
    var prev = 0;
    var repeat;
    /** @type {!(Uint8Array|Array.<number>)} code length table. */
    var lengthTable;
    /** @type {number} loop counter. */
    var i;
    /** @type {number} loop limit. */
    var il;

    // decode code lengths
    for (i = 0; i < hclen; ++i) {
      if ((bits = this.readBits(3)) < 0) {
        throw new Error('not enough input');
      }
      codeLengths[Zlib$1.RawInflateStream.Order[i]] = bits;
    }

    // decode length table
    codeLengthsTable = buildHuffmanTable$1(codeLengths);
    lengthTable = new (Uint8Array)(hlit + hdist);
    for (i = 0, il = hlit + hdist; i < il;) {
      code = this.readCodeByTable(codeLengthsTable);
      if (code < 0) {
        throw new Error('not enough input');
      }
      switch (code) {
        case 16:
          if ((bits = this.readBits(2)) < 0) {
            throw new Error('not enough input');
          }
          repeat = 3 + bits;
          while (repeat--) { lengthTable[i++] = prev; }
          break;
        case 17:
          if ((bits = this.readBits(3)) < 0) {
            throw new Error('not enough input');
          }
          repeat = 3 + bits;
          while (repeat--) { lengthTable[i++] = 0; }
          prev = 0;
          break;
        case 18:
          if ((bits = this.readBits(7)) < 0) {
            throw new Error('not enough input');
          }
          repeat = 11 + bits;
          while (repeat--) { lengthTable[i++] = 0; }
          prev = 0;
          break;
        default:
          lengthTable[i++] = code;
          prev = code;
          break;
      }
    }

    this.litlenTable = buildHuffmanTable$1(lengthTable.subarray(0, hlit))
      ;
    this.distTable = buildHuffmanTable$1(lengthTable.subarray(hlit))
      ;
  }

  this.status = Zlib$1.RawInflateStream.Status.BLOCK_BODY_END;

  return 0;
};

/**
* decode huffman code (dynamic)
* @return {(number|undefined)} -1 is error.
*/
Zlib$1.RawInflateStream.prototype.decodeHuffman = function () {
  var output = this.output;
  var op = this.op;

  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  var litlen = this.litlenTable;
  var dist = this.distTable;

  var olength = output.length;
  var bits;

  this.status = Zlib$1.RawInflateStream.Status.DECODE_BLOCK_START;

  while (true) {
    this.save_();

    code = this.readCodeByTable(litlen);
    if (code < 0) {
      this.op = op;
      this.restore_();
      return -1;
    }

    if (code === 256) {
      break;
    }

    // literal
    if (code < 256) {
      if (op === olength) {
        output = this.expandBuffer();
        olength = output.length;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = Zlib$1.RawInflateStream.LengthCodeTable[ti];
    if (Zlib$1.RawInflateStream.LengthExtraTable[ti] > 0) {
      bits = this.readBits(Zlib$1.RawInflateStream.LengthExtraTable[ti]);
      if (bits < 0) {
        this.op = op;
        this.restore_();
        return -1;
      }
      codeLength += bits;
    }

    // dist code
    code = this.readCodeByTable(dist);
    if (code < 0) {
      this.op = op;
      this.restore_();
      return -1;
    }
    codeDist = Zlib$1.RawInflateStream.DistCodeTable[code];
    if (Zlib$1.RawInflateStream.DistExtraTable[code] > 0) {
      bits = this.readBits(Zlib$1.RawInflateStream.DistExtraTable[code]);
      if (bits < 0) {
        this.op = op;
        this.restore_();
        return -1;
      }
      codeDist += bits;
    }

    // lz77 decode
    if (op + codeLength >= olength) {
      output = this.expandBuffer();
      olength = output.length;
    }

    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }

    // break
    if (this.ip === this.input.length) {
      this.op = op;
      return -1;
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }

  this.op = op;
  this.status = Zlib$1.RawInflateStream.Status.DECODE_BLOCK_END;
};

/**
* expand output buffer. (dynamic)
* @param {Object=} opt_param option parameters.
* @return {!(Array|Uint8Array)} output buffer pointer.
*/
Zlib$1.RawInflateStream.prototype.expandBuffer = function (opt_param) {
  /** @type {!(Array|Uint8Array)} store buffer. */
  var buffer;
  /** @type {number} expantion ratio. */
  var ratio = (this.input.length / this.ip + 1) | 0;
  /** @type {number} maximum number of huffman code. */
  var maxHuffCode;
  /** @type {number} new output buffer size. */
  var newSize;
  /** @type {number} max inflate size. */
  var maxInflateSize;

  var input = this.input;
  var output = this.output;

  if (opt_param) {
    if (typeof opt_param.fixRatio === 'number') {
      ratio = opt_param.fixRatio;
    }
    if (typeof opt_param.addRatio === 'number') {
      ratio += opt_param.addRatio;
    }
  }

  // calculate new buffer size
  if (ratio < 2) {
    maxHuffCode =
      (input.length - this.ip) / this.litlenTable[2];
    maxInflateSize = (maxHuffCode / 2 * 258) | 0;
    newSize = maxInflateSize < output.length ?
      output.length + maxInflateSize :
      output.length << 1;
  } else {
    newSize = output.length * ratio;
  }

  // buffer expantion
  {
    buffer = new Uint8Array(newSize);
    buffer.set(output);
  }

  this.output = buffer;

  return this.output;
};

/**
* concat output buffer. (dynamic)
* @return {!(Array|Uint8Array)} output buffer.
*/
Zlib$1.RawInflateStream.prototype.concatBuffer = function () {
  /** @type {!(Array|Uint8Array)} output buffer. */
  var buffer;
  /** @type {number} */
  var op = this.op;
  /** @type {Uint8Array} */
  var tmp;

  if (this.resize) {
    {
      buffer = new Uint8Array(this.output.subarray(this.sp, op));
    }
  } else {
    buffer =
      this.output.subarray(this.sp, op);
  }

  this.sp = op;

  // compaction
  if (op > Zlib$1.RawInflateStream.MaxBackwardLength + this.bufferSize) {
    this.op = this.sp = Zlib$1.RawInflateStream.MaxBackwardLength;
    {
      tmp = /** @type {Uint8Array} */(this.output);
      this.output = new Uint8Array(this.bufferSize + Zlib$1.RawInflateStream.MaxBackwardLength);
      this.output.set(tmp.subarray(op - Zlib$1.RawInflateStream.MaxBackwardLength, op));
    }
  }

  return buffer;
};


/**
* @constructor
* @param {!(Uint8Array|Array)} input deflated buffer.
* @param {Object=} opt_params option parameters.
*
* opt_params は以下のプロパティを指定する事ができます。
*   - index: input buffer の deflate コンテナの開始位置.
*   - blockSize: バッファのブロックサイズ.
*   - verify: 伸張が終わった後 adler-32 checksum の検証を行うか.
*   - bufferType: Zlib.Inflate.BufferType の値によってバッファの管理方法を指定する.
*       Zlib.Inflate.BufferType は Zlib.RawInflate.BufferType のエイリアス.
*/
Zlib$1.Inflate = function (input, opt_params) {
  /** @type {number} */
  var cmf;
  /** @type {number} */
  var flg;

  /** @type {!(Uint8Array|Array)} */
  this.input = input;
  /** @type {number} */
  this.ip = 0;
  /** @type {Zlib.RawInflate} */
  this.rawinflate;
  /** @type {(boolean|undefined)} verify flag. */
  this.verify;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (opt_params['index']) {
      this.ip = opt_params['index'];
    }
    if (opt_params['verify']) {
      this.verify = opt_params['verify'];
    }
  }

  // Compression Method and Flags
  cmf = input[this.ip++];
  flg = input[this.ip++];

  // compression method
  switch (cmf & 0x0f) {
    case Zlib$1.CompressionMethod.DEFLATE:
      this.method = Zlib$1.CompressionMethod.DEFLATE;
      break;
    default:
      throw new Error('unsupported compression method');
  }

  // fcheck
  if (((cmf << 8) + flg) % 31 !== 0) {
    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
  }

  // fdict (not supported)
  if (flg & 0x20) {
    throw new Error('fdict flag is not supported');
  }

  // RawInflate
  this.rawinflate = new Zlib$1.RawInflate(input, {
    'index': this.ip,
    'bufferSize': opt_params['bufferSize'],
    'bufferType': opt_params['bufferType'],
    'resize': opt_params['resize']
  });
};

/**
* @enum {number}
*/
Zlib$1.Inflate.BufferType = Zlib$1.RawInflate.BufferType;

/**
* decompress.
* @return {!(Uint8Array|Array)} inflated buffer.
*/
Zlib$1.Inflate.prototype.decompress = function () {
  /** @type {!(Array|Uint8Array)} input buffer. */
  var input = this.input;
  /** @type {!(Uint8Array|Array)} inflated buffer. */
  var buffer;
  /** @type {number} adler-32 checksum */
  var adler32;

  buffer = this.rawinflate.decompress();
  this.ip = this.rawinflate.ip;

  // verify adler-32
  if (this.verify) {
    adler32 = (
      input[this.ip++] << 24 | input[this.ip++] << 16 |
      input[this.ip++] << 8 | input[this.ip++]
    ) >>> 0;

    if (adler32 !== Zlib$1.Adler32(buffer)) {
      throw new Error('invalid adler-32 checksum');
    }
  }

  return buffer;
};


/* vim:set expandtab ts=2 sw=2 tw=80: */


/**
* @param {!(Uint8Array|Array)} input deflated buffer.
* @constructor
*/
Zlib$1.InflateStream = function (input) {
  /** @type {!(Uint8Array|Array)} */
  this.input = input === void 0 ? new (Uint8Array)() : input;
  /** @type {number} */
  this.ip = 0;
  /** @type {Zlib.RawInflateStream} */
  this.rawinflate = new Zlib$1.RawInflateStream(this.input, this.ip);
  /** @type {Zlib.CompressionMethod} */
  this.method;
  /** @type {!(Array|Uint8Array)} */
  this.output = this.rawinflate.output;
};

/**
* decompress.
* @return {!(Uint8Array|Array)} inflated buffer.
*/
Zlib$1.InflateStream.prototype.decompress = function (input) {
  /** @type {!(Uint8Array|Array)} inflated buffer. */
  var buffer;

  // 新しい入力を入力バッファに結合する
  // XXX Array, Uint8Array のチェックを行うか確認する
  if (input !== void 0) {
    {
      var tmp = new Uint8Array(this.input.length + input.length);
      tmp.set(this.input, 0);
      tmp.set(input, this.input.length);
      this.input = tmp;
    }
  }

  if (this.method === void 0) {
    if (this.readHeader() < 0) {
      return new (Uint8Array)();
    }
  }

  buffer = this.rawinflate.decompress(this.input, this.ip);
  if (this.rawinflate.ip !== 0) {
    this.input =
      this.input.subarray(this.rawinflate.ip);
    this.ip = 0;
  }

  // verify adler-32
  /*
  if (this.verify) {
    adler32 =
      input[this.ip++] << 24 | input[this.ip++] << 16 |
      input[this.ip++] << 8 | input[this.ip++];
  
    if (adler32 !== Zlib.Adler32(buffer)) {
      throw new Error('invalid adler-32 checksum');
    }
  }
  */

  return buffer;
};

Zlib$1.InflateStream.prototype.readHeader = function () {
  var ip = this.ip;
  var input = this.input;

  // Compression Method and Flags
  var cmf = input[ip++];
  var flg = input[ip++];

  if (cmf === void 0 || flg === void 0) {
    return -1;
  }

  // compression method
  switch (cmf & 0x0f) {
    case Zlib$1.CompressionMethod.DEFLATE:
      this.method = Zlib$1.CompressionMethod.DEFLATE;
      break;
    default:
      throw new Error('unsupported compression method');
  }

  // fcheck
  if (((cmf << 8) + flg) % 31 !== 0) {
    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
  }

  // fdict (not supported)
  if (flg & 0x20) {
    throw new Error('fdict flag is not supported');
  }

  this.ip = ip;
};


/**
* @fileoverview GZIP (RFC1952) 展開コンテナ実装.
*/

/**
* @constructor
* @param {!(Array|Uint8Array)} input input buffer.
* @param {Object=} opt_params option parameters.
*/
Zlib$1.Gunzip = function (input, opt_params) {
  /** @type {!(Array.<number>|Uint8Array)} input buffer. */
  this.input = input;
  /** @type {number} input buffer pointer. */
  this.ip = 0;
  /** @type {Array.<Zlib.GunzipMember>} */
  this.member = [];
  /** @type {boolean} */
  this.decompressed = false;
};

/**
* @return {Array.<Zlib.GunzipMember>}
*/
Zlib$1.Gunzip.prototype.getMembers = function () {
  if (!this.decompressed) {
    this.decompress();
  }

  return this.member.slice();
};

/**
* inflate gzip data.
* @return {!(Array.<number>|Uint8Array)} inflated buffer.
*/
Zlib$1.Gunzip.prototype.decompress = function () {
  /** @type {number} input length. */
  var il = this.input.length;

  while (this.ip < il) {
    this.decodeMember();
  }

  this.decompressed = true;

  return this.concatMember();
};

/**
* decode gzip member.
*/
Zlib$1.Gunzip.prototype.decodeMember = function () {
  /** @type {Zlib.GunzipMember} */
  var member = new Zlib$1.GunzipMember();
  /** @type {number} */
  var isize;
  /** @type {Zlib.RawInflate} RawInflate implementation. */
  var rawinflate;
  /** @type {!(Array.<number>|Uint8Array)} inflated data. */
  var inflated;
  /** @type {number} inflate size */
  var inflen;
  /** @type {number} character code */
  var c;
  /** @type {number} character index in string. */
  var ci;
  /** @type {Array.<string>} character array. */
  var str;
  /** @type {number} modification time. */
  var mtime;
  /** @type {number} */
  var crc32;

  var input = this.input;
  var ip = this.ip;

  member.id1 = input[ip++];
  member.id2 = input[ip++];

  // check signature
  if (member.id1 !== 0x1f || member.id2 !== 0x8b) {
    throw new Error('invalid file signature:' + member.id1 + ',' + member.id2);
  }

  // check compression method
  member.cm = input[ip++];
  switch (member.cm) {
    case 8: /* XXX: use Zlib const */
      break;
    default:
      throw new Error('unknown compression method: ' + member.cm);
  }

  // flags
  member.flg = input[ip++];

  // modification time
  mtime = (input[ip++]) |
    (input[ip++] << 8) |
    (input[ip++] << 16) |
    (input[ip++] << 24);
  member.mtime = new Date(mtime * 1000);

  // extra flags
  member.xfl = input[ip++];

  // operating system
  member.os = input[ip++];

  // extra
  if ((member.flg & Zlib$1.Gzip.FlagsMask.FEXTRA) > 0) {
    member.xlen = input[ip++] | (input[ip++] << 8);
    ip = this.decodeSubField(ip, member.xlen);
  }

  // fname
  if ((member.flg & Zlib$1.Gzip.FlagsMask.FNAME) > 0) {
    for (str = [], ci = 0; (c = input[ip++]) > 0;) {
      str[ci++] = String.fromCharCode(c);
    }
    member.name = str.join('');
  }

  // fcomment
  if ((member.flg & Zlib$1.Gzip.FlagsMask.FCOMMENT) > 0) {
    for (str = [], ci = 0; (c = input[ip++]) > 0;) {
      str[ci++] = String.fromCharCode(c);
    }
    member.comment = str.join('');
  }

  // fhcrc
  if ((member.flg & Zlib$1.Gzip.FlagsMask.FHCRC) > 0) {
    member.crc16 = Zlib$1.CRC32.calc(input, 0, ip) & 0xffff;
    if (member.crc16 !== (input[ip++] | (input[ip++] << 8))) {
      throw new Error('invalid header crc16');
    }
  }

  // isize を事前に取得すると展開後のサイズが分かるため、
  // inflate処理のバッファサイズが事前に分かり、高速になる
  isize = (input[input.length - 4]) | (input[input.length - 3] << 8) |
    (input[input.length - 2] << 16) | (input[input.length - 1] << 24);

  // isize の妥当性チェック
  // ハフマン符号では最小 2-bit のため、最大で 1/4 になる
  // LZ77 符号では 長さと距離 2-Byte で最大 258-Byte を表現できるため、
  // 1/128 になるとする
  // ここから入力バッファの残りが isize の 512 倍以上だったら
  // サイズ指定のバッファ確保は行わない事とする
  if (input.length - ip - /* CRC-32 */4 - /* ISIZE */4 < isize * 512) {
    inflen = isize;
  }

  // compressed block
  rawinflate = new Zlib$1.RawInflate(input, { 'index': ip, 'bufferSize': inflen });
  member.data = inflated = rawinflate.decompress();
  ip = rawinflate.ip;

  // crc32
  member.crc32 = crc32 =
    ((input[ip++]) | (input[ip++] << 8) |
      (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;
  if (Zlib$1.CRC32.calc(inflated) !== crc32) {
    throw new Error('invalid CRC-32 checksum: 0x' +
      Zlib$1.CRC32.calc(inflated).toString(16) + ' / 0x' + crc32.toString(16));
  }

  // input size
  member.isize = isize =
    ((input[ip++]) | (input[ip++] << 8) |
      (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;
  if ((inflated.length & 0xffffffff) !== isize) {
    throw new Error('invalid input size: ' +
      (inflated.length & 0xffffffff) + ' / ' + isize);
  }

  this.member.push(member);
  this.ip = ip;
};

/**
* サブフィールドのデコード
* XXX: 現在は何もせずスキップする
*/
Zlib$1.Gunzip.prototype.decodeSubField = function (ip, length) {
  return ip + length;
};

/**
* @return {!(Array.<number>|Uint8Array)}
*/
Zlib$1.Gunzip.prototype.concatMember = function () {
  /** @type {Array.<Zlib.GunzipMember>} */
  var member = this.member;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;
  /** @type {number} */
  var p = 0;
  /** @type {number} */
  var size = 0;
  /** @type {!(Array.<number>|Uint8Array)} */
  var buffer;

  for (i = 0, il = member.length; i < il; ++i) {
    size += member[i].data.length;
  }

  {
    buffer = new Uint8Array(size);
    for (i = 0; i < il; ++i) {
      buffer.set(member[i].data, p);
      p += member[i].data.length;
    }
  }

  return buffer;
};



/**
* @constructor
*/
Zlib$1.GunzipMember = function () {
  /** @type {number} signature first byte. */
  this.id1;
  /** @type {number} signature second byte. */
  this.id2;
  /** @type {number} compression method. */
  this.cm;
  /** @type {number} flags. */
  this.flg;
  /** @type {Date} modification time. */
  this.mtime;
  /** @type {number} extra flags. */
  this.xfl;
  /** @type {number} operating system number. */
  this.os;
  /** @type {number} CRC-16 value for FHCRC flag. */
  this.crc16;
  /** @type {number} extra length. */
  this.xlen;
  /** @type {number} CRC-32 value for verification. */
  this.crc32;
  /** @type {number} input size modulo 32 value. */
  this.isize;
  /** @type {string} filename. */
  this.name;
  /** @type {string} comment. */
  this.comment;
  /** @type {!(Uint8Array|Array.<number>)} */
  this.data;
};

Zlib$1.GunzipMember.prototype.getName = function () {
  return this.name;
};

Zlib$1.GunzipMember.prototype.getData = function () {
  return this.data;
};

Zlib$1.GunzipMember.prototype.getMtime = function () {
  return this.mtime;
};

/**
* @fileoverview GZIP (RFC1952) 実装.
*/

/**
* @constructor
* @param {!(Array|Uint8Array)} input input buffer.
* @param {Object=} opt_params option parameters.
*/
Zlib$1.Gzip = function (input, opt_params) {
  /** @type {!(Array.<number>|Uint8Array)} input buffer. */
  this.input = input;
  /** @type {number} input buffer pointer. */
  this.ip = 0;
  /** @type {!(Array.<number>|Uint8Array)} output buffer. */
  this.output;
  /** @type {number} output buffer. */
  this.op = 0;
  /** @type {!Object} flags option flags. */
  this.flags = {};
  /** @type {!string} filename. */
  this.filename;
  /** @type {!string} comment. */
  this.comment;
  /** @type {!Object} deflate options. */
  this.deflateOptions;

  // option parameters
  if (opt_params) {
    if (opt_params['flags']) {
      this.flags = opt_params['flags'];
    }
    if (typeof opt_params['filename'] === 'string') {
      this.filename = opt_params['filename'];
    }
    if (typeof opt_params['comment'] === 'string') {
      this.comment = opt_params['comment'];
    }
    if (opt_params['deflateOptions']) {
      this.deflateOptions = opt_params['deflateOptions'];
    }
  }

  if (!this.deflateOptions) {
    this.deflateOptions = {};
  }
};

/**
* @type {number}
* @const
*/
Zlib$1.Gzip.DefaultBufferSize = 0x8000;

/**
* encode gzip members.
* @return {!(Array|Uint8Array)} gzip binary array.
*/
Zlib$1.Gzip.prototype.compress = function () {
  /** @type {number} flags. */
  var flg;
  /** @type {number} modification time. */
  var mtime;
  /** @type {number} CRC-16 value for FHCRC flag. */
  var crc16;
  /** @type {number} CRC-32 value for verification. */
  var crc32;
  /** @type {!Zlib.RawDeflate} raw deflate object. */
  var rawdeflate;
  /** @type {number} character code */
  var c;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limiter. */
  var il;
  /** @type {!(Array|Uint8Array)} output buffer. */
  var output =
    new (Uint8Array)(Zlib$1.Gzip.DefaultBufferSize);
  /** @type {number} output buffer pointer. */
  var op = 0;

  var input = this.input;
  var ip = this.ip;
  var filename = this.filename;
  var comment = this.comment;

  // check signature
  output[op++] = 0x1f;
  output[op++] = 0x8b;

  // check compression method
  output[op++] = 8; /* XXX: use Zlib const */

  // flags
  flg = 0;
  if (this.flags['fname']) flg |= Zlib$1.Gzip.FlagsMask.FNAME;
  if (this.flags['fcomment']) flg |= Zlib$1.Gzip.FlagsMask.FCOMMENT;
  if (this.flags['fhcrc']) flg |= Zlib$1.Gzip.FlagsMask.FHCRC;
  // XXX: FTEXT
  // XXX: FEXTRA
  output[op++] = flg;

  // modification time
  mtime = (Date.now ? Date.now() : +new Date()) / 1000 | 0;
  output[op++] = mtime & 0xff;
  output[op++] = mtime >>> 8 & 0xff;
  output[op++] = mtime >>> 16 & 0xff;
  output[op++] = mtime >>> 24 & 0xff;

  // extra flags
  output[op++] = 0;

  // operating system
  output[op++] = Zlib$1.Gzip.OperatingSystem.UNKNOWN;

  // extra
  /* NOP */

  // fname
  if (this.flags['fname'] !== void 0) {
    for (i = 0, il = filename.length; i < il; ++i) {
      c = filename.charCodeAt(i);
      if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }
      output[op++] = c & 0xff;
    }
    output[op++] = 0; // null termination
  }

  // fcomment
  if (this.flags['comment']) {
    for (i = 0, il = comment.length; i < il; ++i) {
      c = comment.charCodeAt(i);
      if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }
      output[op++] = c & 0xff;
    }
    output[op++] = 0; // null termination
  }

  // fhcrc
  if (this.flags['fhcrc']) {
    crc16 = Zlib$1.CRC32.calc(output, 0, op) & 0xffff;
    output[op++] = (crc16) & 0xff;
    output[op++] = (crc16 >>> 8) & 0xff;
  }

  // add compress option
  this.deflateOptions['outputBuffer'] = output;
  this.deflateOptions['outputIndex'] = op;

  // compress
  rawdeflate = new Zlib$1.RawDeflate(input, this.deflateOptions);
  output = rawdeflate.compress();
  op = rawdeflate.op;

  // expand buffer
  {
    if (op + 8 > output.buffer.byteLength) {
      this.output = new Uint8Array(op + 8);
      this.output.set(new Uint8Array(output.buffer));
      output = this.output;
    } else {
      output = new Uint8Array(output.buffer);
    }
  }

  // crc32
  crc32 = Zlib$1.CRC32.calc(input);
  output[op++] = (crc32) & 0xff;
  output[op++] = (crc32 >>> 8) & 0xff;
  output[op++] = (crc32 >>> 16) & 0xff;
  output[op++] = (crc32 >>> 24) & 0xff;

  // input size
  il = input.length;
  output[op++] = (il) & 0xff;
  output[op++] = (il >>> 8) & 0xff;
  output[op++] = (il >>> 16) & 0xff;
  output[op++] = (il >>> 24) & 0xff;

  this.ip = ip;

  if (op < output.length) {
    this.output = output = output.subarray(0, op);
  }

  return output;
};

/** @enum {number} */
Zlib$1.Gzip.OperatingSystem = {
  FAT: 0,
  AMIGA: 1,
  VMS: 2,
  UNIX: 3,
  VM_CMS: 4,
  ATARI_TOS: 5,
  HPFS: 6,
  MACINTOSH: 7,
  Z_SYSTEM: 8,
  CP_M: 9,
  TOPS_20: 10,
  NTFS: 11,
  QDOS: 12,
  ACORN_RISCOS: 13,
  UNKNOWN: 255
};

/** @enum {number} */
Zlib$1.Gzip.FlagsMask = {
  FTEXT: 0x01,
  FHCRC: 0x02,
  FEXTRA: 0x04,
  FNAME: 0x08,
  FCOMMENT: 0x10
};


/**
* @fileoverview Heap Sort 実装. ハフマン符号化で使用する.
*/

/**
* カスタムハフマン符号で使用するヒープ実装
* @param {number} length ヒープサイズ.
* @constructor
*/
Zlib$1.Heap = function (length) {
  this.buffer = new (Uint16Array)(length * 2);
  this.length = 0;
};

/**
* 親ノードの index 取得
* @param {number} index 子ノードの index.
* @return {number} 親ノードの index.
*
*/
Zlib$1.Heap.prototype.getParent = function (index) {
  return ((index - 2) / 4 | 0) * 2;
};

/**
* 子ノードの index 取得
* @param {number} index 親ノードの index.
* @return {number} 子ノードの index.
*/
Zlib$1.Heap.prototype.getChild = function (index) {
  return 2 * index + 2;
};

/**
* Heap に値を追加する
* @param {number} index キー index.
* @param {number} value 値.
* @return {number} 現在のヒープ長.
*/
Zlib$1.Heap.prototype.push = function (index, value) {
  var current, parent,
    heap = this.buffer,
    swap;

  current = this.length;
  heap[this.length++] = value;
  heap[this.length++] = index;

  // ルートノードにたどり着くまで入れ替えを試みる
  while (current > 0) {
    parent = this.getParent(current);

    // 親ノードと比較して親の方が小さければ入れ替える
    if (heap[current] > heap[parent]) {
      swap = heap[current];
      heap[current] = heap[parent];
      heap[parent] = swap;

      swap = heap[current + 1];
      heap[current + 1] = heap[parent + 1];
      heap[parent + 1] = swap;

      current = parent;
      // 入れ替えが必要なくなったらそこで抜ける
    } else {
      break;
    }
  }

  return this.length;
};

/**
* Heapから一番大きい値を返す
* @return {{index: number, value: number, length: number}} {index: キーindex,
*     value: 値, length: ヒープ長} の Object.
*/
Zlib$1.Heap.prototype.pop = function () {
  var index, value,
    heap = this.buffer, swap,
    current, parent;

  value = heap[0];
  index = heap[1];

  // 後ろから値を取る
  this.length -= 2;
  heap[0] = heap[this.length];
  heap[1] = heap[this.length + 1];

  parent = 0;
  // ルートノードから下がっていく
  while (true) {
    current = this.getChild(parent);

    // 範囲チェック
    if (current >= this.length) {
      break;
    }

    // 隣のノードと比較して、隣の方が値が大きければ隣を現在ノードとして選択
    if (current + 2 < this.length && heap[current + 2] > heap[current]) {
      current += 2;
    }

    // 親ノードと比較して親の方が小さい場合は入れ替える
    if (heap[current] > heap[parent]) {
      swap = heap[parent];
      heap[parent] = heap[current];
      heap[current] = swap;

      swap = heap[parent + 1];
      heap[parent + 1] = heap[current + 1];
      heap[current + 1] = swap;
    } else {
      break;
    }

    parent = current;
  }

  return { index: index, value: value, length: this.length };
};


/* vim:set expandtab ts=2 sw=2 tw=80: */

/**
* @fileoverview Deflate (RFC1951) 符号化アルゴリズム実装.
*/


/**
* Raw Deflate 実装
*
* @constructor
* @param {!(Array.<number>|Uint8Array)} input 符号化する対象のバッファ.
* @param {Object=} opt_params option parameters.
*
* typed array が使用可能なとき、outputBuffer が Array は自動的に Uint8Array に
* 変換されます.
* 別のオブジェクトになるため出力バッファを参照している変数などは
* 更新する必要があります.
*/
Zlib$1.RawDeflate = function (input, opt_params) {
  /** @type {Zlib.RawDeflate.CompressionType} */
  this.compressionType = Zlib$1.RawDeflate.CompressionType.DYNAMIC;
  /** @type {number} */
  this.lazy = 0;
  /** @type {!(Array.<number>|Uint32Array)} */
  this.freqsLitLen;
  /** @type {!(Array.<number>|Uint32Array)} */
  this.freqsDist;
  /** @type {!(Array.<number>|Uint8Array)} */
  this.input =
    (input instanceof Array) ? new Uint8Array(input) : input;
  /** @type {!(Array.<number>|Uint8Array)} output output buffer. */
  this.output;
  /** @type {number} pos output buffer position. */
  this.op = 0;

  // option parameters
  if (opt_params) {
    if (opt_params['lazy']) {
      this.lazy = opt_params['lazy'];
    }
    if (typeof opt_params['compressionType'] === 'number') {
      this.compressionType = opt_params['compressionType'];
    }
    if (opt_params['outputBuffer']) {
      this.output =
        (opt_params['outputBuffer'] instanceof Array) ?
          new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];
    }
    if (typeof opt_params['outputIndex'] === 'number') {
      this.op = opt_params['outputIndex'];
    }
  }

  if (!this.output) {
    this.output = new (Uint8Array)(0x8000);
  }
};

/**
* @enum {number}
*/
Zlib$1.RawDeflate.CompressionType = {
  NONE: 0,
  FIXED: 1,
  DYNAMIC: 2,
  RESERVED: 3
};


/**
* LZ77 の最小マッチ長
* @const
* @type {number}
*/
Zlib$1.RawDeflate.Lz77MinLength = 3;

/**
* LZ77 の最大マッチ長
* @const
* @type {number}
*/
Zlib$1.RawDeflate.Lz77MaxLength = 258;

/**
* LZ77 のウィンドウサイズ
* @const
* @type {number}
*/
Zlib$1.RawDeflate.WindowSize = 0x8000;

/**
* 最長の符号長
* @const
* @type {number}
*/
Zlib$1.RawDeflate.MaxCodeLength = 16;

/**
* ハフマン符号の最大数値
* @const
* @type {number}
*/
Zlib$1.RawDeflate.HUFMAX = 286;

/**
* 固定ハフマン符号の符号化テーブル
* @const
* @type {Array.<Array.<number, number>>}
*/
Zlib$1.RawDeflate.FixedHuffmanTable = (function () {
  var table = [], i;

  for (i = 0; i < 288; i++) {
    switch (true) {
      case (i <= 143): table.push([i + 0x030, 8]); break;
      case (i <= 255): table.push([i - 144 + 0x190, 9]); break;
      case (i <= 279): table.push([i - 256 + 0x000, 7]); break;
      case (i <= 287): table.push([i - 280 + 0x0C0, 8]); break;
      default:
        throw 'invalid literal: ' + i;
    }
  }

  return table;
})();

/**
* DEFLATE ブロックの作成
* @return {!(Array.<number>|Uint8Array)} 圧縮済み byte array.
*/
Zlib$1.RawDeflate.prototype.compress = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var blockArray;
  /** @type {number} */
  var position;
  /** @type {number} */
  var length;

  var input = this.input;

  // compression
  switch (this.compressionType) {
    case Zlib$1.RawDeflate.CompressionType.NONE:
      // each 65535-Byte (length header: 16-bit)
      for (position = 0, length = input.length; position < length;) {
        blockArray =
          input.subarray(position, position + 0xffff);
        position += blockArray.length;
        this.makeNocompressBlock(blockArray, (position === length));
      }
      break;
    case Zlib$1.RawDeflate.CompressionType.FIXED:
      this.output = this.makeFixedHuffmanBlock(input, true);
      this.op = this.output.length;
      break;
    case Zlib$1.RawDeflate.CompressionType.DYNAMIC:
      this.output = this.makeDynamicHuffmanBlock(input, true);
      this.op = this.output.length;
      break;
    default:
      throw 'invalid compression type';
  }

  return this.output;
};

/**
* 非圧縮ブロックの作成
* @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
* @param {!boolean} isFinalBlock 最後のブロックならばtrue.
* @return {!(Array.<number>|Uint8Array)} 非圧縮ブロック byte array.
*/
Zlib$1.RawDeflate.prototype.makeNocompressBlock =
  function (blockArray, isFinalBlock) {
    /** @type {number} */
    var bfinal;
    /** @type {Zlib.RawDeflate.CompressionType} */
    var btype;
    /** @type {number} */
    var len;
    /** @type {number} */
    var nlen;

    var output = this.output;
    var op = this.op;

    // expand buffer
    {
      output = new Uint8Array(this.output.buffer);
      while (output.length <= op + blockArray.length + 5) {
        output = new Uint8Array(output.length << 1);
      }
      output.set(this.output);
    }

    // header
    bfinal = isFinalBlock ? 1 : 0;
    btype = Zlib$1.RawDeflate.CompressionType.NONE;
    output[op++] = (bfinal) | (btype << 1);

    // length
    len = blockArray.length;
    nlen = (~len + 0x10000) & 0xffff;
    output[op++] = len & 0xff;
    output[op++] = (len >>> 8) & 0xff;
    output[op++] = nlen & 0xff;
    output[op++] = (nlen >>> 8) & 0xff;

    // copy buffer
    {
      output.set(blockArray, op);
      op += blockArray.length;
      output = output.subarray(0, op);
    }

    this.op = op;
    this.output = output;

    return output;
  };

/**
* 固定ハフマンブロックの作成
* @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
* @param {!boolean} isFinalBlock 最後のブロックならばtrue.
* @return {!(Array.<number>|Uint8Array)} 固定ハフマン符号化ブロック byte array.
*/
Zlib$1.RawDeflate.prototype.makeFixedHuffmanBlock =
  function (blockArray, isFinalBlock) {
    /** @type {Zlib.BitStream} */
    var stream = new Zlib$1.BitStream(
      new Uint8Array(this.output.buffer), this.op);
    /** @type {number} */
    var bfinal;
    /** @type {Zlib.RawDeflate.CompressionType} */
    var btype;
    /** @type {!(Array.<number>|Uint16Array)} */
    var data;

    // header
    bfinal = isFinalBlock ? 1 : 0;
    btype = Zlib$1.RawDeflate.CompressionType.FIXED;

    stream.writeBits(bfinal, 1, true);
    stream.writeBits(btype, 2, true);

    data = this.lz77(blockArray);
    this.fixedHuffman(data, stream);

    return stream.finish();
  };

/**
* 動的ハフマンブロックの作成
* @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
* @param {!boolean} isFinalBlock 最後のブロックならばtrue.
* @return {!(Array.<number>|Uint8Array)} 動的ハフマン符号ブロック byte array.
*/
Zlib$1.RawDeflate.prototype.makeDynamicHuffmanBlock =
  function (blockArray, isFinalBlock) {
    /** @type {Zlib.BitStream} */
    var stream = new Zlib$1.BitStream(
      new Uint8Array(this.output.buffer), this.op);
    /** @type {number} */
    var bfinal;
    /** @type {Zlib.RawDeflate.CompressionType} */
    var btype;
    /** @type {!(Array.<number>|Uint16Array)} */
    var data;
    /** @type {number} */
    var hlit;
    /** @type {number} */
    var hdist;
    /** @type {number} */
    var hclen;
    /** @const @type {Array.<number>} */
    var hclenOrder =
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    /** @type {!(Array.<number>|Uint8Array)} */
    var litLenLengths;
    /** @type {!(Array.<number>|Uint16Array)} */
    var litLenCodes;
    /** @type {!(Array.<number>|Uint8Array)} */
    var distLengths;
    /** @type {!(Array.<number>|Uint16Array)} */
    var distCodes;
    /** @type {{
     *   codes: !(Array.<number>|Uint32Array),
     *   freqs: !(Array.<number>|Uint8Array)
     * }} */
    var treeSymbols;
    /** @type {!(Array.<number>|Uint8Array)} */
    var treeLengths;
    /** @type {Array} */
    var transLengths = new Array(19);
    /** @type {!(Array.<number>|Uint16Array)} */
    var treeCodes;
    /** @type {number} */
    var code;
    /** @type {number} */
    var bitlen;
    /** @type {number} */
    var i;
    /** @type {number} */
    var il;

    // header
    bfinal = isFinalBlock ? 1 : 0;
    btype = Zlib$1.RawDeflate.CompressionType.DYNAMIC;

    stream.writeBits(bfinal, 1, true);
    stream.writeBits(btype, 2, true);

    data = this.lz77(blockArray);

    // リテラル・長さ, 距離のハフマン符号と符号長の算出
    litLenLengths = this.getLengths_(this.freqsLitLen, 15);
    litLenCodes = this.getCodesFromLengths_(litLenLengths);
    distLengths = this.getLengths_(this.freqsDist, 7);
    distCodes = this.getCodesFromLengths_(distLengths);

    // HLIT, HDIST の決定
    for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) { }
    for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) { }

    // HCLEN
    treeSymbols =
      this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);
    treeLengths = this.getLengths_(treeSymbols.freqs, 7);
    for (i = 0; i < 19; i++) {
      transLengths[i] = treeLengths[hclenOrder[i]];
    }
    for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) { }

    treeCodes = this.getCodesFromLengths_(treeLengths);

    // 出力
    stream.writeBits(hlit - 257, 5, true);
    stream.writeBits(hdist - 1, 5, true);
    stream.writeBits(hclen - 4, 4, true);
    for (i = 0; i < hclen; i++) {
      stream.writeBits(transLengths[i], 3, true);
    }

    // ツリーの出力
    for (i = 0, il = treeSymbols.codes.length; i < il; i++) {
      code = treeSymbols.codes[i];

      stream.writeBits(treeCodes[code], treeLengths[code], true);

      // extra bits
      if (code >= 16) {
        i++;
        switch (code) {
          case 16: bitlen = 2; break;
          case 17: bitlen = 3; break;
          case 18: bitlen = 7; break;
          default:
            throw 'invalid code: ' + code;
        }

        stream.writeBits(treeSymbols.codes[i], bitlen, true);
      }
    }

    this.dynamicHuffman(
      data,
      [litLenCodes, litLenLengths],
      [distCodes, distLengths],
      stream
    );

    return stream.finish();
  };


/**
* 動的ハフマン符号化(カスタムハフマンテーブル)
* @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
* @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
* @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
*/
Zlib$1.RawDeflate.prototype.dynamicHuffman =
  function (dataArray, litLen, dist, stream) {
    /** @type {number} */
    var index;
    /** @type {number} */
    var length;
    /** @type {number} */
    var literal;
    /** @type {number} */
    var code;
    /** @type {number} */
    var litLenCodes;
    /** @type {number} */
    var litLenLengths;
    /** @type {number} */
    var distCodes;
    /** @type {number} */
    var distLengths;

    litLenCodes = litLen[0];
    litLenLengths = litLen[1];
    distCodes = dist[0];
    distLengths = dist[1];

    // 符号を BitStream に書き込んでいく
    for (index = 0, length = dataArray.length; index < length; ++index) {
      literal = dataArray[index];

      // literal or length
      stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);

      // 長さ・距離符号
      if (literal > 256) {
        // length extra
        stream.writeBits(dataArray[++index], dataArray[++index], true);
        // distance
        code = dataArray[++index];
        stream.writeBits(distCodes[code], distLengths[code], true);
        // distance extra
        stream.writeBits(dataArray[++index], dataArray[++index], true);
        // 終端
      } else if (literal === 256) {
        break;
      }
    }

    return stream;
  };

/**
* 固定ハフマン符号化
* @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
* @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
* @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
*/
Zlib$1.RawDeflate.prototype.fixedHuffman = function (dataArray, stream) {
  /** @type {number} */
  var index;
  /** @type {number} */
  var length;
  /** @type {number} */
  var literal;

  // 符号を BitStream に書き込んでいく
  for (index = 0, length = dataArray.length; index < length; index++) {
    literal = dataArray[index];

    // 符号の書き込み
    Zlib$1.BitStream.prototype.writeBits.apply(
      stream,
      Zlib$1.RawDeflate.FixedHuffmanTable[literal]
    );

    // 長さ・距離符号
    if (literal > 0x100) {
      // length extra
      stream.writeBits(dataArray[++index], dataArray[++index], true);
      // distance
      stream.writeBits(dataArray[++index], 5);
      // distance extra
      stream.writeBits(dataArray[++index], dataArray[++index], true);
      // 終端
    } else if (literal === 0x100) {
      break;
    }
  }

  return stream;
};

/**
* マッチ情報
* @param {!number} length マッチした長さ.
* @param {!number} backwardDistance マッチ位置との距離.
* @constructor
*/
Zlib$1.RawDeflate.Lz77Match = function (length, backwardDistance) {
  /** @type {number} match length. */
  this.length = length;
  /** @type {number} backward distance. */
  this.backwardDistance = backwardDistance;
};

/**
* 長さ符号テーブル.
* [コード, 拡張ビット, 拡張ビット長] の配列となっている.
* @const
* @type {!(Array.<number>|Uint32Array)}
*/
Zlib$1.RawDeflate.Lz77Match.LengthCodeTable = (function (table) {
  return new Uint32Array(table);
})((function () {
  /** @type {!Array} */
  var table = [];
  /** @type {number} */
  var i;
  /** @type {!Array.<number>} */
  var c;

  for (i = 3; i <= 258; i++) {
    c = code(i);
    table[i] = (c[2] << 24) | (c[1] << 16) | c[0];
  }

  /**
   * @param {number} length lz77 length.
   * @return {!Array.<number>} lz77 codes.
   */
  function code(length) {
    switch (true) {
      case (length === 3): return [257, length - 3, 0]; case (length === 4): return [258, length - 4, 0]; case (length === 5): return [259, length - 5, 0]; case (length === 6): return [260, length - 6, 0]; case (length === 7): return [261, length - 7, 0]; case (length === 8): return [262, length - 8, 0]; case (length === 9): return [263, length - 9, 0]; case (length === 10): return [264, length - 10, 0]; case (length <= 12): return [265, length - 11, 1]; case (length <= 14): return [266, length - 13, 1]; case (length <= 16): return [267, length - 15, 1]; case (length <= 18): return [268, length - 17, 1]; case (length <= 22): return [269, length - 19, 2]; case (length <= 26): return [270, length - 23, 2]; case (length <= 30): return [271, length - 27, 2]; case (length <= 34): return [272, length - 31, 2]; case (length <= 42): return [273, length - 35, 3]; case (length <= 50): return [274, length - 43, 3]; case (length <= 58): return [275, length - 51, 3]; case (length <= 66): return [276, length - 59, 3]; case (length <= 82): return [277, length - 67, 4]; case (length <= 98): return [278, length - 83, 4]; case (length <= 114): return [279, length - 99, 4]; case (length <= 130): return [280, length - 115, 4]; case (length <= 162): return [281, length - 131, 5]; case (length <= 194): return [282, length - 163, 5]; case (length <= 226): return [283, length - 195, 5]; case (length <= 257): return [284, length - 227, 5]; case (length === 258): return [285, length - 258, 0]; default: throw 'invalid length: ' + length;
    }
  }

  return table;
})());

/**
* 距離符号テーブル
* @param {!number} dist 距離.
* @return {!Array.<number>} コード、拡張ビット、拡張ビット長の配列.
* @private
*/
Zlib$1.RawDeflate.Lz77Match.prototype.getDistanceCode_ = function (dist) {
  /** @type {!Array.<number>} distance code table. */
  var r;

  switch (true) {
    case (dist === 1): r = [0, dist - 1, 0]; break;
    case (dist === 2): r = [1, dist - 2, 0]; break;
    case (dist === 3): r = [2, dist - 3, 0]; break;
    case (dist === 4): r = [3, dist - 4, 0]; break;
    case (dist <= 6): r = [4, dist - 5, 1]; break;
    case (dist <= 8): r = [5, dist - 7, 1]; break;
    case (dist <= 12): r = [6, dist - 9, 2]; break;
    case (dist <= 16): r = [7, dist - 13, 2]; break;
    case (dist <= 24): r = [8, dist - 17, 3]; break;
    case (dist <= 32): r = [9, dist - 25, 3]; break;
    case (dist <= 48): r = [10, dist - 33, 4]; break;
    case (dist <= 64): r = [11, dist - 49, 4]; break;
    case (dist <= 96): r = [12, dist - 65, 5]; break;
    case (dist <= 128): r = [13, dist - 97, 5]; break;
    case (dist <= 192): r = [14, dist - 129, 6]; break;
    case (dist <= 256): r = [15, dist - 193, 6]; break;
    case (dist <= 384): r = [16, dist - 257, 7]; break;
    case (dist <= 512): r = [17, dist - 385, 7]; break;
    case (dist <= 768): r = [18, dist - 513, 8]; break;
    case (dist <= 1024): r = [19, dist - 769, 8]; break;
    case (dist <= 1536): r = [20, dist - 1025, 9]; break;
    case (dist <= 2048): r = [21, dist - 1537, 9]; break;
    case (dist <= 3072): r = [22, dist - 2049, 10]; break;
    case (dist <= 4096): r = [23, dist - 3073, 10]; break;
    case (dist <= 6144): r = [24, dist - 4097, 11]; break;
    case (dist <= 8192): r = [25, dist - 6145, 11]; break;
    case (dist <= 12288): r = [26, dist - 8193, 12]; break;
    case (dist <= 16384): r = [27, dist - 12289, 12]; break;
    case (dist <= 24576): r = [28, dist - 16385, 13]; break;
    case (dist <= 32768): r = [29, dist - 24577, 13]; break;
    default: throw 'invalid distance';
  }

  return r;
};

/**
* マッチ情報を LZ77 符号化配列で返す.
* なお、ここでは以下の内部仕様で符号化している
* [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]
* @return {!Array.<number>} LZ77 符号化 byte array.
*/
Zlib$1.RawDeflate.Lz77Match.prototype.toLz77Array = function () {
  /** @type {number} */
  var length = this.length;
  /** @type {number} */
  var dist = this.backwardDistance;
  /** @type {Array} */
  var codeArray = [];
  /** @type {number} */
  var pos = 0;
  /** @type {!Array.<number>} */
  var code;

  // length
  code = Zlib$1.RawDeflate.Lz77Match.LengthCodeTable[length];
  codeArray[pos++] = code & 0xffff;
  codeArray[pos++] = (code >> 16) & 0xff;
  codeArray[pos++] = code >> 24;

  // distance
  code = this.getDistanceCode_(dist);
  codeArray[pos++] = code[0];
  codeArray[pos++] = code[1];
  codeArray[pos++] = code[2];

  return codeArray;
};

/**
* LZ77 実装
* @param {!(Array.<number>|Uint8Array)} dataArray LZ77 符号化するバイト配列.
* @return {!(Array.<number>|Uint16Array)} LZ77 符号化した配列.
*/
Zlib$1.RawDeflate.prototype.lz77 = function (dataArray) {
  /** @type {number} input position */
  var position;
  /** @type {number} input length */
  var length;
  /** @type {number} loop counter */
  var i;
  /** @type {number} loop limiter */
  var il;
  /** @type {number} chained-hash-table key */
  var matchKey;
  /** @type {Object.<number, Array.<number>>} chained-hash-table */
  var table = {};
  /** @const @type {number} */
  var windowSize = Zlib$1.RawDeflate.WindowSize;
  /** @type {Array.<number>} match list */
  var matchList;
  /** @type {Zlib.RawDeflate.Lz77Match} longest match */
  var longestMatch;
  /** @type {Zlib.RawDeflate.Lz77Match} previous longest match */
  var prevMatch;
  /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */
  var lz77buf =
    new Uint16Array(dataArray.length * 2);
  /** @type {number} lz77 output buffer pointer */
  var pos = 0;
  /** @type {number} lz77 skip length */
  var skipLength = 0;
  /** @type {!(Array.<number>|Uint32Array)} */
  var freqsLitLen = new (Uint32Array)(286);
  /** @type {!(Array.<number>|Uint32Array)} */
  var freqsDist = new (Uint32Array)(30);
  /** @type {number} */
  var lazy = this.lazy;
  /** @type {*} temporary variable */
  var tmp;
  freqsLitLen[256] = 1; // EOB の最低出現回数は 1

  /**
   * マッチデータの書き込み
   * @param {Zlib.RawDeflate.Lz77Match} match LZ77 Match data.
   * @param {!number} offset スキップ開始位置(相対指定).
   * @private
   */
  function writeMatch(match, offset) {
    /** @type {Array.<number>} */
    var lz77Array = match.toLz77Array();
    /** @type {number} */
    var i;
    /** @type {number} */
    var il;

    for (i = 0, il = lz77Array.length; i < il; ++i) {
      lz77buf[pos++] = lz77Array[i];
    }
    freqsLitLen[lz77Array[0]]++;
    freqsDist[lz77Array[3]]++;
    skipLength = match.length + offset - 1;
    prevMatch = null;
  }

  // LZ77 符号化
  for (position = 0, length = dataArray.length; position < length; ++position) {
    // ハッシュキーの作成
    for (matchKey = 0, i = 0, il = Zlib$1.RawDeflate.Lz77MinLength; i < il; ++i) {
      if (position + i === length) {
        break;
      }
      matchKey = (matchKey << 8) | dataArray[position + i];
    }

    // テーブルが未定義だったら作成する
    if (table[matchKey] === void 0) { table[matchKey] = []; }
    matchList = table[matchKey];

    // skip
    if (skipLength-- > 0) {
      matchList.push(position);
      continue;
    }

    // マッチテーブルの更新 (最大戻り距離を超えているものを削除する)
    while (matchList.length > 0 && position - matchList[0] > windowSize) {
      matchList.shift();
    }

    // データ末尾でマッチしようがない場合はそのまま流しこむ
    if (position + Zlib$1.RawDeflate.Lz77MinLength >= length) {
      if (prevMatch) {
        writeMatch(prevMatch, -1);
      }

      for (i = 0, il = length - position; i < il; ++i) {
        tmp = dataArray[position + i];
        lz77buf[pos++] = tmp;
        ++freqsLitLen[tmp];
      }
      break;
    }

    // マッチ候補から最長のものを探す
    if (matchList.length > 0) {
      longestMatch = this.searchLongestMatch_(dataArray, position, matchList);

      if (prevMatch) {
        // 現在のマッチの方が前回のマッチよりも長い
        if (prevMatch.length < longestMatch.length) {
          // write previous literal
          tmp = dataArray[position - 1];
          lz77buf[pos++] = tmp;
          ++freqsLitLen[tmp];

          // write current match
          writeMatch(longestMatch, 0);
        } else {
          // write previous match
          writeMatch(prevMatch, -1);
        }
      } else if (longestMatch.length < lazy) {
        prevMatch = longestMatch;
      } else {
        writeMatch(longestMatch, 0);
      }
      // 前回マッチしていて今回マッチがなかったら前回のを採用
    } else if (prevMatch) {
      writeMatch(prevMatch, -1);
    } else {
      tmp = dataArray[position];
      lz77buf[pos++] = tmp;
      ++freqsLitLen[tmp];
    }

    matchList.push(position); // マッチテーブルに現在の位置を保存
  }

  // 終端処理
  lz77buf[pos++] = 256;
  freqsLitLen[256]++;
  this.freqsLitLen = freqsLitLen;
  this.freqsDist = freqsDist;

  return /** @type {!(Uint16Array|Array.<number>)} */ (
    lz77buf.subarray(0, pos)
  );
};

/**
* マッチした候補の中から最長一致を探す
* @param {!Object} data plain data byte array.
* @param {!number} position plain data byte array position.
* @param {!Array.<number>} matchList 候補となる位置の配列.
* @return {!Zlib.RawDeflate.Lz77Match} 最長かつ最短距離のマッチオブジェクト.
* @private
*/
Zlib$1.RawDeflate.prototype.searchLongestMatch_ =
  function (data, position, matchList) {
    var match,
      currentMatch,
      matchMax = 0, matchLength,
      i, j, l, dl = data.length;

    // 候補を後ろから 1 つずつ絞り込んでゆく
    permatch:
    for (i = 0, l = matchList.length; i < l; i++) {
      match = matchList[l - i - 1];
      matchLength = Zlib$1.RawDeflate.Lz77MinLength;

      // 前回までの最長一致を末尾から一致検索する
      if (matchMax > Zlib$1.RawDeflate.Lz77MinLength) {
        for (j = matchMax; j > Zlib$1.RawDeflate.Lz77MinLength; j--) {
          if (data[match + j - 1] !== data[position + j - 1]) {
            continue permatch;
          }
        }
        matchLength = matchMax;
      }

      // 最長一致探索
      while (matchLength < Zlib$1.RawDeflate.Lz77MaxLength &&
        position + matchLength < dl &&
        data[match + matchLength] === data[position + matchLength]) {
        ++matchLength;
      }

      // マッチ長が同じ場合は後方を優先
      if (matchLength > matchMax) {
        currentMatch = match;
        matchMax = matchLength;
      }

      // 最長が確定したら後の処理は省略
      if (matchLength === Zlib$1.RawDeflate.Lz77MaxLength) {
        break;
      }
    }

    return new Zlib$1.RawDeflate.Lz77Match(matchMax, position - currentMatch);
  };

/**
* Tree-Transmit Symbols の算出
* reference: PuTTY Deflate implementation
* @param {number} hlit HLIT.
* @param {!(Array.<number>|Uint8Array)} litlenLengths リテラルと長さ符号の符号長配列.
* @param {number} hdist HDIST.
* @param {!(Array.<number>|Uint8Array)} distLengths 距離符号の符号長配列.
* @return {{
*   codes: !(Array.<number>|Uint32Array),
*   freqs: !(Array.<number>|Uint8Array)
* }} Tree-Transmit Symbols.
*/
Zlib$1.RawDeflate.prototype.getTreeSymbols_ =
  function (hlit, litlenLengths, hdist, distLengths) {
    var src = new (Uint32Array)(hlit + hdist),
      i, j, runLength, l,
      result = new (Uint32Array)(286 + 30),
      nResult,
      rpt,
      freqs = new (Uint8Array)(19);

    j = 0;
    for (i = 0; i < hlit; i++) {
      src[j++] = litlenLengths[i];
    }
    for (i = 0; i < hdist; i++) {
      src[j++] = distLengths[i];
    }

    // 符号化
    nResult = 0;
    for (i = 0, l = src.length; i < l; i += j) {
      // Run Length Encoding
      for (j = 1; i + j < l && src[i + j] === src[i]; ++j) { }

      runLength = j;

      if (src[i] === 0) {
        // 0 の繰り返しが 3 回未満ならばそのまま
        if (runLength < 3) {
          while (runLength-- > 0) {
            result[nResult++] = 0;
            freqs[0]++;
          }
        } else {
          while (runLength > 0) {
            // 繰り返しは最大 138 までなので切り詰める
            rpt = (runLength < 138 ? runLength : 138);

            if (rpt > runLength - 3 && rpt < runLength) {
              rpt = runLength - 3;
            }

            // 3-10 回 -> 17
            if (rpt <= 10) {
              result[nResult++] = 17;
              result[nResult++] = rpt - 3;
              freqs[17]++;
              // 11-138 回 -> 18
            } else {
              result[nResult++] = 18;
              result[nResult++] = rpt - 11;
              freqs[18]++;
            }

            runLength -= rpt;
          }
        }
      } else {
        result[nResult++] = src[i];
        freqs[src[i]]++;
        runLength--;

        // 繰り返し回数が3回未満ならばランレングス符号は要らない
        if (runLength < 3) {
          while (runLength-- > 0) {
            result[nResult++] = src[i];
            freqs[src[i]]++;
          }
          // 3 回以上ならばランレングス符号化
        } else {
          while (runLength > 0) {
            // runLengthを 3-6 で分割
            rpt = (runLength < 6 ? runLength : 6);

            if (rpt > runLength - 3 && rpt < runLength) {
              rpt = runLength - 3;
            }

            result[nResult++] = 16;
            result[nResult++] = rpt - 3;
            freqs[16]++;

            runLength -= rpt;
          }
        }
      }
    }

    return {
      codes:
        result.subarray(0, nResult),
      freqs: freqs
    };
  };

/**
* ハフマン符号の長さを取得する
* @param {!(Array.<number>|Uint8Array|Uint32Array)} freqs 出現カウント.
* @param {number} limit 符号長の制限.
* @return {!(Array.<number>|Uint8Array)} 符号長配列.
* @private
*/
Zlib$1.RawDeflate.prototype.getLengths_ = function (freqs, limit) {
  /** @type {number} */
  var nSymbols = freqs.length;
  /** @type {Zlib.Heap} */
  var heap = new Zlib$1.Heap(2 * Zlib$1.RawDeflate.HUFMAX);
  /** @type {!(Array.<number>|Uint8Array)} */
  var length = new (Uint8Array)(nSymbols);
  /** @type {Array} */
  var nodes;
  /** @type {!(Array.<number>|Uint32Array)} */
  var values;
  /** @type {!(Array.<number>|Uint8Array)} */
  var codeLength;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  // ヒープの構築
  for (i = 0; i < nSymbols; ++i) {
    if (freqs[i] > 0) {
      heap.push(i, freqs[i]);
    }
  }
  nodes = new Array(heap.length / 2);
  values = new (Uint32Array)(heap.length / 2);

  // 非 0 の要素が一つだけだった場合は、そのシンボルに符号長 1 を割り当てて終了
  if (nodes.length === 1) {
    length[heap.pop().index] = 1;
    return length;
  }

  // Reverse Package Merge Algorithm による Canonical Huffman Code の符号長決定
  for (i = 0, il = heap.length / 2; i < il; ++i) {
    nodes[i] = heap.pop();
    values[i] = nodes[i].value;
  }
  codeLength = this.reversePackageMerge_(values, values.length, limit);

  for (i = 0, il = nodes.length; i < il; ++i) {
    length[nodes[i].index] = codeLength[i];
  }

  return length;
};

/**
* Reverse Package Merge Algorithm.
* @param {!(Array.<number>|Uint32Array)} freqs sorted probability.
* @param {number} symbols number of symbols.
* @param {number} limit code length limit.
* @return {!(Array.<number>|Uint8Array)} code lengths.
*/
Zlib$1.RawDeflate.prototype.reversePackageMerge_ = function (freqs, symbols, limit) {
  /** @type {!(Array.<number>|Uint16Array)} */
  var minimumCost = new (Uint16Array)(limit);
  /** @type {!(Array.<number>|Uint8Array)} */
  var flag = new (Uint8Array)(limit);
  /** @type {!(Array.<number>|Uint8Array)} */
  var codeLength = new (Uint8Array)(symbols);
  /** @type {Array} */
  var value = new Array(limit);
  /** @type {Array} */
  var type = new Array(limit);
  /** @type {Array.<number>} */
  var currentPosition = new Array(limit);
  /** @type {number} */
  var excess = (1 << limit) - symbols;
  /** @type {number} */
  var half = (1 << (limit - 1));
  /** @type {number} */
  var i;
  /** @type {number} */
  var j;
  /** @type {number} */
  var t;
  /** @type {number} */
  var weight;
  /** @type {number} */
  var next;

  /**
   * @param {number} j
   */
  function takePackage(j) {
    /** @type {number} */
    var x = type[j][currentPosition[j]];

    if (x === symbols) {
      takePackage(j + 1);
      takePackage(j + 1);
    } else {
      --codeLength[x];
    }

    ++currentPosition[j];
  }

  minimumCost[limit - 1] = symbols;

  for (j = 0; j < limit; ++j) {
    if (excess < half) {
      flag[j] = 0;
    } else {
      flag[j] = 1;
      excess -= half;
    }
    excess <<= 1;
    minimumCost[limit - 2 - j] = (minimumCost[limit - 1 - j] / 2 | 0) + symbols;
  }
  minimumCost[0] = flag[0];

  value[0] = new Array(minimumCost[0]);
  type[0] = new Array(minimumCost[0]);
  for (j = 1; j < limit; ++j) {
    if (minimumCost[j] > 2 * minimumCost[j - 1] + flag[j]) {
      minimumCost[j] = 2 * minimumCost[j - 1] + flag[j];
    }
    value[j] = new Array(minimumCost[j]);
    type[j] = new Array(minimumCost[j]);
  }

  for (i = 0; i < symbols; ++i) {
    codeLength[i] = limit;
  }

  for (t = 0; t < minimumCost[limit - 1]; ++t) {
    value[limit - 1][t] = freqs[t];
    type[limit - 1][t] = t;
  }

  for (i = 0; i < limit; ++i) {
    currentPosition[i] = 0;
  }
  if (flag[limit - 1] === 1) {
    --codeLength[0];
    ++currentPosition[limit - 1];
  }

  for (j = limit - 2; j >= 0; --j) {
    i = 0;
    weight = 0;
    next = currentPosition[j + 1];

    for (t = 0; t < minimumCost[j]; t++) {
      weight = value[j + 1][next] + value[j + 1][next + 1];

      if (weight > freqs[i]) {
        value[j][t] = weight;
        type[j][t] = symbols;
        next += 2;
      } else {
        value[j][t] = freqs[i];
        type[j][t] = i;
        ++i;
      }
    }

    currentPosition[j] = 0;
    if (flag[j] === 1) {
      takePackage(j);
    }
  }

  return codeLength;
};

/**
* 符号長配列からハフマン符号を取得する
* reference: PuTTY Deflate implementation
* @param {!(Array.<number>|Uint8Array)} lengths 符号長配列.
* @return {!(Array.<number>|Uint16Array)} ハフマン符号配列.
* @private
*/
Zlib$1.RawDeflate.prototype.getCodesFromLengths_ = function (lengths) {
  var codes = new (Uint16Array)(lengths.length),
    count = [],
    startCode = [],
    code = 0, i, il, j, m;

  // Count the codes of each length.
  for (i = 0, il = lengths.length; i < il; i++) {
    count[lengths[i]] = (count[lengths[i]] | 0) + 1;
  }

  // Determine the starting code for each length block.
  for (i = 1, il = Zlib$1.RawDeflate.MaxCodeLength; i <= il; i++) {
    startCode[i] = code;
    code += count[i] | 0;
    code <<= 1;
  }

  // Determine the code for each symbol. Mirrored, of course.
  for (i = 0, il = lengths.length; i < il; i++) {
    code = startCode[lengths[i]];
    startCode[lengths[i]] += 1;
    codes[i] = 0;

    for (j = 0, m = lengths[i]; j < m; j++) {
      codes[i] = (codes[i] << 1) | (code & 1);
      code >>>= 1;
    }
  }

  return codes;
};


/**
* @param {!(Array.<number>|Uint8Array)} input input buffer.
* @param {Object=} opt_params options.
* @constructor
*/
Zlib$1.Unzip = function (input, opt_params) {
  opt_params = opt_params || {};
  /** @type {!(Array.<number>|Uint8Array)} */
  this.input =
    ((input instanceof Array)) ?
      new Uint8Array(input) : input;
  /** @type {number} */
  this.ip = 0;
  /** @type {number} */
  this.eocdrOffset;
  /** @type {number} */
  this.numberOfThisDisk;
  /** @type {number} */
  this.startDisk;
  /** @type {number} */
  this.totalEntriesThisDisk;
  /** @type {number} */
  this.totalEntries;
  /** @type {number} */
  this.centralDirectorySize;
  /** @type {number} */
  this.centralDirectoryOffset;
  /** @type {number} */
  this.commentLength;
  /** @type {(Array.<number>|Uint8Array)} */
  this.comment;
  /** @type {Array.<Zlib.Unzip.FileHeader>} */
  this.fileHeaderList;
  /** @type {Object.<string, number>} */
  this.filenameToIndex;
  /** @type {boolean} */
  this.verify = opt_params['verify'] || false;
  /** @type {(Array.<number>|Uint8Array)} */
  this.password = opt_params['password'];
};

Zlib$1.Unzip.CompressionMethod = Zlib$1.Zip.CompressionMethod;

/**
* @type {Array.<number>}
* @const
*/
Zlib$1.Unzip.FileHeaderSignature = Zlib$1.Zip.FileHeaderSignature;

/**
* @type {Array.<number>}
* @const
*/
Zlib$1.Unzip.LocalFileHeaderSignature = Zlib$1.Zip.LocalFileHeaderSignature;

/**
* @type {Array.<number>}
* @const
*/
Zlib$1.Unzip.CentralDirectorySignature = Zlib$1.Zip.CentralDirectorySignature;

/**
* @param {!(Array.<number>|Uint8Array)} input input buffer.
* @param {number} ip input position.
* @constructor
*/
Zlib$1.Unzip.FileHeader = function (input, ip) {
  /** @type {!(Array.<number>|Uint8Array)} */
  this.input = input;
  /** @type {number} */
  this.offset = ip;
  /** @type {number} */
  this.length;
  /** @type {number} */
  this.version;
  /** @type {number} */
  this.os;
  /** @type {number} */
  this.needVersion;
  /** @type {number} */
  this.flags;
  /** @type {number} */
  this.compression;
  /** @type {number} */
  this.time;
  /** @type {number} */
  this.date;
  /** @type {number} */
  this.crc32;
  /** @type {number} */
  this.compressedSize;
  /** @type {number} */
  this.plainSize;
  /** @type {number} */
  this.fileNameLength;
  /** @type {number} */
  this.extraFieldLength;
  /** @type {number} */
  this.fileCommentLength;
  /** @type {number} */
  this.diskNumberStart;
  /** @type {number} */
  this.internalFileAttributes;
  /** @type {number} */
  this.externalFileAttributes;
  /** @type {number} */
  this.relativeOffset;
  /** @type {string} */
  this.filename;
  /** @type {!(Array.<number>|Uint8Array)} */
  this.extraField;
  /** @type {!(Array.<number>|Uint8Array)} */
  this.comment;
};

Zlib$1.Unzip.FileHeader.prototype.parse = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip = this.offset;

  // central file header signature
  if (input[ip++] !== Zlib$1.Unzip.FileHeaderSignature[0] ||
    input[ip++] !== Zlib$1.Unzip.FileHeaderSignature[1] ||
    input[ip++] !== Zlib$1.Unzip.FileHeaderSignature[2] ||
    input[ip++] !== Zlib$1.Unzip.FileHeaderSignature[3]) {
    throw new Error('invalid file header signature');
  }

  // version made by
  this.version = input[ip++];
  this.os = input[ip++];

  // version needed to extract
  this.needVersion = input[ip++] | (input[ip++] << 8);

  // general purpose bit flag
  this.flags = input[ip++] | (input[ip++] << 8);

  // compression method
  this.compression = input[ip++] | (input[ip++] << 8);

  // last mod file time
  this.time = input[ip++] | (input[ip++] << 8);

  //last mod file date
  this.date = input[ip++] | (input[ip++] << 8);

  // crc-32
  this.crc32 = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // compressed size
  this.compressedSize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // uncompressed size
  this.plainSize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // file name length
  this.fileNameLength = input[ip++] | (input[ip++] << 8);

  // extra field length
  this.extraFieldLength = input[ip++] | (input[ip++] << 8);

  // file comment length
  this.fileCommentLength = input[ip++] | (input[ip++] << 8);

  // disk number start
  this.diskNumberStart = input[ip++] | (input[ip++] << 8);

  // internal file attributes
  this.internalFileAttributes = input[ip++] | (input[ip++] << 8);

  // external file attributes
  this.externalFileAttributes =
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24);

  // relative offset of local header
  this.relativeOffset = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // file name
  this.filename = String.fromCharCode.apply(null,
    input.subarray(ip, ip += this.fileNameLength)
  );

  // extra field
  this.extraField =
    input.subarray(ip, ip += this.extraFieldLength);

  // file comment
  this.comment =
    input.subarray(ip, ip + this.fileCommentLength);

  this.length = ip - this.offset;
};

/**
* @param {!(Array.<number>|Uint8Array)} input input buffer.
* @param {number} ip input position.
* @constructor
*/
Zlib$1.Unzip.LocalFileHeader = function (input, ip) {
  /** @type {!(Array.<number>|Uint8Array)} */
  this.input = input;
  /** @type {number} */
  this.offset = ip;
  /** @type {number} */
  this.length;
  /** @type {number} */
  this.needVersion;
  /** @type {number} */
  this.flags;
  /** @type {number} */
  this.compression;
  /** @type {number} */
  this.time;
  /** @type {number} */
  this.date;
  /** @type {number} */
  this.crc32;
  /** @type {number} */
  this.compressedSize;
  /** @type {number} */
  this.plainSize;
  /** @type {number} */
  this.fileNameLength;
  /** @type {number} */
  this.extraFieldLength;
  /** @type {string} */
  this.filename;
  /** @type {!(Array.<number>|Uint8Array)} */
  this.extraField;
};

Zlib$1.Unzip.LocalFileHeader.Flags = Zlib$1.Zip.Flags;

Zlib$1.Unzip.LocalFileHeader.prototype.parse = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip = this.offset;

  // local file header signature
  if (input[ip++] !== Zlib$1.Unzip.LocalFileHeaderSignature[0] ||
    input[ip++] !== Zlib$1.Unzip.LocalFileHeaderSignature[1] ||
    input[ip++] !== Zlib$1.Unzip.LocalFileHeaderSignature[2] ||
    input[ip++] !== Zlib$1.Unzip.LocalFileHeaderSignature[3]) {
    throw new Error('invalid local file header signature');
  }

  // version needed to extract
  this.needVersion = input[ip++] | (input[ip++] << 8);

  // general purpose bit flag
  this.flags = input[ip++] | (input[ip++] << 8);

  // compression method
  this.compression = input[ip++] | (input[ip++] << 8);

  // last mod file time
  this.time = input[ip++] | (input[ip++] << 8);

  //last mod file date
  this.date = input[ip++] | (input[ip++] << 8);

  // crc-32
  this.crc32 = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // compressed size
  this.compressedSize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // uncompressed size
  this.plainSize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // file name length
  this.fileNameLength = input[ip++] | (input[ip++] << 8);

  // extra field length
  this.extraFieldLength = input[ip++] | (input[ip++] << 8);

  // file name
  this.filename = String.fromCharCode.apply(null,
    input.subarray(ip, ip += this.fileNameLength)
  );

  // extra field
  this.extraField =
    input.subarray(ip, ip += this.extraFieldLength);

  this.length = ip - this.offset;
};


Zlib$1.Unzip.prototype.searchEndOfCentralDirectoryRecord = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip;

  for (ip = input.length - 12; ip > 0; --ip) {
    if (input[ip] === Zlib$1.Unzip.CentralDirectorySignature[0] &&
      input[ip + 1] === Zlib$1.Unzip.CentralDirectorySignature[1] &&
      input[ip + 2] === Zlib$1.Unzip.CentralDirectorySignature[2] &&
      input[ip + 3] === Zlib$1.Unzip.CentralDirectorySignature[3]) {
      this.eocdrOffset = ip;
      return;
    }
  }

  throw new Error('End of Central Directory Record not found');
};

Zlib$1.Unzip.prototype.parseEndOfCentralDirectoryRecord = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip;

  if (!this.eocdrOffset) {
    this.searchEndOfCentralDirectoryRecord();
  }
  ip = this.eocdrOffset;

  // signature
  if (input[ip++] !== Zlib$1.Unzip.CentralDirectorySignature[0] ||
    input[ip++] !== Zlib$1.Unzip.CentralDirectorySignature[1] ||
    input[ip++] !== Zlib$1.Unzip.CentralDirectorySignature[2] ||
    input[ip++] !== Zlib$1.Unzip.CentralDirectorySignature[3]) {
    throw new Error('invalid signature');
  }

  // number of this disk
  this.numberOfThisDisk = input[ip++] | (input[ip++] << 8);

  // number of the disk with the start of the central directory
  this.startDisk = input[ip++] | (input[ip++] << 8);

  // total number of entries in the central directory on this disk
  this.totalEntriesThisDisk = input[ip++] | (input[ip++] << 8);

  // total number of entries in the central directory
  this.totalEntries = input[ip++] | (input[ip++] << 8);

  // size of the central directory
  this.centralDirectorySize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // offset of start of central directory with respect to the starting disk number
  this.centralDirectoryOffset = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // .ZIP file comment length
  this.commentLength = input[ip++] | (input[ip++] << 8);

  // .ZIP file comment
  this.comment =
    input.subarray(ip, ip + this.commentLength);
};

Zlib$1.Unzip.prototype.parseFileHeader = function () {
  /** @type {Array.<Zlib.Unzip.FileHeader>} */
  var filelist = [];
  /** @type {Object.<string, number>} */
  var filetable = {};
  /** @type {number} */
  var ip;
  /** @type {Zlib.Unzip.FileHeader} */
  var fileHeader;
  /*: @type {number} */
  var i;
  /*: @type {number} */
  var il;

  if (this.fileHeaderList) {
    return;
  }

  if (this.centralDirectoryOffset === void 0) {
    this.parseEndOfCentralDirectoryRecord();
  }
  ip = this.centralDirectoryOffset;

  for (i = 0, il = this.totalEntries; i < il; ++i) {
    fileHeader = new Zlib$1.Unzip.FileHeader(this.input, ip);
    fileHeader.parse();
    ip += fileHeader.length;
    filelist[i] = fileHeader;
    filetable[fileHeader.filename] = i;
  }

  if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {
    throw new Error('invalid file header size');
  }

  this.fileHeaderList = filelist;
  this.filenameToIndex = filetable;
};

/**
* @param {number} index file header index.
* @param {Object=} opt_params
* @return {!(Array.<number>|Uint8Array)} file data.
*/
Zlib$1.Unzip.prototype.getFileData = function (index, opt_params) {
  opt_params = opt_params || {};
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {Array.<Zlib.Unzip.FileHeader>} */
  var fileHeaderList = this.fileHeaderList;
  /** @type {Zlib.Unzip.LocalFileHeader} */
  var localFileHeader;
  /** @type {number} */
  var offset;
  /** @type {number} */
  var length;
  /** @type {!(Array.<number>|Uint8Array)} */
  var buffer;
  /** @type {number} */
  var crc32;
  /** @type {Array.<number>|Uint32Array|Object} */
  var key;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  if (!fileHeaderList) {
    this.parseFileHeader();
  }

  if (fileHeaderList[index] === void 0) {
    throw new Error('wrong index');
  }

  offset = fileHeaderList[index].relativeOffset;
  localFileHeader = new Zlib$1.Unzip.LocalFileHeader(this.input, offset);
  localFileHeader.parse();
  offset += localFileHeader.length;
  length = localFileHeader.compressedSize;

  // decryption
  if ((localFileHeader.flags & Zlib$1.Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {
    if (!(opt_params['password'] || this.password)) {
      throw new Error('please set password');
    }
    key = this.createDecryptionKey(opt_params['password'] || this.password);

    // encryption header
    for (i = offset, il = offset + 12; i < il; ++i) {
      this.decode(key, input[i]);
    }
    offset += 12;
    length -= 12;

    // decryption
    for (i = offset, il = offset + length; i < il; ++i) {
      input[i] = this.decode(key, input[i]);
    }
  }

  switch (localFileHeader.compression) {
    case Zlib$1.Unzip.CompressionMethod.STORE:
      buffer =
        this.input.subarray(offset, offset + length);
      break;
    case Zlib$1.Unzip.CompressionMethod.DEFLATE:
      buffer = new Zlib$1.RawInflate(this.input, {
        'index': offset,
        'bufferSize': localFileHeader.plainSize
      }).decompress();
      break;
    default:
      throw new Error('unknown compression type');
  }

  if (this.verify) {
    crc32 = Zlib$1.CRC32.calc(buffer);
    if (localFileHeader.crc32 !== crc32) {
      throw new Error(
        'wrong crc: file=0x' + localFileHeader.crc32.toString(16) +
        ', data=0x' + crc32.toString(16)
      );
    }
  }

  return buffer;
};

/**
* @return {Array.<string>}
*/
Zlib$1.Unzip.prototype.getFilenames = function () {
  /** @type {Array.<string>} */
  var filenameList = [];
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;
  /** @type {Array.<Zlib.Unzip.FileHeader>} */
  var fileHeaderList;

  if (!this.fileHeaderList) {
    this.parseFileHeader();
  }
  fileHeaderList = this.fileHeaderList;

  for (i = 0, il = fileHeaderList.length; i < il; ++i) {
    filenameList[i] = fileHeaderList[i].filename;
  }

  return filenameList;
};

/**
* @param {string} filename extract filename.
* @param {Object=} opt_params
* @return {!(Array.<number>|Uint8Array)} decompressed data.
*/
Zlib$1.Unzip.prototype.decompress = function (filename, opt_params) {
  /** @type {number} */
  var index;

  if (!this.filenameToIndex) {
    this.parseFileHeader();
  }
  index = this.filenameToIndex[filename];

  if (index === void 0) {
    throw new Error(filename + ' not found');
  }

  return this.getFileData(index, opt_params);
};

/**
* @param {(Array.<number>|Uint8Array)} password
*/
Zlib$1.Unzip.prototype.setPassword = function (password) {
  this.password = password;
};

/**
* @param {(Array.<number>|Uint32Array|Object)} key
* @param {number} n
* @return {number}
*/
Zlib$1.Unzip.prototype.decode = function (key, n) {
  n ^= this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));
  this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);

  return n;
};

// common method
Zlib$1.Unzip.prototype.updateKeys = Zlib$1.Zip.prototype.updateKeys;
Zlib$1.Unzip.prototype.createDecryptionKey = Zlib$1.Zip.prototype.createEncryptionKey;
Zlib$1.Unzip.prototype.getByte = Zlib$1.Zip.prototype.getByte;

/**
* @fileoverview 雑多な関数群をまとめたモジュール実装.
*/


/**
* Byte String から Byte Array に変換.
* @param {!string} str byte string.
* @return {!Array.<number>} byte array.
*/
Zlib$1.Util.stringToByteArray = function (str) {
  /** @type {!Array.<(string|number)>} */
  var tmp = str.split('');
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  for (i = 0, il = tmp.length; i < il; i++) {
    tmp[i] = (tmp[i].charCodeAt(0) & 0xff) >>> 0;
  }

  return tmp;
};


/**
* @fileoverview Adler32 checksum 実装.
*/


/**
* Adler32 ハッシュ値の作成
* @param {!(Array|Uint8Array|string)} array 算出に使用する byte array.
* @return {number} Adler32 ハッシュ値.
*/
Zlib$1.Adler32 = function (array) {
  if (typeof (array) === 'string') {
    array = Zlib$1.Util.stringToByteArray(array);
  }
  return Zlib$1.Adler32.update(1, array);
};

/**
* Adler32 ハッシュ値の更新
* @param {number} adler 現在のハッシュ値.
* @param {!(Array|Uint8Array)} array 更新に使用する byte array.
* @return {number} Adler32 ハッシュ値.
*/
Zlib$1.Adler32.update = function (adler, array) {
  /** @type {number} */
  var s1 = adler & 0xffff;
  /** @type {number} */
  var s2 = (adler >>> 16) & 0xffff;
  /** @type {number} array length */
  var len = array.length;
  /** @type {number} loop length (don't overflow) */
  var tlen;
  /** @type {number} array index */
  var i = 0;

  while (len > 0) {
    tlen = len > Zlib$1.Adler32.OptimizationParameter ?
      Zlib$1.Adler32.OptimizationParameter : len;
    len -= tlen;
    do {
      s1 += array[i++];
      s2 += s1;
    } while (--tlen);

    s1 %= 65521;
    s2 %= 65521;
  }

  return ((s2 << 16) | s1) >>> 0;
};

/**
* Adler32 最適化パラメータ
* 現状では 1024 程度が最適.
* @see http://jsperf.com/adler-32-simple-vs-optimized/3
* @define {number}
*/
Zlib$1.Adler32.OptimizationParameter = 1024;




/**
* ビットストリーム
* @constructor
* @param {!(Array|Uint8Array)=} buffer output buffer.
* @param {number=} bufferPosition start buffer pointer.
*/
Zlib$1.BitStream = function (buffer, bufferPosition) {
  /** @type {number} buffer index. */
  this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;
  /** @type {number} bit index. */
  this.bitindex = 0;
  /** @type {!(Array|Uint8Array)} bit-stream output buffer. */
  this.buffer = buffer instanceof (Uint8Array) ?
    buffer :
    new (Uint8Array)(Zlib$1.BitStream.DefaultBlockSize);

  // 入力された index が足りなかったら拡張するが、倍にしてもダメなら不正とする
  if (this.buffer.length * 2 <= this.index) {
    throw new Error("invalid index");
  } else if (this.buffer.length <= this.index) {
    this.expandBuffer();
  }
};

/**
* デフォルトブロックサイズ.
* @const
* @type {number}
*/
Zlib$1.BitStream.DefaultBlockSize = 0x8000;

/**
* expand buffer.
* @return {!(Array|Uint8Array)} new buffer.
*/
Zlib$1.BitStream.prototype.expandBuffer = function () {
  /** @type {!(Array|Uint8Array)} old buffer. */
  var oldbuf = this.buffer;
  /** @type {number} loop limiter. */
  var il = oldbuf.length;
  /** @type {!(Array|Uint8Array)} new buffer. */
  var buffer =
    new (Uint8Array)(il << 1);

  // copy buffer
  {
    buffer.set(oldbuf);
  }

  return (this.buffer = buffer);
};


/**
* 数値をビットで指定した数だけ書き込む.
* @param {number} number 書き込む数値.
* @param {number} n 書き込むビット数.
* @param {boolean=} reverse 逆順に書き込むならば true.
*/
Zlib$1.BitStream.prototype.writeBits = function (number, n, reverse) {
  var buffer = this.buffer;
  var index = this.index;
  var bitindex = this.bitindex;

  /** @type {number} current octet. */
  var current = buffer[index];
  /** @type {number} loop counter. */
  var i;

  /**
   * 32-bit 整数のビット順を逆にする
   * @param {number} n 32-bit integer.
   * @return {number} reversed 32-bit integer.
   * @private
   */
  function rev32_(n) {
    return (Zlib$1.BitStream.ReverseTable[n & 0xFF] << 24) |
      (Zlib$1.BitStream.ReverseTable[n >>> 8 & 0xFF] << 16) |
      (Zlib$1.BitStream.ReverseTable[n >>> 16 & 0xFF] << 8) |
      Zlib$1.BitStream.ReverseTable[n >>> 24 & 0xFF];
  }

  if (reverse && n > 1) {
    number = n > 8 ?
      rev32_(number) >> (32 - n) :
      Zlib$1.BitStream.ReverseTable[number] >> (8 - n);
  }

  // Byte 境界を超えないとき
  if (n + bitindex < 8) {
    current = (current << n) | number;
    bitindex += n;
    // Byte 境界を超えるとき
  } else {
    for (i = 0; i < n; ++i) {
      current = (current << 1) | ((number >> n - i - 1) & 1);

      // next byte
      if (++bitindex === 8) {
        bitindex = 0;
        buffer[index++] = Zlib$1.BitStream.ReverseTable[current];
        current = 0;

        // expand
        if (index === buffer.length) {
          buffer = this.expandBuffer();
        }
      }
    }
  }
  buffer[index] = current;

  this.buffer = buffer;
  this.bitindex = bitindex;
  this.index = index;
};


/**
* ストリームの終端処理を行う
* @return {!(Array|Uint8Array)} 終端処理後のバッファを byte array で返す.
*/
Zlib$1.BitStream.prototype.finish = function () {
  var buffer = this.buffer;
  var index = this.index;

  /** @type {!(Array|Uint8Array)} output buffer. */
  var output;

  // bitindex が 0 の時は余分に index が進んでいる状態
  if (this.bitindex > 0) {
    buffer[index] <<= 8 - this.bitindex;
    buffer[index] = Zlib$1.BitStream.ReverseTable[buffer[index]];
    index++;
  }

  // array truncation
  {
    output = buffer.subarray(0, index);
  }

  return output;
};

/**
* 0-255 のビット順を反転したテーブル
* @const
* @type {!(Uint8Array|Array.<number>)}
*/
Zlib$1.BitStream.ReverseTable = (function (table) {
  return table;
})((function () {
  /** @type {!(Array|Uint8Array)} reverse table. */
  var table = new (Uint8Array)(256);
  /** @type {number} loop counter. */
  var i;

  // generate
  for (i = 0; i < 256; ++i) {
    table[i] = (function (n) {
      var r = n;
      var s = 7;

      for (n >>>= 1; n; n >>>= 1) {
        r <<= 1;
        r |= n & 1;
        --s;
      }

      return (r << s & 0xff) >>> 0;
    })(i);
  }

  return table;
})());

/**
* CRC32 ハッシュ値を取得
* @param {!(Array.<number>|Uint8Array)} data data byte array.
* @param {number=} pos data position.
* @param {number=} length data length.
* @return {number} CRC32.
*/
Zlib$1.CRC32.calc = function (data, pos, length) {
  return Zlib$1.CRC32.update(data, 0, pos, length);
};

/**
* CRC32ハッシュ値を更新
* @param {!(Array.<number>|Uint8Array)} data data byte array.
* @param {number} crc CRC32.
* @param {number=} pos data position.
* @param {number=} length data length.
* @return {number} CRC32.
*/
Zlib$1.CRC32.update = function (data, crc, pos, length) {
  var table = Zlib$1.CRC32.Table;
  var i = (typeof pos === 'number') ? pos : (pos = 0);
  var il = (typeof length === 'number') ? length : data.length;

  crc ^= 0xffffffff;

  // loop unrolling for performance
  for (i = il & 7; i--; ++pos) {
    crc = (crc >>> 8) ^ table[(crc ^ data[pos]) & 0xff];
  }
  for (i = il >> 3; i--; pos += 8) {
    crc = (crc >>> 8) ^ table[(crc ^ data[pos]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 1]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 2]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 3]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 4]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 5]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 6]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 7]) & 0xff];
  }

  return (crc ^ 0xffffffff) >>> 0;
};

/**
* @param {number} num
* @param {number} crc
* @returns {number}
*/
Zlib$1.CRC32.single = function (num, crc) {
  return (Zlib$1.CRC32.Table[(num ^ crc) & 0xff] ^ (num >>> 8)) >>> 0;
};

/**
* @type {Array.<number>}
* @const
* @private
*/
Zlib$1.CRC32.Table_ = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
  0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
  0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
  0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
  0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
  0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
  0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
  0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
  0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
  0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
  0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
  0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
  0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
  0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
  0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
  0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
  0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
  0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
];

/**
* @type {!(Array.<number>|Uint32Array)} CRC-32 Table.
* @const
*/
Zlib$1.CRC32.Table = new Uint32Array(Zlib$1.CRC32.Table_);

/**
* @fileoverview Deflate (RFC1951) 実装.
* Deflateアルゴリズム本体は Zlib.RawDeflate で実装されている.
*/

/**
* Zlib Deflate
* @constructor
* @param {!(Array|Uint8Array)} input 符号化する対象の byte array.
* @param {Object=} opt_params option parameters.
*/
Zlib$1.Deflate = function (input, opt_params) {
  /** @type {!(Array|Uint8Array)} */
  this.input = input;
  /** @type {!(Array|Uint8Array)} */
  this.output =
    new (Uint8Array)(Zlib$1.Deflate.DefaultBufferSize);
  /** @type {Zlib.Deflate.CompressionType} */
  this.compressionType = Zlib$1.Deflate.CompressionType.DYNAMIC;
  /** @type {Zlib.RawDeflate} */
  this.rawDeflate;
  /** @type {Object} */
  var rawDeflateOption = {};
  /** @type {string} */
  var prop;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (typeof opt_params['compressionType'] === 'number') {
      this.compressionType = opt_params['compressionType'];
    }
  }

  // copy options
  for (prop in opt_params) {
    rawDeflateOption[prop] = opt_params[prop];
  }

  // set raw-deflate output buffer
  rawDeflateOption['outputBuffer'] = this.output;

  this.rawDeflate = new Zlib$1.RawDeflate(this.input, rawDeflateOption);
};

/**
* @const
* @type {number} デフォルトバッファサイズ.
*/
Zlib$1.Deflate.DefaultBufferSize = 0x8000;

/**
* @enum {number}
*/
Zlib$1.Deflate.CompressionType = Zlib$1.RawDeflate.CompressionType;

/**
* 直接圧縮に掛ける.
* @param {!(Array|Uint8Array)} input target buffer.
* @param {Object=} opt_params option parameters.
* @return {!(Array|Uint8Array)} compressed data byte array.
*/
Zlib$1.Deflate.compress = function (input, opt_params) {
  return (new Zlib$1.Deflate(input, opt_params)).compress();
};

/**
* Deflate Compression.
* @return {!(Array|Uint8Array)} compressed data byte array.
*/
Zlib$1.Deflate.prototype.compress = function () {
  /** @type {Zlib.CompressionMethod} */
  var cm;
  /** @type {number} */
  var cinfo;
  /** @type {number} */
  var cmf;
  /** @type {number} */
  var flg;
  /** @type {number} */
  var fcheck;
  /** @type {number} */
  var fdict;
  /** @type {number} */
  var flevel;
  /** @type {number} */
  var adler;
  /** @type {!(Array|Uint8Array)} */
  var output;
  /** @type {number} */
  var pos = 0;

  output = this.output;

  // Compression Method and Flags
  cm = Zlib$1.CompressionMethod.DEFLATE;
  switch (cm) {
    case Zlib$1.CompressionMethod.DEFLATE:
      cinfo = Math.LOG2E * Math.log(Zlib$1.RawDeflate.WindowSize) - 8;
      break;
    default:
      throw new Error('invalid compression method');
  }
  cmf = (cinfo << 4) | cm;
  output[pos++] = cmf;

  // Flags
  fdict = 0;
  switch (cm) {
    case Zlib$1.CompressionMethod.DEFLATE:
      switch (this.compressionType) {
        case Zlib$1.Deflate.CompressionType.NONE: flevel = 0; break;
        case Zlib$1.Deflate.CompressionType.FIXED: flevel = 1; break;
        case Zlib$1.Deflate.CompressionType.DYNAMIC: flevel = 2; break;
        default: throw new Error('unsupported compression type');
      }
      break;
    default:
      throw new Error('invalid compression method');
  }
  flg = (flevel << 6) | (fdict << 5);
  fcheck = 31 - (cmf * 256 + flg) % 31;
  flg |= fcheck;
  output[pos++] = flg;

  // Adler-32 checksum
  adler = Zlib$1.Adler32(this.input);

  this.rawDeflate.op = pos;
  output = this.rawDeflate.compress();
  pos = output.length;

  {
    // subarray 分を元にもどす
    output = new Uint8Array(output.buffer);
    // expand buffer
    if (output.length <= pos + 4) {
      this.output = new Uint8Array(output.length + 4);
      this.output.set(output);
      output = this.output;
    }
    output = output.subarray(0, pos + 4);
  }

  // adler32
  output[pos++] = (adler >> 24) & 0xff;
  output[pos++] = (adler >> 16) & 0xff;
  output[pos++] = (adler >> 8) & 0xff;
  output[pos++] = (adler) & 0xff;

  return output;
};
if (typeof btoa === 'undefined') {
  require('btoa');
}

if (typeof process === 'object' && typeof window === 'undefined') {
  global.atob = function (str) {
    return Buffer.from(str, 'base64').toString('binary');
  };
}

/**
* Make the target element movable by clicking and dragging on the handle.  This is not a general purprose function,
* it makes several options specific to igv dialogs, the primary one being that the
* target is absolutely positioned in pixel coordinates

*/

let dragData;   // Its assumed we are only dragging one element at a time.


function makeDraggable(target, handle) {
  handle.addEventListener('mousedown', dragStart.bind(target));
}


function dragStart(event) {

  event.stopPropagation();
  event.preventDefault();

  offset(this);
  const dragFunction = drag.bind(this);
  const dragEndFunction = dragEnd.bind(this);
  const computedStyle = getComputedStyle(this);
  const top = parseInt(computedStyle.top.replace("px", ""));
  const left = parseInt(computedStyle.left.replace("px", ""));

  dragData =
  {
    dragFunction: dragFunction,
    dragEndFunction: dragEndFunction,
    screenX: event.screenX,
    screenY: event.screenY,
    top: top,
    left: left
  };

  document.addEventListener('mousemove', dragFunction);
  document.addEventListener('mouseup', dragEndFunction);
  document.addEventListener('mouseleave', dragEndFunction);
  document.addEventListener('mouseexit', dragEndFunction);
}

function drag(event) {

  if (!dragData) {
    return;
  }
  event.stopPropagation();
  event.preventDefault();
  const dx = event.screenX - dragData.screenX;
  const dy = event.screenY - dragData.screenY;
  this.style.left = `${dragData.left + dx}px`;
  this.style.top = `${dragData.top + dy}px`;
}

function dragEnd(event) {

  if (!dragData) {
    return;
  }
  event.stopPropagation();
  event.preventDefault();

  const dragFunction = dragData.dragFunction;
  const dragEndFunction = dragData.dragEndFunction;
  document.removeEventListener('mousemove', dragFunction);
  document.removeEventListener('mouseup', dragEndFunction);
  document.removeEventListener('mouseleave', dragEndFunction);
  document.removeEventListener('mouseexit', dragEndFunction);
  dragData = undefined;
}


const appleCrayonPalette = [
  '#f6cacc', '#f1a7a9', '#ec8385', '#e66063', '#e35053', '#FF0000', '#d02224', '#bd1f21', '#ac1c1e', '#9c191b',
  '#ffedd8', '#f3d5b5', '#e7bc91', '#d4a276', '#bc8a5f', '#a47148', '#8b5e34', '#6f4518', '#603808', '#583101',
  '#fff75e', '#fff056', '#ffe94e', '#ffe246', '#ffda3d', '#ffd53e', ' #fecf3e', '#fdc43f', '#fdbe39', '#fdb833',
  '#b7efc5', '#92e6a7', '#6ede8a', '#4ad66d', '#2dc653', '#25a244', '#208b3a', '#1a7431', '#155d27', '#10451d',
  '#3fc1c0', '#20bac5', '#00b2ca', '#04a6c2', '#0899ba', '#0f80aa', '#16679a', '#1a5b92', '#1c558e', '#1d4e89',
  '#e3f2fd', '#bbdefb', '#90caf9', '#64b5f6', '#42a5f5', '#2196f3', '#1e88e5', '#1976d2', '#1565c0', '#0d47a1',
  '#dec9e9', '#dac3e8', '#d2b7e5', '#c19ee0', '#b185db', '#a06cd5', '#9163cb', '#815ac0', '#7251b5', '#6247aa',
  '#f8f9fa', '#e9ecef', '#dee2e6', '#ced4da', '#adb5bd', '#6c757d', '#6E6E6E', '#495057', '#343a40', '#212529'
]

const appleCrayonPalette1 =
{
  licorice: "#000000",
  lead: "#1e1e1e",
  tungsten: "#3a3a3a",
  iron: "#545453",
  steel: "#6e6e6e",
  tin: "#878687",
  nickel: "#888787",
  aluminum: "#a09fa0",
  magnesium: "#b8b8b8",
  silver: "#d0d0d0",
  mercury: "#e8e8e8",
  snow: "#ffffff",
  //
  cayenne: "#891100",
  mocha: "#894800",
  aspargus: "#888501",
  fern: "#458401",
  clover: "#028401",
  moss: "#018448",
  teal: "#008688",
  ocean: "#004a88",
  midnight: "#001888",
  eggplant: "#491a88",
  plum: "#891e88",
  maroon: "#891648",
  //
  maraschino: "#ff2101",
  tangerine: "#ff8802",
  lemon: "#fffa03",
  lime: "#83f902",
  spring: "#05f802",
  seam_foam: "#03f987",
  turquoise: "#00fdff",
  aqua: "#008cff",
  blueberry: "#002eff",
  grape: "#8931ff",
  magenta: "#ff39ff",
  strawberry: "#ff2987",
  //
  salmon: "#ff726e",
  cantaloupe: "#ffce6e",
  banana: "#fffb6d",
  honeydew: "#cefa6e",
  flora: "#68f96e",
  spindrift: "#68fbd0",
  ice: "#68fdff",
  sky: "#6acfff",
  orchid: "#6e76ff",
  lavender: "#d278ff",
  bubblegum: "#ff7aff",
  carnation: "#ff7fd3"
};

// The MIT License (MIT)

/**
* @constructor
* @param {Object} options A set op options to pass to the throttle function
*        @param {number} requestsPerSecond The amount of requests per second
*                                          the library will limit to
*/
class Throttle {
  constructor(options) {
    this.requestsPerSecond = options.requestsPerSecond || 10;
    this.lastStartTime = 0;
    this.queued = [];
  }

  /**
   * Adds a promise
   * @param {Function} async function to be executed
   * @param {Object} options A set of options.
   * @return {Promise} A promise
   */
  add(asyncFunction, options) {

    var self = this;
    return new Promise(function (resolve, reject) {
      self.queued.push({
        resolve: resolve,
        reject: reject,
        asyncFunction: asyncFunction,
      });
      self.dequeue();
    });
  }

  /**
   * Adds all the promises passed as parameters
   * @param {Function} promises An array of functions that return a promise
   * @param {Object} options A set of options.
   * @param {number} options.signal An AbortSignal object that can be used to abort the returned promise
   * @param {number} options.weight A "weight" of each operation resolving by array of promises
   * @return {Promise} A promise that succeeds when all the promises passed as options do
   */
  addAll(promises, options) {
    var addedPromises = promises.map(function (promise) {
      return this.add(promise, options);
    }.bind(this));

    return Promise.all(addedPromises);
  };

  /**
   * Dequeues a promise
   * @return {void}
   */
  dequeue() {
    if (this.queued.length > 0) {
      var now = new Date(),
        inc = (1000 / this.requestsPerSecond) + 1,
        elapsed = now - this.lastStartTime;

      if (elapsed >= inc) {
        this._execute();
      } else {
        // we have reached the limit, schedule a dequeue operation
        setTimeout(function () {
          this.dequeue();
        }.bind(this), inc - elapsed);
      }
    }
  }

  /**
   * Executes the promise
   * @private
   * @return {void}
   */
  async _execute() {
    this.lastStartTime = new Date();
    var candidate = this.queued.shift();
    const f = candidate.asyncFunction;
    try {
      const r = await f();
      candidate.resolve(r);
    } catch (e) {
      candidate.reject(e);
    }

  }


}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

new Throttle({
  requestsPerSecond: 8
});

class Textbox {

  constructor({ value, label, onchange }) {

    this.elem = div({ class: 'igv-ui-generic-dialog-label-input' });

    if (label) {
      const div$1 = div();
      div$1.innerHTML = label;
      this.elem.appendChild(div$1);
    }

    this.textBox = create('input');
    if (value) {
      this.textBox.value = value;
    }
    this.elem.appendChild(this.textBox);

    if (onchange) {
      this.textBox.addEventListener('change', (e) => onchange(this.textBox.value));
    }
  }

  get value() {
    return this.textBox.value;
  }

  set value(v) {
    this.textBox.value = v;
  }
}

/**
* Generic container for UI components
*/
class Panel {

  constructor() {

    this.elem = create('div', {
      class: 'igv-ui-panel-column'
    });
  }

  add(component) {

    if (component instanceof Node) {
      this.elem.append(component);
    }
    else if (typeof component === 'object') {
      this.elem.append(component.elem);
    }
    else {
      // Assuming a string, possibly html
      const wrapper = div();
      wrapper.innerHTML = component;
      this.elem.append(wrapper);
    }
  }


}

class Dialog {

  constructor({ label, content, okHandler, cancelHandler }) {

    const cancel = () => {
      hide(this.elem);
      if (typeof cancelHandler === 'function') {
        cancelHandler(this);
      }
    };

    // dialog container
    this.elem = div({ class: 'igv-ui-generic-dialog-container' });

    // dialog header
    const header = div({ class: 'igv-ui-generic-dialog-header' });
    this.elem.appendChild(header);

    attachDialogCloseHandlerWithParent(header, cancel);

    // dialog label
    if (label) {
      const labelDiv = div({ class: 'igv-ui-dialog-one-liner' });
      this.elem.appendChild(labelDiv);
      labelDiv.innerHTML = label;
    }

    // input container
    content.elem.style.margin = '8px';
    this.elem.appendChild(content.elem);

    // ok | cancel
    const buttons = div({ class: 'igv-ui-generic-dialog-ok-cancel' });
    this.elem.appendChild(buttons);

    // ok
    this.ok = div();
    buttons.appendChild(this.ok);
    this.ok.textContent = 'OK';

    // cancel
    this.cancel = div();
    buttons.appendChild(this.cancel);
    this.cancel.textContent = 'Cancel';

    this.ok.addEventListener('click', (e) => {
      hide(this.elem);
      if (typeof okHandler === 'function') {
        okHandler(this);
      }
    });

    this.cancel.addEventListener('click', cancel);

    makeDraggable(this.elem, header);


    // Consume all clicks in component
    this.elem.addEventListener('click', (e) => {
      e.preventDefault;
      e.stopPropagation();
    });

  }

  present(options, e) {

    this.label.textContent = options.label;
    this.input.value = options.value;
    this.callback = options.callback;

    const page = pageCoordinates(e);
    this.clampLocation(page.x, page.y);

    show(this.elem);
  }

  clampLocation(pageX, pageY) {

    let popoverRect = this.elem.getBoundingClientRect();
    let parentRect = this.parent.getBoundingClientRect();
    const y = Math.min(Math.max(pageY, parentRect.y), parentRect.y + parentRect.height - popoverRect.height);
    const x = Math.min(Math.max(pageX, parentRect.x), parentRect.x + parentRect.width - popoverRect.width);
    this.elem.style.left = x + "px";
    this.elem.style.top = y + "px";
  }
}

class DataRangeDialog {

  constructor(parent, okHandler) {

    const panel = new Panel();
    this.minbox = new Textbox({ label: "Minimum", value: "0" });
    panel.add(this.minbox);

    this.maxbox = new Textbox({ label: "Maximum", value: "0" });
    panel.add(this.maxbox);

    let callback;
    if (okHandler) {
      callback = (e) => {
        okHandler(Number.parseFloat(this.minbox.value), Number.parseFloat(this.maxbox.value));
      };
    } else {
      callback = (d) => {
      };
    }

    this.dialog = new Dialog({
      //label: 'Multi-select',
      content: panel,
      okHandler: callback
    });

    // Overide some css styles -- TODO redesign this.
    this.dialog.elem.style.position = "absolute";

    hide(this.dialog.elem);
    parent.appendChild(this.dialog.elem);
  }

  show({ min, max }) {
    if (min !== undefined) this.minbox.value = min.toString();
    if (max !== undefined) this.maxbox.value = max.toString();
    show(this.dialog.elem);
  }
}

const httpMessages =
{
  "401": "Access unauthorized",
  "403": "Access forbidden",
  "404": "Not found"
};


class AlertDialog {
  constructor(parent) {

    // container
    this.container = div({ class: "igv-ui-alert-dialog-container" });
    parent.appendChild(this.container);
    this.container.setAttribute('tabIndex', '-1');

    // header
    const header = div();
    this.container.appendChild(header);

    this.errorHeadline = div();
    header.appendChild(this.errorHeadline);
    this.errorHeadline.textContent = '';

    // body container
    let bodyContainer = div({ id: 'igv-ui-alert-dialog-body' });
    this.container.appendChild(bodyContainer);

    // body copy
    this.body = div({ id: 'igv-ui-alert-dialog-body-copy' });
    bodyContainer.appendChild(this.body);

    // ok container
    let ok_container = div();
    this.container.appendChild(ok_container);

    // ok
    this.ok = div();
    ok_container.appendChild(this.ok);
    this.ok.textContent = 'OK';

    const okHandler = () => {

      if (typeof this.callback === 'function') {
        this.callback("OK");
        this.callback = undefined;
      }
      this.body.innerHTML = '';
      hide(this.container);
    };

    this.ok.addEventListener('click', event => {

      event.stopPropagation();

      okHandler();
    });

    this.container.addEventListener('keypress', event => {

      event.stopPropagation();

      if ('Enter' === event.key) {
        okHandler();
      }
    });

    makeDraggable(this.container, header);

    hide(this.container);
  }

  present(alert, callback) {

    this.errorHeadline.textContent = alert.message ? 'ERROR' : '';
    let string = alert.message || alert;

    if (httpMessages.hasOwnProperty(string)) {
      string = httpMessages[string];
    }

    this.body.innerHTML = string;
    this.callback = callback;
    show(this.container);
    this.container.focus();
  }
}

// The global Alert dialog

let alertDialog;

const Alert$1 = {

  init(root) {
    if (!alertDialog) {
      alertDialog = new AlertDialog(root);
    }
  },

  presentAlert(alert, callback) {
    if (!alertDialog) {
      this.init(document.body);
    }
    alertDialog.present(alert, callback);
  },
};

class InputDialog {

  constructor(parent) {

    this.parent = parent;

    // dialog container
    this.container = div({ class: 'igv-ui-generic-dialog-container' });
    parent.appendChild(this.container);

    // const { x, y, width, height } = this.container.getBoundingClientRect();
    // console.log(`InputDialog - x ${ x } y ${ y } width ${ width } height ${ height }`)

    // dialog header
    const header = div({ class: 'igv-ui-generic-dialog-header' });
    this.container.appendChild(header);

    // dialog label
    this.label = div({ class: 'igv-ui-generic-dialog-one-liner' });
    this.container.appendChild(this.label);
    this.label.text = 'Unlabeled';

    // input container
    this.input_container = div({ class: 'igv-ui-generic-dialog-input' });
    this.container.appendChild(this.input_container);
    //
    this.input = document.createElement("input");
    this.input_container.appendChild(this.input);


    // ok | cancel
    const buttons = div({ class: 'igv-ui-generic-dialog-ok-cancel' });
    this.container.appendChild(buttons);

    // ok
    this.ok = div();
    buttons.appendChild(this.ok);
    this.ok.textContent = 'OK';

    // cancel
    this.cancel = div();
    buttons.appendChild(this.cancel);
    this.cancel.textContent = 'Cancel';

    hide(this.container);

    this.input.addEventListener('keyup', e => {
      if (13 === e.keyCode) {
        if (typeof this.callback === 'function') {
          this.callback(this.input.value);
          this.callback = undefined;
        }
        this.input.value = undefined;
        hide(this.container);
      }
    });

    this.ok.addEventListener('click', () => {
      if (typeof this.callback === 'function') {
        this.callback(this.input.value);
        this.callback = undefined;
      }
      this.input.value = undefined;
      hide(this.container);
    });

    const cancel = () => {
      this.input.value = '';
      hide(this.container);
    };

    this.cancel.addEventListener('click', cancel);

    attachDialogCloseHandlerWithParent(header, cancel);
    makeDraggable(this.container, header);

  }

  present(options, e) {

    this.label.textContent = options.label;
    this.input.value = options.value;
    this.callback = options.callback || options.click;

    show(this.container);
    const { x, y } = pageCoordinates(e);
    this.clampLocation(x, y);

  }

  clampLocation(pageX, pageY) {

    const { width: w, height: h } = this.container.getBoundingClientRect();

    const { x: px, y: py, width: pw, height: ph } = this.parent.getBoundingClientRect();

    const y = Math.min(Math.max(pageY, py), py + ph - h);
    const x = Math.min(Math.max(pageX, px), px + pw - w);
    this.container.style.left = `${x}px`;
    this.container.style.top = `${y}px`;
  }
}

class GenericContainer {

  constructor({ parent, top, left, width, height, border, closeHandler }) {

    let container = div({ class: 'igv-ui-generic-container' });
    parent.appendChild(container);
    hide(container);
    this.container = container;

    if (top !== undefined) {
      this.container.style.top = `${top}px`;
    }
    if (left !== undefined) {
      this.container.style.left = `${left}px`;
    }
    if (width !== undefined) {
      this.container.style.width = `${width}px`;
    }
    if (height !== undefined) {
      this.container.style.height = `${height}px`;
    }
    if (border) {
      this.container.style.border = border;
    }
    //
    // let bbox = parent.getBoundingClientRect();
    // this.origin = {x: bbox.x, y: bbox.y};
    // this.container.offset({left: this.origin.x, top: this.origin.y});

    // header
    const header = div();
    this.container.appendChild(header);

    // close button
    attachDialogCloseHandlerWithParent(header, (e) => {
      hide(this.container);
      if (typeof closeHandler === "function") {
        closeHandler(e);
      }
    });

    makeDraggable(this.container, header);
  }

  show() {
    show(this.container);
  }

  hide() {
    hide(this.container);
  }

  dispose() {
    if (this.container.parent) {
      this.container.parent.removeChild(this.container);
    }
  }
}

class ColorPicker extends GenericContainer {

  constructor({ parent, top, left, width, height, defaultColors, colorHandler }) {

    super({ parent, top, left, width, height, border: '1px solid gray' });

    createColorSwatchSelector(this.container, colorHandler, defaultColors);
  }

}

const createColorSwatchSelector = (container, colorHandler, defaultColors) => {

  const hexColorStrings = Object.values(appleCrayonPalette);

  for (let hexColorString of hexColorStrings) {
    const swatch = div({ class: 'igv-ui-color-swatch' });
    container.appendChild(swatch);
    decorateSwatch(swatch, hexColorString, colorHandler);
  }

  // if (defaultColors) {
  //     for (let hexColorString of defaultColors) {
  //         const swatch = div({ class: 'igv-ui-color-swatch' });
  //         container.appendChild(swatch);
  //         decorateSwatch(swatch, hexColorString, colorHandler);
  //     }
  // }

};

const decorateSwatch = (swatch, hexColorString, colorHandler) => {

  swatch.style.backgroundColor = hexColorString;

  swatch.addEventListener('mouseenter', e => swatch.style.borderColor = hexColorString);

  swatch.addEventListener('mouseleave', e => swatch.style.borderColor = 'white');

  swatch.addEventListener('click', event => {
    event.stopPropagation();
    colorHandler(hexColorString);
  });

  swatch.addEventListener('touchend', event => {
    event.stopPropagation();
    colorHandler(hexColorString);
  });

};

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

function isMobile() {
  return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
}

function throttle(fn, threshhold, scope) {
  var last,
    deferTimer;

  threshhold || (threshhold = 200);

  return function () {
    var context,
      now,
      args;

    context = scope || this;
    now = +new Date;
    args = arguments;

    if (last && now < last + threshhold) {
      // hold on to it
      clearTimeout(deferTimer);
      deferTimer = setTimeout(function () {
        last = now;
        fn.apply(context, args);
      }, threshhold);
    } else {
      last = now;
      fn.apply(context, args);
    }
  }
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

const Globals = {};

const Track2DDisplaceModes = {
  displayAllMatrix: 'displayAllMatrix',
  displayLowerMatrix: 'displayLowerMatrix',
  displayUpperMatrix: 'displayUpperMatrix'
};

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/
function present$1(e, popover, popoverContent) {

  const { x, y, width } = translateMouseCoordinates(e, popover.parentNode);
  popover.style.top = `${y}px`;

  const { width: w } = popover.getBoundingClientRect();

  const xmax = x + w;
  const delta = xmax - width;

  popover.style.left = `${xmax > width ? (x - delta) : x}px`;
  popoverContent.style.maxWidth = `${Math.min(w, width)}px`;


}

class Popover {

  constructor(parent, title) {

    this.parent = parent;

    // popover


    this.popover = div({ class: "igv-ui-1_3_0-popover" });
    parent.appendChild(this.popover);

    // header
    const popoverHeader = div();
    this.popover.appendChild(popoverHeader);

    const titleElement = div();
    popoverHeader.appendChild(titleElement);
    if (title) {
      titleElement.textContent = title;
    }

    attachDialogCloseHandlerWithParent(popoverHeader, () => this.hide());
    makeDraggable(this.popover, popoverHeader);

    // content
    this.popoverContent = div();
    this.popover.appendChild(this.popoverContent);

    this.popover.style.display = 'none';


  }

  presentContentWithEvent(e, content) {

    this.popover.style.display = 'block';

    this.popoverContent.innerHTML = content;

    present$1(e, this.popover, this.popoverContent);

  }

  presentMenu(e, menuItems) {

    if (0 === menuItems.length) {
      return
    }

    this.popover.style.display = 'block';

    const menuElements = createMenuElements$1(menuItems, this.popover);
    for (let item of menuElements) {
      this.popoverContent.appendChild(item.object);
    }

    present$1(e, this.popover, this.popoverContent);
  }

  hide() {
    this.popover.style.display = 'none';
    this.dispose();
  }

  dispose() {

    if (this.popover) {
      this.popover.parentNode.removeChild(this.popover);
    }

    const keys = Object.keys(this);
    for (let key of keys) {
      this[key] = undefined;
    }
  }

}

/**
* @author Jim Robinson
*/


/**
* Barebones event bus.
*/

class EventBus {

  constructor() {

    // Map eventType -> list of subscribers
    this.subscribers = {};

    this.stack = [];
  }

  subscribe(eventType, object) {

    var subscriberList = this.subscribers[eventType];
    if (subscriberList == undefined) {
      subscriberList = [];
      this.subscribers[eventType] = subscriberList;
    }
    subscriberList.push(object);

  }

  post(event) {

    const eventType = event.type;

    if (this._hold) {
      this.stack.push(event);
    } else {
      const subscriberList = this.subscribers[eventType];

      if (subscriberList) {
        for (let subscriber of subscriberList) {

          if ("function" === typeof subscriber.receiveEvent) {
            subscriber.receiveEvent(event);
          } else if ("function" === typeof subscriber) {
            subscriber(event);
          }
        }
      }
    }
  }

  hold() {
    this._hold = true;
  }

  release() {
    this._hold = false;
    for (let event of this.stack) {
      this.post(event);
    }
    this.stack = [];
  }
}

// The global event bus

EventBus.globalBus = new EventBus();

class Track2D {

  constructor(config, features) {

    this.config = config;
    this.name = config.name;
    this.featureMap = {};
    this.featureCount = 0;
    this.isVisible = true;

    this.displayMode = Track2DDisplaceModes.displayAllMatrix;

    if (config.color && validateColor(config.color)) {
      this.color = this.color = config.color;    // If specified, this will override colors of individual records.
    }

    this.repColor = features.length > 0 ? features[0].color : "black";

    for (let f of features) {
      this.featureCount++;
      const key = getKey(f.chr1, f.chr2);
      let list = this.featureMap[key];
      if (!list) {
        list = [];
        this.featureMap[key] = list;
      }
      list.push(f);
    }
    for (let k in this.featureMap) {
      let v = this.featureMap[k];
      v.sort(function (a, b) {
        return a.x1 - b.x1;
      });
    }
  }

  static async loadTrack2DData(config, genome) {
    const data = config.data; // 加载数据
    const features = parseData(data, isBedPE(config), genome); // 添加颜色
    return new Track2D(config, features);
  }

  static async loadTrack2D(config, genome) {

    // if (isString(config.url) && config.url.startsWith("https://drive.google.com")) {
    //     const json = await google.getDriveFileInfo(config.url)
    //     config.url = "https://www.googleapis.com/drive/v3/files/" + json.id + "?alt=media";
    //     if (!config.filename) {
    //         config.filename = json.originalFileName || json.name;
    //     }
    //     if (!config.name) {
    //         config.name = json.name || json.originalFileName;
    //     }
    // }

    const data = await igvxhr.loadString(config.url, buildOptions(config)); // 加载数据
    const features = parseData(data, isBedPE(config), genome); // 添加颜色
    return new Track2D(config, features);
  }

  getColor() {
    return this.color || this.repColor;
  }

  getFeatures(chr1, chr2) {
    const key = getKey(chr1, chr2);
    return this.featureMap[key];
  }




}


function isBedPE(config) {

  if (typeof config.url === "string") {
    return config.url.toLowerCase().indexOf(".bedpe") > 0;
  } else if (typeof config.name === "string") {
    return config.name.toLowerCase().indexOf(".bedpe") > 0;
  } else {
    return true;  // Default
  }
}

function parseData(data, isBedPE, genome) {

  if (!data) return null;

  const lines = splitLines(data);
  const allFeatures = [];
  const delimiter = "\t";
  const colorColumn = isBedPE ? 10 : 6;

  let errorCount = 0;
  for (let line of lines) {
    line = line.trim();
    if (line.startsWith("#") || line.startsWith("track") || line.startsWith("browser") || line.length === 0) {
      continue;
    }
    const tokens = line.split(delimiter);
    if (tokens.length < 6 && errorCount <= 5) {
      if (errorCount === 5) {
        console.error("...");
      } else {
        console.error("Could not parse line: " + line);
      }
      errorCount++;
      continue;
    }

    const feature = {
      chr1: genome ? genome.getChromosomeName(tokens[0]) : tokens[0],
      x1: parseInt(tokens[1]),
      x2: parseInt(tokens[2]),
      chr2: genome ? genome.getChromosomeName(tokens[3]) : tokens[3],
      y1: parseInt(tokens[4]),
      y2: parseInt(tokens[5])
    };

    if (tokens.length > colorColumn) {
      feature.color = "rgb(" + tokens[colorColumn] + ")";
    }

    if (!Number.isNaN(feature.x1)) {
      allFeatures.push(feature);
    }
  }

  return allFeatures;
}

function getKey(chr1, chr2) {
  return chr1 > chr2 ? chr2 + "_" + chr1 : chr1 + "_" + chr2;
}

function validateColor(str) {
  var div = document.createElement("div");
  div.style.borderColor = str;
  return div.style.borderColor !== "";
}

function buildOptions(config, options) {
  const defaultOptions = {
    oauthToken: config.oauthToken,
    headers: config.headers,
    withCredentials: config.withCredentials,
    filename: config.filename
  };

  return Object.assign(defaultOptions, options);
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

function setCanvasWidth(canvas, ratio) {
  let cw = canvas.width;
  let ch = canvas.height;

  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';

  canvas.height = ch * ratio;
  canvas.width = cw * ratio;
}

class Ruler {

  constructor(browser, $parent, axis) {

    this.browser = browser;
    this.axis = axis;

    this.$axis = $parent.find(`div[id$='-axis']`);

    this.$canvas = $parent.find("canvas");

    this.ctx = this.$canvas.get(0).getContext("2d");
    this.ctx.canvas.width = this.$axis.width();
    this.ctx.canvas.height = this.$axis.height();

    this.$wholeGenomeContainer = $parent.find("div[id$='-axis-whole-genome-container']");

    this.yAxisTransformWithContext = ctx => {
      ctx.scale(-1, 1);
      ctx.rotate(Math.PI / 2.0);
    };

    this.setAxisTransform(axis);

    browser.eventBus.subscribe('MapLoad', this);
    browser.eventBus.subscribe("UpdateContactMapMousePosition", this);

  }

  wholeGenomeLayout($axis, $wholeGenomeContainer, axisName, dataset) {

    var self = this,
      list,
      dimen,
      extent,
      scraps,
      $div,
      $firstDiv;

    // discard current tiles
    $wholeGenomeContainer.empty();

    list = dataset.chromosomes.filter(function (chromosome) {
      return 'all' !== chromosome.name.toLowerCase();
    });

    extent = 0;    // could use reduce for this
    list.forEach(function (chromosome) {
      extent += chromosome.size;
    });

    dimen = 'x' === axisName ? $axis.width() : $axis.height();

    scraps = 0;
    this.bboxes = [];
    $firstDiv = undefined;

    list.forEach(function (chr) {
      var size,
        percentage;

      percentage = (chr.bpLength) / extent;

      if (percentage * dimen < 1.0) {
        scraps += percentage;
      } else {

        $div = $("<div>", { class: `${self.axis}-axis-whole-genome-chromosome-container` });
        $wholeGenomeContainer.append($div);
        $div.data('label', chr.name);

        // debug
        // $div.get(0).style.backgroundColor = randomRGB(150, 250);

        if (!$firstDiv) {
          $firstDiv = $div;
        }

        if ('x' === axisName) {
          size = Math.round(percentage * dimen);
          $div.width(size);
        } else {
          size = Math.round(percentage * dimen);
          $div.height(size);
        }

        // border
        const $border = $('<div>');
        $div.append($border);

        // label
        const $label = $('<div>');
        $border.append($label);

        $label.text($div.data('label'));
        $label.get(0).title = $div.data('label');

        decorate.call(self, $div);
      }

    });

    scraps *= dimen;
    scraps = Math.floor(scraps);
    if (scraps >= 1) {

      const className = self.axis + '-axis-whole-genome-chromosome-container';
      $div = $("<div>", { class: className });
      $wholeGenomeContainer.append($div);
      $div.data('label', '-');

      $div.width(scraps);

      // className = self.axis + '-axis-whole-genome-chromosome';
      // $e = $("<div>", {class: className});
      // $div.append($e);
      // $e.text($div.data('label'));

      decorate.call(self, $div);
    }

    $wholeGenomeContainer.children().each(function (index) {
      self.bboxes.push(bbox(axisName, $(this), $firstDiv));
    });


    // initially hide
    this.hideWholeGenome();

    function decorate($d) {
      var self = this;

      $d.on('click', function (e) {
        var $o;
        $o = $(this).first();
        self.browser.parseGotoInput($o.text());

        self.unhighlightWholeChromosome();
        self.otherRuler.unhighlightWholeChromosome();
      });

      $d.hover(
        function () {
          hoverHandler.call(self, $(this), true);
        },

        function () {
          hoverHandler.call(self, $(this), false);
        }
      );

    }

    function hoverHandler($e, doHover) {

      var target,
        $target;

      target = $e.data('label');

      this.otherRuler.$wholeGenomeContainer.children().each(function (index) {
        if (target === $(this).data('label')) {
          $target = $(this);
        }
      });

      if (true === doHover) {
        $e.addClass('hic-whole-genome-chromosome-highlight');
        $target.addClass('hic-whole-genome-chromosome-highlight');
      } else {
        $e.removeClass('hic-whole-genome-chromosome-highlight');
        $target.removeClass('hic-whole-genome-chromosome-highlight');
      }
    }

  };

  hideWholeGenome() {
    this.$wholeGenomeContainer.hide();
    this.$canvas.show();
  };

  showWholeGenome() {
    this.$canvas.hide();
    this.$wholeGenomeContainer.show();
  };

  setAxisTransform(axis) {

    this.canvasTransform = ('y' === axis) ? this.yAxisTransformWithContext : identityTransformWithContext;

    this.labelReflectionTransform = ('y' === axis) ? reflectionTransformWithContext : function (context, exe) {
    };

  };

  unhighlightWholeChromosome() {
    this.$wholeGenomeContainer.children().removeClass('hic-whole-genome-chromosome-highlight');
  };

  receiveEvent(event) {
    var offset,
      $e;

    if ('MapLoad' === event.type) {
      this.wholeGenomeLayout(this.$axis, this.$wholeGenomeContainer, this.axis, event.data);
      this.update();
    } else if ('UpdateContactMapMousePosition' === event.type) {

      if (this.bboxes) {
        this.unhighlightWholeChromosome();
        offset = 'x' === this.axis ? event.data.x : event.data.y;
        $e = hitTest(this.bboxes, offset);
        if ($e) {
          // console.log(this.axis + ' highlight chr ' + $e.text());
          $e.addClass('hic-whole-genome-chromosome-highlight');
        }
      }
    }

  };

  locusChange(event) {

    this.update();

  };

  updateWidthWithCalculation(calc) {

    this.$axis.css('width', calc);

    this.$canvas.width(this.$axis.width());
    this.$canvas.attr('width', this.$axis.width());

    this.wholeGenomeLayout(this.$axis, this.$wholeGenomeContainer, this.axis, this.browser.dataset);

    this.update();
  };

  updateHeight(height) {

    this.$canvas.height(height);
    this.$canvas.attr('height', height);

    this.wholeGenomeLayout(this.$axis, this.$wholeGenomeContainer, this.axis, this.browser.dataset);

    this.update();
  };

  update() {

    var w,
      h,
      bin,
      config = {},
      browser = this.browser;

    if (browser.dataset.isWholeGenome(browser.state.chr1)) {
      this.showWholeGenome();
      return;
    }

    this.hideWholeGenome();

    identityTransformWithContext(this.ctx);
    IGVGraphics.fillRect(this.ctx, 0, 0, this.$canvas.width(), this.$canvas.height(), { fillStyle: IGVColor.rgbColor(255, 255, 255) });

    this.canvasTransform(this.ctx);

    w = ('x' === this.axis) ? this.$canvas.width() : this.$canvas.height();
    h = ('x' === this.axis) ? this.$canvas.height() : this.$canvas.width();

    IGVGraphics.fillRect(this.ctx, 0, 0, w, h, { fillStyle: IGVColor.rgbColor(255, 255, 255) });

    config.bpPerPixel = browser.dataset.bpResolutions[browser.state.zoom] / browser.state.pixelSize;

    bin = ('x' === this.axis) ? browser.state.x : browser.state.y;
    config.bpStart = bin * browser.dataset.bpResolutions[browser.state.zoom];

    config.rulerTickMarkReferencePixels = Math.max(Math.max(this.$canvas.width(), this.$canvas.height()), Math.max(this.$otherRulerCanvas.width(), this.$otherRulerCanvas.height()));

    config.rulerLengthPixels = w;
    config.rulerHeightPixels = h;

    config.height = Math.min(this.$canvas.width(), this.$canvas.height());

    this.draw(config);
  };

  draw(options) {

    var fontStyle,
      tickSpec,
      majorTickSpacing,
      nTick,
      pixelLast,
      pixel,
      tickSpacingPixels,
      labelWidthPixels,
      modulo,
      l,
      yShim,
      tickHeight,
      rulerLabel,
      chrSize,
      chromosomes = this.browser.dataset.chromosomes;
    ('x' === this.axis) ? chromosomes[this.browser.state.chr1].name : chromosomes[this.browser.state.chr2].name;
    chrSize = ('x' === this.axis) ? chromosomes[this.browser.state.chr1].size : chromosomes[this.browser.state.chr2].size;

    if (options.chrName === "all"); else {

      IGVGraphics.fillRect(this.ctx, 0, 0, options.rulerLengthPixels, options.rulerHeightPixels, { fillStyle: IGVColor.rgbColor(255, 255, 255) });

      fontStyle = {
        textAlign: 'center',
        font: '9px PT Sans',
        fillStyle: "rgba(64, 64, 64, 1)",
        strokeStyle: "rgba(64, 64, 64, 1)"
      };

      tickSpec = findSpacing(Math.floor(options.rulerTickMarkReferencePixels * options.bpPerPixel));
      majorTickSpacing = tickSpec.majorTick;

      // Find starting point closest to the current origin
      nTick = Math.floor(options.bpStart / majorTickSpacing) - 1;

      pixel = pixelLast = 0;

      IGVGraphics.setProperties(this.ctx, fontStyle);
      this.ctx.lineWidth = 1.0;

      yShim = 1;
      tickHeight = 8;
      while (pixel < options.rulerLengthPixels) {

        l = Math.floor(nTick * majorTickSpacing);

        pixel = Math.round(((l - 1) - options.bpStart + 0.5) / options.bpPerPixel);

        rulerLabel = formatNumber(l / tickSpec.unitMultiplier, 0) + " " + tickSpec.majorUnit;

        tickSpacingPixels = Math.abs(pixel - pixelLast);
        labelWidthPixels = this.ctx.measureText(rulerLabel).width;

        if (labelWidthPixels > tickSpacingPixels) {

          if (tickSpacingPixels < 32) {
            modulo = 4;
          } else {
            modulo = 2;
          }
        } else {
          modulo = 1;
        }

        // modulo = 1;
        if (0 === nTick % modulo) {

          if (Math.floor((pixel * options.bpPerPixel) + options.bpStart) < chrSize) {

            // console.log('   label delta(' + Math.abs(pixel - pixelLast) + ') modulo(' + modulo + ') bpp(' + options.bpPerPixel + ')');

            this.ctx.save();
            this.labelReflectionTransform(this.ctx, pixel);
            IGVGraphics.fillText(this.ctx, rulerLabel, pixel, options.height - (tickHeight / 0.75));
            this.ctx.restore();

          }

        }

        if (Math.floor((pixel * options.bpPerPixel) + options.bpStart) < chrSize) {
          IGVGraphics.strokeLine(this.ctx,
            pixel, options.height - tickHeight,
            pixel, options.height - yShim);
        }

        pixelLast = pixel;
        nTick++;

      } // while (pixel < options.rulerLengthPixels)

      IGVGraphics.strokeLine(this.ctx, 0, options.height - yShim, options.rulerLengthPixels, options.height - yShim);

    }

    function formatNumber(anynum, decimal) {
      //decimal  - the number of decimals after the digit from 0 to 3
      //-- Returns the passed number as a string in the xxx,xxx.xx format.
      //anynum = eval(obj.value);
      var divider = 10;
      switch (decimal) {
        case 0:
          divider = 1;
          break;
        case 1:
          divider = 10;
          break;
        case 2:
          divider = 100;
          break;
        default:       //for 3 decimal places
          divider = 1000;
      }

      var workNum = Math.abs((Math.round(anynum * divider) / divider));

      var workStr = "" + workNum;

      if (-1 === workStr.indexOf(".")) {
        workStr += ".";
      }

      var dStr = workStr.substr(0, workStr.indexOf("."));
      var dNum = dStr - 0;
      var pStr = workStr.substr(workStr.indexOf("."));

      while (pStr.length - 1 < decimal) {
        pStr += "0";
      }

      if ('.' === pStr) {
        pStr = '';
      }

      //--- Adds a comma in the thousands place.
      if (dNum >= 1000) {
        var dLen = dStr.length;
        dStr = parseInt("" + (dNum / 1000)) + "," + dStr.substring(dLen - 3, dLen);
      }

      //-- Adds a comma in the millions place.
      if (dNum >= 1000000) {
        dLen = dStr.length;
        dStr = parseInt("" + (dNum / 1000000)) + "," + dStr.substring(dLen - 7, dLen);
      }
      var retval = dStr + pStr;
      //-- Put numbers in parentheses if negative.
      if (anynum < 0) {
        retval = "(" + retval + ")";
      }

      //You could include a dollar sign in the return value.
      //retval =  "$"+retval
      return retval;
    }
  };
}

function bbox(axis, $child, $firstChild) {
  var delta,
    size,
    o,
    fo;

  o = 'x' === axis ? $child.offset().left : $child.offset().top;
  fo = 'x' === axis ? $firstChild.offset().left : $firstChild.offset().top;

  delta = o - fo;
  size = 'x' === axis ? $child.width() : $child.height();

  return { $e: $child, a: delta, b: delta + size };

}

function hitTest(bboxes, value) {
  var $result,
    success;

  success = false;
  $result = undefined;
  bboxes.forEach(function (bbox) {

    if (false === success) {

      if (value < bbox.a); else if (value > bbox.b); else {
        $result = bbox.$e;
        success = true;
      }

    }

  });

  return $result;
}


function TickSpacing(majorTick, majorUnit, unitMultiplier) {
  this.majorTick = majorTick;
  this.majorUnit = majorUnit;
  this.unitMultiplier = unitMultiplier;
}

function findSpacing(rulerLengthBP) {

  if (rulerLengthBP < 10) {
    return new TickSpacing(1, "", 1);
  }


  // How many zeroes?
  var nZeroes = Math.floor(log10(rulerLengthBP));
  var majorUnit = "";
  var unitMultiplier = 1;
  if (nZeroes > 9) {
    majorUnit = "gb";
    unitMultiplier = 1000000000;
  }
  if (nZeroes > 6) {
    majorUnit = "mb";
    unitMultiplier = 1000000;
  } else if (nZeroes > 3) {
    majorUnit = "kb";
    unitMultiplier = 1000;
  }

  var nMajorTicks = rulerLengthBP / Math.pow(10, nZeroes - 1);
  if (nMajorTicks < 25) {
    return new TickSpacing(Math.pow(10, nZeroes - 1), majorUnit, unitMultiplier);
  } else {
    return new TickSpacing(Math.pow(10, nZeroes) / 2, majorUnit, unitMultiplier);
  }

  function log10(x) {
    var dn = Math.log(10);
    return Math.log(x) / dn;
  }
}

function reflectionTransformWithContext(context, exe) {
  context.translate(exe, 0);
  context.scale(-1, 1);
  context.translate(-exe, 0);
}

function identityTransformWithContext(context) {
  // 3x2 matrix. column major. (sx 0 0 sy tx ty).
  context.setTransform(1, 0, 0, 1, 0, 0);
}

/*
* The MIT License (MIT)
*
* Copyright (c) 2014 Broad Institute
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

const trackMenuItemListHelper = (itemList, $popover) => {

  var list = [];

  if (itemList.length > 0) {

    list = itemList.map(function (item, i) {
      let $e;

      // name and object fields checked for backward compatibility
      if (item.name) {
        $e = $('<div>');
        $e.text(item.name);
      } else if (item.object) {
        $e = $(item.object);     // This creates a JQuery object form a dom element, or clones if already a jQuery object
      } else if (typeof item.label === 'string') {
        $e = $('<div>');
        $e.html(item.label);
      } else if (typeof item === 'string') {

        if (item.startsWith("<")) {
          $e = $(item);
        } else {
          $e = $("<div>" + item + "</div>");
        }
      }

      if (0 === i) {
        $e.addClass('igv-track-menu-border-top');
      }

      if (item.click) {
        $e.on('click', handleClick);
        $e.on('touchend', function (e) {
          handleClick(e);
        });
        $e.on('mouseup', function (e) {
          e.preventDefault;
          e.stopPropagation();
        });

        // eslint-disable-next-line no-inner-declarations
        function handleClick(e) {
          item.click(e);
          $popover.hide();
          e.preventDefault;
          e.stopPropagation();
        }
      }

      return { object: $e, init: (item.init || undefined) };
    });
  }
  return list;
};


const MenuPopup = function ($parent) {

  // popover container
  this.$popover = $('<div>', { class: 'igv-menu-popup' });
  $parent.append(this.$popover);

  // popover header
  let $popoverHeader = $('<div>', { class: 'igv-menu-popup-header' });
  this.$popover.append($popoverHeader);

  attachDialogCloseHandlerWithParent$1($popoverHeader.get(0), () => this.$popover.hide());

  this.$popoverContent = $('<div>');
  this.$popover.append(this.$popoverContent);

  makeDraggable$1(this.$popover.get(0), $popoverHeader.get(0));

  $popoverHeader.on('click.menu-popup-dismiss', function (e) {
    e.stopPropagation();
    e.preventDefault;
    // absorb click to prevent it leaking through to parent DOM element
  });

};

MenuPopup.prototype.presentMenuList = function (dx, dy, list) {

  hideAllMenuPopups();

  if (list.length > 0) {

    this.$popoverContent.empty();

    list = trackMenuItemListHelper(list, this.$popover);

    for (let item of list) {

      if (item.init) {
        item.init();
      }

      let $e = item.object;
      if (0 === list.indexOf(item)) {
        $e.removeClass('igv-track-menu-border-top');
      }

      if ($e.hasClass('igv-track-menu-border-top') || $e.hasClass('igv-menu-popup-check-container')); else if ($e.is('div')) {
        $e.addClass('igv-menu-popup-shim');
      }

      this.$popoverContent.append($e);

    }

    this.$popover.css({ left: (dx + 'px'), top: (dy + 'px') });
    this.$popover.show();

  }
};

MenuPopup.prototype.presentTrackContextMenu = function (e, menuItems) {

  this.$popoverContent.empty();

  const menuElements = createMenuElements(menuItems, this.$popover.get(0));
  for (let item of menuElements) {
    this.$popoverContent.get(0).appendChild(item.object);
  }

  present(e, this.$popover.get(0));

  this.$popover.show();

};

MenuPopup.prototype.dispose = function () {
  this.$popover.empty();
  this.$popoverContent.empty();
  Object.keys(this).forEach(function (key) {
    this[key] = undefined;
  });
};

function createMenuElements(itemList, popover) {

  return itemList.map(item => {

    let elem;

    if (typeof item === 'string' && '<hr/>' === item) {
      elem = document.createElement('hr');
    } else if (typeof item === 'string') {
      elem = div$1({ class: 'context-menu' });
      elem.innerHTML = item;
    } else if (typeof item === 'Node') {
      elem = item;
    } else {
      if (typeof item.init === 'function') {
        item.init();
      }

      if ("checkbox" === item.type) {
        elem = Icon.createCheckbox("Show all bases", item.value);
      } else if ("color" === item.type) {
        const colorPicker = new ColorPicker({
          parent: popover.parentElement,
          width: 364,
          //defaultColor: 'aqua',
          colorHandler: (color) => item.click(color)
        });
        elem = div$1({ class: 'context-menu' });
        if (typeof item.label === 'string') {
          elem.innerHTML = item.label;
        }
        const clickHandler = e => {
          colorPicker.show();
          hide$1(popover);
          e.preventDefault;
          e.stopPropagation();
        };
        elem.addEventListener('click', clickHandler);
        elem.addEventListener('touchend', clickHandler);
        elem.addEventListener('mouseup', function (e) {
          e.preventDefault;
          e.stopPropagation();
        });
      } else {
        elem = div$1({ class: 'context-menu' });
        if (typeof item.label === 'string') {
          elem.innerHTML = item.label;
        }
      }

      if (item.click && "color" !== item.type) {
        elem.addEventListener('click', handleClick);
        elem.addEventListener('touchend', handleClick);
        elem.addEventListener('mouseup', function (e) {
          e.preventDefault;
          e.stopPropagation();
        });

        // eslint-disable-next-line no-inner-declarations
        function handleClick(e) {
          item.click();
          hide$1(popover);
          e.preventDefault;
          e.stopPropagation();
        }
      }
    }


    return { object: elem, init: item.init };
  })

}

function present(e, popover) {

  const { x, y } = translateMouseCoordinates(e, popover.parentNode);

  // parent bbox
  const { width } = popover.parentNode.getBoundingClientRect();
  const { width: w } = popover.getBoundingClientRect();

  const xmax = x + w;

  popover.style.left = `${xmax > width ? (x - (xmax - width)) : x}px`;
  popover.style.top = `${y}px`;

}

const hideAllMenuPopups = () => $('.igv-menu-popup').hide();

/**
* Created by dat on 4/5/17.
*/

class TrackPair {

  constructor(browser, trackHeight, $x_tracks, $y_tracks, track, index) {

    this.browser = browser;
    this.track = track;
    this.x = new TrackRenderer(browser, { height: trackHeight }, $x_tracks, track, 'x', index);
    this.y = new TrackRenderer(browser, { width: trackHeight }, $y_tracks, track, 'y', index);
    this.init();
  }

  init() {

    this.colorPicker = new ColorPicker({
      parent: this.x.$viewport[0],
      width: 456,
      height: undefined,
      colorHandler: color => this.setColor(color)
    });
    this.colorPicker.hide();

    this.dataRangeDialog = new DataRangeDialog(this.x.$viewport[0],
      (min, max) => this.setDataRange(min, max));


    this.appendRightHandGutter(this.x.$viewport);

    // igvjs compatibility
    this.track.trackView = this;
    this.track.trackView.trackDiv = this.x.$viewport.get(0);

  }

  presentColorPicker() {
    const bbox = this.x.trackDiv.getBoundingClientRect();
    this.colorPicker.origin = { x: bbox.x, y: 0 };
    this.colorPicker.$container.offset({ left: this.colorPicker.origin.x, top: this.colorPicker.origin.y });
    this.colorPicker.$container.show();
  }

  setTrackName(name) {
    this.track.name = name;
    this.x.$label.text(name);
  }

  setColor(color) {
    this.y.tile = undefined;
    this.x.tile = undefined;
    this.track.color = color;
    this.repaintViews();
  }

  dataRange() {
    return this.track.dataRange ? this.track.dataRange : undefined;
  }

  setDataRange(min, max) {
    if (min !== undefined) {
      this.track.dataRange.min = min;
      this.track.config.min = min;
    }
    if (max !== undefined) {
      this.track.dataRange.max = max;
      this.track.config.max = max;
    }
    this.track.autoscale = false;
    this.track.config.autoScale = false;
    this.y.tile = undefined;
    this.x.tile = undefined;
    this.repaintViews();
  }

  appendRightHandGutter($parent) {
    let $div = $('<div class="hic-igv-right-hand-gutter">');
    $parent.append($div);
    this.createTrackGearPopup($div);
  }

  createTrackGearPopup($parent) {

    let $container = $("<div>", { class: 'igv-trackgear-container' });
    $parent.append($container);

    $container.append(createIcon$1('cog'));

    this.trackGearPopup = new MenuPopup($parent);
    this.trackGearPopup.$popover.hide();
    $container.click(e => {
      e.preventDefault;
      e.stopPropagation();
      this.trackGearPopup.presentMenuList(-(this.trackGearPopup.$popover.width()), 0, MenuUtils.trackMenuItemList(this));
    });
  }

  async updateViews() {

    if (this.updating) {
      this.pending = true;
    } else {
      try {
        this.updating = true;
        const genomicStateX = this.browser.genomicState(this.x.axis);
        let imageTileX = await this.getTileX(genomicStateX);
        if (imageTileX) {
          this.x.drawTile(imageTileX, genomicStateX);
        }

        const genomicStateY = this.browser.genomicState(this.y.axis);
        let imageTileY = await this.getTileY(genomicStateY);
        if (imageTileY) {
          this.y.drawTile(imageTileY, genomicStateY);
        }
      } finally {
        this.updating = false;
        if (this.pending) {
          this.pending = false;
          this.updateViews();
        }
      }
    }
  }

  /**
   * Repaint current tiles with cached features (due to color, scale, or other visual attribute change)
   * @returns {Promise<void>}
   */
  async repaintViews() {

    const genomicStateX = this.browser.genomicState(this.x.axis);
    if (this.tileX) {
      this.tileX = await this.createImageTile(genomicStateX, this.tileX.features);
      this.x.drawTile(this.tileX, genomicStateX);
    }

    const genomicStateY = this.browser.genomicState(this.y.axis);
    if (this.tileY) {
      this.tileY = await this.createImageTile(genomicStateX, this.tileY.features);
      this.y.drawTile(this.tileY, genomicStateY);
    }
  }

  async getTileX(genomicState) {
    const chrName = genomicState.chromosome.name;
    const bpPerPixel = genomicState.bpp;
    if (!(this.tileX && this.tileX.containsRange(chrName, genomicState.startBP, genomicState.endBP, bpPerPixel))) {
      this.tileX = await this.createImageTile(genomicState);
    }
    return this.tileX;
  }

  async getTileY(genomicState) {
    const chrName = genomicState.chromosome.name;
    const bpPerPixel = genomicState.bpp;
    if (this.tileX && this.tileX.containsRange(chrName, genomicState.startBP, genomicState.endBP, bpPerPixel)) {
      this.tileY = this.tileX;
    } else if (!(this.tileY && this.tileY.containsRange(chrName, genomicState.startBP, genomicState.endBP, bpPerPixel))) {
      this.tileY = await this.createImageTile(genomicState);
    }
    return this.tileY;
  }

  async createImageTile(genomicState, tileFeatures) {

    const chrName = genomicState.chromosome.name;
    const bpPerPixel = genomicState.bpp;

    if (bpPerPixel * Math.max(this.x.$canvas.width(), this.x.$canvas.height()) > this.track.visibilityWindow); else {

      // Expand the requested range so we can pan a bit without reloading
      const pixelWidth = 3 * this.x.$canvas.width();
      const lengthBP = Math.round(bpPerPixel * pixelWidth);
      const bpStart = Math.max(0, Math.round(genomicState.startBP - lengthBP / 3));
      const bpEnd = bpStart + lengthBP;

      const features = tileFeatures || await this.track.getFeatures(genomicState.chromosome.name, bpStart, bpEnd, bpPerPixel);

      const buffer = document.createElement('canvas');
      buffer.width = pixelWidth;
      buffer.height = this.x.$canvas.height();

      const context = buffer.getContext("2d");

      if (features) {
        const drawConfiguration =
        {
          features,
          context,
          pixelWidth,
          bpStart,
          bpEnd,
          bpPerPixel,
          genomicState,
          pixelHeight: Math.min(buffer.width, buffer.height),
          viewportContainerX: (genomicState.startBP - bpStart) / bpPerPixel,
          viewportContainerWidth: pixelWidth,
          viewportWidth: pixelWidth,
          referenceFrame: {}
        };

        if (this.track.autoscale || !this.track.dataRange) {
          if (typeof this.track.doAutoscale === 'function') {
            this.track.doAutoscale(features);
          } else {
            this.track.dataRange = doAutoscale(features);
          }
        }
        this.track.draw(drawConfiguration);


      } else {
        context.clearRect(0, 0, this.$canvas.width(), this.$canvas.height());
      }

      this.tile = new Tile(chrName, bpStart, bpEnd, bpPerPixel, buffer, features);
      return this.tile
    }
  }

  dispose() {
    this['x'].dispose();
    this['y'].dispose();
  }
}

class TrackRenderer {

  constructor(browser, size, $container, track, axis, order) {

    this.browser = browser;
    this.track = track;
    this.id = `trackRender_${guid()}`;
    this.axis = axis;
    this.init($container, size, order);

  }

  init($container, size, order) {

    var self = this;

    // track canvas container
    this.$viewport = ('x' === this.axis) ? $('<div class="x-track-canvas-container">') : $('<div class="y-track-canvas-container">');
    if (size.width) {
      this.$viewport.width(size.width);
    }
    if (size.height) {
      this.$viewport.height(size.height);
    }
    $container.append(this.$viewport);
    this.$viewport.css({ order: order });

    // canvas
    this.$canvas = $('<canvas>');
    this.$viewport.append(this.$canvas);
    this.ctx = this.$canvas.get(0).getContext("2d");

    if ('x' === this.axis) {
      // label
      this.$label = $('<div class="x-track-label">');
      const str = this.track.name || 'untitled';
      this.$label.text(str);
      this.$viewport.append(this.$label);
      if (true === self.browser.showTrackLabelAndGutter) {
        this.$label.show();
      } else {
        this.$label.hide();
      }

      this.$viewport.on('click', function (e) {

        e.preventDefault;
        e.stopPropagation();

        self.browser.toggleTrackLabelAndGutterState();
        if (true === self.browser.showTrackLabelAndGutter) {
          $('.x-track-label').show();
          $('.hic-igv-right-hand-gutter').show();
        } else {
          $('.x-track-label').hide();
          $('.hic-igv-right-hand-gutter').hide();
        }
      });
    }

    // track spinner container
    this.$spinner = ('x' === this.axis) ? $('<div class="x-track-spinner">') : $('<div class="y-track-spinner">');
    this.$viewport.append(this.$spinner);
    this.stopSpinner();

  }

  dispose($container, size, order) {
    this.tile = undefined;
    this.$viewport.remove();
  }


  syncCanvas() {
    this.$canvas.width(this.$viewport.width());
    this.$canvas.attr('width', this.$viewport.width());
    this.$canvas.height(this.$viewport.height());
    this.$canvas.attr('height', this.$viewport.height());
  }

  drawTile(tile, genomicState) {

    if (tile) {
      this.offsetPixel = Math.round((tile.startBP - genomicState.startBP) / genomicState.bpp);
      if ('x' === this.axis) {
        this.ctx.clearRect(0, 0, this.$canvas.width(), this.$canvas.height());
        this.ctx.drawImage(tile.buffer, this.offsetPixel, 0);
      } else {
        this.ctx.setTransform(0, 1, 1, 0, 0, 0);
        this.ctx.clearRect(0, 0, this.$canvas.height(), this.$canvas.width());
        this.ctx.drawImage(tile.buffer, this.offsetPixel, 0);
      }
    }
  }

  startSpinner() {
    this.browser.startSpinner();
  }

  stopSpinner() {
    this.browser.stopSpinner();
  }

  isLoading() {
    return !(undefined === this.loading);
  }

}

class Tile {

  constructor(chr, startBP, endBP, bpp, buffer, features) {
    this.chr = chr;
    this.startBP = startBP;
    this.endBP = endBP;
    this.bpp = bpp;
    this.buffer = buffer;
    this.features = features;
  }

  containsRange(chr, startBP, endBP, bpp) {
    return chr === this.chr && this.bpp === bpp && this.startBP <= startBP && this.endBP >= endBP;
  }
}

/**
* Created by dat on 4/4/17.
*/

// Keep in sync with juicebox.scss variables

// $nav-bar-label-height: 36px;
const nav_bar_label_height = 36;

// $nav-bar-widget-container-height: 36px;
const nav_bar_widget_container_height = 36;

// $nav-bar-widget-container-margin: 4px;
const nav_bar_widget_container_margin = 4;

// $hic-scrollbar-height: 20px;
const scrollbar_height = 20;

// $hic-axis-height: 40px;
const axis_height = 40;

// $track-margin: 2px;
const track_margin = 2;

const trackHeight = 40;

class LayoutController {

  constructor(browser, $root) {

    this.browser = browser;

    createNavBar(browser, $root);

    this.createAllContainers(browser, $root);
  }

  // 创建中间的canvas
  createAllContainers(browser, $root) {

    const html_x_track_container =
      `<div id="${browser.id}-x-track-container"><div id="${browser.id}-track-shim"></div><div id="${browser.id}-x-tracks"><div id="${browser.id}-y-track-guide" style="display: none;"></div></div></div>`;
    $root.append($(html_x_track_container));

    this.$x_track_container = $root.find("div[id$='x-track-container']");
    this.$track_shim = this.$x_track_container.find("div[id$='track-shim']");
    this.$x_tracks = this.$x_track_container.find("div[id$='x-tracks']");
    this.$y_track_guide = this.$x_track_container.find("div[id$='y-track-guide']");

    const html_content_container = `<div id="${browser.id}-content-container"></div>`;

    this.$content_container = $(html_content_container);

    $root.append(this.$content_container);

    const html_x_axis_container =
      `<div id="${browser.id}-x-axis-container">
          <div id="${browser.id}-x-axis">
              <canvas></canvas>
              <div id="${browser.id}-x-axis-whole-genome-container"></div>
          </div>
    </div>`;

    this.$content_container.append($(html_x_axis_container));

    const $x_axis_container = this.$content_container.find("div[id$='x-axis-container']");

    this.xAxisRuler = new Ruler(browser, $x_axis_container, 'x');

    const html_y_tracks_y_axis_viewport_y_scrollbar =
      `<div id="${browser.id}-y-tracks-y-axis-viewport-y-scrollbar">

          <div id="${browser.id}-y-tracks">
              <div id="${browser.id}-x-track-guide" style="display: none;"></div>
          </div>
          
          <div id="${browser.id}-y-axis">
        <canvas></canvas>
        <div id="${browser.id}-y-axis-whole-genome-container"></div>
      </div>
      
      </div>`;

    this.$content_container.append($(html_y_tracks_y_axis_viewport_y_scrollbar));
    const $y_tracks_y_axis_viewport_y_scrollbar = this.$content_container.find("div[id$='-y-tracks-y-axis-viewport-y-scrollbar']");

    this.$y_tracks = $y_tracks_y_axis_viewport_y_scrollbar.find("div[id$='-y-tracks']");
    this.$x_track_guide = this.$y_tracks.find("div[id$='-x-track-guide']");

    this.yAxisRuler = new Ruler(browser, $y_tracks_y_axis_viewport_y_scrollbar, 'y');

    this.xAxisRuler.$otherRulerCanvas = this.yAxisRuler.$canvas;
    this.xAxisRuler.otherRuler = this.yAxisRuler;

    this.yAxisRuler.$otherRulerCanvas = this.xAxisRuler.$canvas;
    this.yAxisRuler.otherRuler = this.xAxisRuler;

    const html_viewport =
      `<div id="${browser.id}-viewport">
    <canvas></canvas>
    <i class="fa fa-spinner fa-spin" style="font-size: 48px; position: absolute; left: 40%; top: 40%; display: none;"></i>
    <div id="${browser.id}-sweep-zoom-container" style="display: none;"></div>
    <div id="${browser.id}-x-guide" style="display: none;"></div>
    <div id="${browser.id}-y-guide" style="display: none;"></div>
  </div>`;

    $y_tracks_y_axis_viewport_y_scrollbar.append($(html_viewport));

    const html_y_axis_scrollbar_container =
      `<div style="display:none !important" id="${browser.id}-y-axis-scrollbar-container">
    <div id="${browser.id}-y-axis-scrollbar">
      <div class="scrollbar-label-rotation-in-place"></div>
    </div>
  </div>`;

    $y_tracks_y_axis_viewport_y_scrollbar.append($(html_y_axis_scrollbar_container));

    const html_x_axis_scrollbar_container =
      `<div style="display:none" id="${browser.id}-x-scrollbar-container">
          <div id="${browser.id}-x-axis-scrollbar-container">
              <div id="${browser.id}-x-axis-scrollbar">
                  <div></div>
              </div>
          </div>
    </div>`;

    this.$content_container.append($(html_x_axis_scrollbar_container));

  }

  getContactMatrixViewport() {
    const $parent = this.$content_container.find("div[id$='-y-tracks-y-axis-viewport-y-scrollbar']");
    return $parent.find("div[id$='-viewport']");
  }

  getYAxisScrollbarContainer() {
    const $parent = this.$content_container.find("div[id$='-y-tracks-y-axis-viewport-y-scrollbar']");
    return $parent.find("div[id$='-y-axis-scrollbar-container']");
  }

  getXAxisScrollbarContainer() {
    return this.$content_container.find("div[id$='-x-axis-scrollbar-container']");
  }

  tracksLoaded(tracks) {

    this.doLayoutTrackXYPairCount(tracks.length + this.browser.trackPairs.length);

    tracks.forEach((track, index) => {
      const trackPair = new TrackPair(
        this.browser,
        trackHeight,
        this.$x_tracks,
        this.$y_tracks,
        track,
        index
      );
      this.browser.trackPairs.push(trackPair);
    });
  }

  removeAllTrackXYPairs() {

    if (this.browser.trackPairs.length === 0) {
      return;
    }

    for (let trackPair of this.browser.trackPairs) {
      // discard DOM element's
      trackPair.dispose();
    }
    this.browser.trackPairs = [];
    this.browser.updateLayout();
    this.doLayoutTrackXYPairCount(0);

    // What ???
    // [...Array(this.browser.trackPairs.length).keys()].forEach(() => {
    //
    //     // select last track to discard
    //     let discard = this.browser.trackPairs[this.browser.trackPairs.length - 1];
    //
    //     // discard DOM element's
    //     discard['x'].$viewport.remove();
    //     discard['y'].$viewport.remove();
    //
    //     // remove discard from list
    //     const index = this.browser.trackPairs.indexOf(discard);
    //     this.browser.trackPairs.splice(index, 1);
    //
    //     discard = undefined;
    //     this.doLayoutTrackXYPairCount(this.browser.trackPairs.length);
    //
    // });
  };

  removeLastTrackXYPair() {

    if (this.browser.trackPairs.length > 0) {

      // select last track to dicard
      let discard = this.browser.trackPairs[this.browser.trackPairs.length - 1];

      // discard DOM element's
      discard['x'].$viewport.remove();
      discard['y'].$viewport.remove();

      // remove discard from list
      const index = this.browser.trackPairs.indexOf(discard);
      this.browser.trackPairs.splice(index, 1);

      discard = undefined;
      this.doLayoutTrackXYPairCount(this.browser.trackPairs.length);

      this.browser.updateLayout();

    }
  }

  removeTrackXYPair(trackXYPair) {

    if (this.browser.trackPairs.length > 0) {

      const discard = trackXYPair;

      // discard DOM element's
      discard['x'].$viewport.remove();
      discard['y'].$viewport.remove();

      // remove discard from list
      const index = this.browser.trackPairs.indexOf(discard);
      this.browser.trackPairs.splice(index, 1);

      this.doLayoutTrackXYPairCount(this.browser.trackPairs.length);

      this.browser.updateLayout();


    }

  };

  doLayoutTrackXYPairCount(trackXYPairCount) {


    const track_aggregate_height = (0 === trackXYPairCount) ? 0 : trackXYPairCount * (trackHeight + track_margin);

    let tokens = [getNavbarHeight(), track_aggregate_height].map(number => `${number}px`);
    const height_calc = 'calc(100% - (' + tokens.join(' + ') + '))';

    tokens = [track_aggregate_height, axis_height, scrollbar_height].map(number => `${number}px`);
    const width_calc = 'calc(100% - (' + tokens.join(' + ') + '))';

    // x-track container
    this.$x_track_container.height(track_aggregate_height);

    // track labels
    this.$track_shim.width(track_aggregate_height);

    // x-tracks
    this.$x_tracks.css('width', width_calc);


    // content container
    this.$content_container.css('height', height_calc);

    // x-axis - repaint canvas
    this.xAxisRuler.updateWidthWithCalculation(width_calc);

    // y-tracks
    this.$y_tracks.width(track_aggregate_height);

    // y-axis - repaint canvas
    this.yAxisRuler.updateHeight(this.yAxisRuler.$axis.height());

    // viewport
    this.browser.contactMatrixView.$viewport.css('width', width_calc);

    // x-scrollbar
    this.browser.contactMatrixView.scrollbarWidget.$x_axis_scrollbar_container.css('width', width_calc);

  }

  doLayoutWithRootContainerSize(size) {

    this.browser.$root.width(size.width);
    this.browser.$root.height(size.height + getNavbarHeight());

    const count = this.browser.trackPairs.length > 0 ? this.browser.trackPairs.length : 0;
    this.doLayoutTrackXYPairCount(count);

    this.browser.updateLayout();
  }
}

const getNavbarHeight = () => 2 * (nav_bar_label_height + nav_bar_widget_container_height + (2 * nav_bar_widget_container_margin));

const getNavbarContainer = browser => browser.$root.find('.hic-navbar-container');

function createNavBar(browser, $root) {

  const $hic_navbar_container = $('<div>', { class: 'hic-navbar-container' });
  $root.append($hic_navbar_container);

  // 选中的浏览器
  $root.on('click', e => {
    e.stopPropagation();
    e.preventDefault;
    setCurrentBrowser(browser);
    // 确定是否有canvas
    let _id = browser.id
    if ($(`#glass_canvas_${_id}`).length > 0) {
      $('#ROI').addClass('active');
    } else {
      $('#ROI').removeClass('active');
    }
  });

  const html_contact_map_hic_nav_bar_map_container =
    `<div id="${browser.id}-contact-map-hic-nav-bar-map-container">
          <div id="${browser.id}-contact-map-hic-nav-bar-map-label">
          </div>
           <div class="hic-nav-bar-button-container">
              <span id ='sync_browser_${browser.id}' class="sync-close" title="Sync Browser"></span>
              <span class="present-menu" title="Present menu"></span>
              <span class="delete-browser-panel" title="Delete browser panel" style="display: none;"></span>
           </div>
      </div>`;

  $hic_navbar_container.append($(html_contact_map_hic_nav_bar_map_container));

  browser.$contactMaplabel = $hic_navbar_container.find("div[id$='contact-map-hic-nav-bar-map-label']");


  browser.$menuPresentDismiss = $hic_navbar_container.find('.present-menu');
  browser.$menuPresentDismiss.on('click', e => browser.toggleMenu());

  browser.$browser_panel_delete_button = $hic_navbar_container.find('.delete-browser-panel');
  browser.$browser_panel_delete_button.on('click', e => deleteBrowser(browser));

  browser.$syncBrowser = $hic_navbar_container.find(`#sync_browser_${browser.id}`);
  browser.$syncBrowser.on('click', e => {
    if (browser.dataset === undefined) return;
    // 开启同步
    if (browser.$syncBrowser.hasClass('sync-close')) {
      browser.isSync = true;
      let allbrowsers = getAllBrowsers();
      for (let a of allbrowsers) {
        if (a === browser || a.isSync === false) continue;
        syncBrowsers(a, browser);
      }
      browser.$syncBrowser.removeClass('sync-close')
      browser.$syncBrowser.addClass('sync-open')
    }
    // 关闭同步
    else {
      browser.$syncBrowser.removeClass('sync-open')
      browser.$syncBrowser.addClass('sync-close')
      browser.isSync = false;
      browser.synchedBrowsers = []
      let allbrowsers = getAllBrowsers();
      for (let a of allbrowsers) {
        if (a === browser) continue;
        unsyncBrowsers(a, browser);
      }
    }
  });

  // Delete button is only vidible if there is more then one browser
  browser.$browser_panel_delete_button.hide();

  // const html_control_map_hic_nav_bar_map_container =
  //     `<div id="${browser.id}-control-map-hic-nav-bar-map-container">
  //         <div id="${browser.id}-control-map-hic-nav-bar-map-label"></div>
  //     </div>`;

  // $hic_navbar_container.append($(html_control_map_hic_nav_bar_map_container));

  browser.$controlMaplabel = $hic_navbar_container.find("div[id$='control-map-hic-nav-bar-map-label']");

  const html_upper_hic_nav_bar_widget_container = `<div id="${browser.id}-upper-hic-nav-bar-widget-container"></div>`;
  $hic_navbar_container.append($(html_upper_hic_nav_bar_widget_container));

  const html_lower_hic_nav_bar_widget_container = `<div id="${browser.id}-lower-hic-nav-bar-widget-container"></div>`;
  $hic_navbar_container.append($(html_lower_hic_nav_bar_widget_container));

}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/


function HICEvent(type, data, propogate) {
  return {
    type: type,
    data: data || {},
    propogate: propogate !== undefined ? propogate : true     // Default to true
  }
}

// from https://github.com/imaya/zlib.js

var Zlib = {
  Huffman: {},
  Util: {},
  CRC32: {}
};


/**
* Compression Method
* @enum {number}
*/
Zlib.CompressionMethod = {
  DEFLATE: 8,
  RESERVED: 15
};




/**
* @param {Object=} opt_params options.
* @constructor
*/
Zlib.Zip = function (opt_params) {
  opt_params = opt_params || {};
  /** @type {Array.<{
   *   buffer: !(Array.<number>|Uint8Array),
   *   option: Object,
   *   compressed: boolean,
   *   encrypted: boolean,
   *   size: number,
   *   crc32: number
   * }>} */
  this.files = [];
  /** @type {(Array.<number>|Uint8Array)} */
  this.comment = opt_params['comment'];
  /** @type {(Array.<number>|Uint8Array)} */
  this.password;
};


/**
* @enum {number}
*/
Zlib.Zip.CompressionMethod = {
  STORE: 0,
  DEFLATE: 8
};

/**
* @enum {number}
*/
Zlib.Zip.OperatingSystem = {
  MSDOS: 0,
  UNIX: 3,
  MACINTOSH: 7
};

/**
* @enum {number}
*/
Zlib.Zip.Flags = {
  ENCRYPT: 0x0001,
  DESCRIPTOR: 0x0008,
  UTF8: 0x0800
};

/**
* @type {Array.<number>}
* @const
*/
Zlib.Zip.FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];

/**
* @type {Array.<number>}
* @const
*/
Zlib.Zip.LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];

/**
* @type {Array.<number>}
* @const
*/
Zlib.Zip.CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];

/**
* @param {Array.<number>|Uint8Array} input
* @param {Object=} opt_params options.
*/
Zlib.Zip.prototype.addFile = function (input, opt_params) {
  opt_params = opt_params || {};
  /** @type {string} */
  opt_params['filename'];
  /** @type {boolean} */
  var compressed;
  /** @type {number} */
  var size = input.length;
  /** @type {number} */
  var crc32 = 0;

  if (input instanceof Array) {
    input = new Uint8Array(input);
  }

  // default
  if (typeof opt_params['compressionMethod'] !== 'number') {
    opt_params['compressionMethod'] = Zlib.Zip.CompressionMethod.DEFLATE;
  }

  // その場で圧縮する場合
  if (opt_params['compress']) {
    switch (opt_params['compressionMethod']) {
      case Zlib.Zip.CompressionMethod.STORE:
        break;
      case Zlib.Zip.CompressionMethod.DEFLATE:
        crc32 = Zlib.CRC32.calc(input);
        input = this.deflateWithOption(input, opt_params);
        compressed = true;
        break;
      default:
        throw new Error('unknown compression method:' + opt_params['compressionMethod']);
    }
  }

  this.files.push({
    buffer: input,
    option: opt_params,
    compressed: compressed,
    encrypted: false,
    size: size,
    crc32: crc32
  });
};

/**
* @param {(Array.<number>|Uint8Array)} password
*/
Zlib.Zip.prototype.setPassword = function (password) {
  this.password = password;
};

Zlib.Zip.prototype.compress = function () {
  /** @type {Array.<{
   *   buffer: !(Array.<number>|Uint8Array),
   *   option: Object,
   *   compressed: boolean,
   *   encrypted: boolean,
   *   size: number,
   *   crc32: number
   * }>} */
  var files = this.files;
  /** @type {{
   *   buffer: !(Array.<number>|Uint8Array),
   *   option: Object,
   *   compressed: boolean,
   *   encrypted: boolean,
   *   size: number,
   *   crc32: number
   * }} */
  var file;
  /** @type {!(Array.<number>|Uint8Array)} */
  var output;
  /** @type {number} */
  var op1;
  /** @type {number} */
  var op2;
  /** @type {number} */
  var op3;
  /** @type {number} */
  var localFileSize = 0;
  /** @type {number} */
  var centralDirectorySize = 0;
  /** @type {number} */
  var endOfCentralDirectorySize;
  /** @type {number} */
  var offset;
  /** @type {number} */
  var needVersion;
  /** @type {number} */
  var flags;
  /** @type {Zlib.Zip.CompressionMethod} */
  var compressionMethod;
  /** @type {Date} */
  var date;
  /** @type {number} */
  var crc32;
  /** @type {number} */
  var size;
  /** @type {number} */
  var plainSize;
  /** @type {number} */
  var filenameLength;
  /** @type {number} */
  var extraFieldLength;
  /** @type {number} */
  var commentLength;
  /** @type {(Array.<number>|Uint8Array)} */
  var filename;
  /** @type {(Array.<number>|Uint8Array)} */
  var extraField;
  /** @type {(Array.<number>|Uint8Array)} */
  var comment;
  /** @type {(Array.<number>|Uint8Array)} */
  var buffer;
  /** @type {*} */
  var tmp;
  /** @type {Array.<number>|Uint32Array|Object} */
  var key;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;
  /** @type {number} */
  var j;
  /** @type {number} */
  var jl;

  // ファイルの圧縮
  for (i = 0, il = files.length; i < il; ++i) {
    file = files[i];
    filenameLength =
      (file.option['filename']) ? file.option['filename'].length : 0;
    extraFieldLength =
      (file.option['extraField']) ? file.option['extraField'].length : 0;
    commentLength =
      (file.option['comment']) ? file.option['comment'].length : 0;

    // 圧縮されていなかったら圧縮
    if (!file.compressed) {
      // 圧縮前に CRC32 の計算をしておく
      file.crc32 = Zlib.CRC32.calc(file.buffer);

      switch (file.option['compressionMethod']) {
        case Zlib.Zip.CompressionMethod.STORE:
          break;
        case Zlib.Zip.CompressionMethod.DEFLATE:
          file.buffer = this.deflateWithOption(file.buffer, file.option);
          file.compressed = true;
          break;
        default:
          throw new Error('unknown compression method:' + file.option['compressionMethod']);
      }
    }

    // encryption
    if (file.option['password'] !== void 0 || this.password !== void 0) {
      // init encryption
      key = this.createEncryptionKey(file.option['password'] || this.password);

      // add header
      buffer = file.buffer;
      {
        tmp = new Uint8Array(buffer.length + 12);
        tmp.set(buffer, 12);
        buffer = tmp;
      }

      for (j = 0; j < 12; ++j) {
        buffer[j] = this.encode(
          key,
          i === 11 ? (file.crc32 & 0xff) : (Math.random() * 256 | 0)
        );
      }

      // data encryption
      for (jl = buffer.length; j < jl; ++j) {
        buffer[j] = this.encode(key, buffer[j]);
      }
      file.buffer = buffer;
    }

    // 必要バッファサイズの計算
    localFileSize +=
      // local file header
      30 + filenameLength +
      // file data
      file.buffer.length;

    centralDirectorySize +=
      // file header
      46 + filenameLength + commentLength;
  }

  // end of central directory
  endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);
  output = new (Uint8Array)(
    localFileSize + centralDirectorySize + endOfCentralDirectorySize
  );
  op1 = 0;
  op2 = localFileSize;
  op3 = op2 + centralDirectorySize;

  // ファイルの圧縮
  for (i = 0, il = files.length; i < il; ++i) {
    file = files[i];
    filenameLength =
      file.option['filename'] ? file.option['filename'].length : 0;
    extraFieldLength = 0; // TODO
    commentLength =
      file.option['comment'] ? file.option['comment'].length : 0;

    //-------------------------------------------------------------------------
    // local file header & file header
    //-------------------------------------------------------------------------

    offset = op1;

    // signature
    // local file header
    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[0];
    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[1];
    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[2];
    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[3];
    // file header
    output[op2++] = Zlib.Zip.FileHeaderSignature[0];
    output[op2++] = Zlib.Zip.FileHeaderSignature[1];
    output[op2++] = Zlib.Zip.FileHeaderSignature[2];
    output[op2++] = Zlib.Zip.FileHeaderSignature[3];

    // compressor info
    needVersion = 20;
    output[op2++] = needVersion & 0xff;
    output[op2++] =
      /** @type {Zlib.Zip.OperatingSystem} */
      (file.option['os']) ||
      Zlib.Zip.OperatingSystem.MSDOS;

    // need version
    output[op1++] = output[op2++] = needVersion & 0xff;
    output[op1++] = output[op2++] = (needVersion >> 8) & 0xff;

    // general purpose bit flag
    flags = 0;
    if (file.option['password'] || this.password) {
      flags |= Zlib.Zip.Flags.ENCRYPT;
    }
    output[op1++] = output[op2++] = flags & 0xff;
    output[op1++] = output[op2++] = (flags >> 8) & 0xff;

    // compression method
    compressionMethod =
      /** @type {Zlib.Zip.CompressionMethod} */
      (file.option['compressionMethod']);
    output[op1++] = output[op2++] = compressionMethod & 0xff;
    output[op1++] = output[op2++] = (compressionMethod >> 8) & 0xff;

    // date
    date = /** @type {(Date|undefined)} */(file.option['date']) || new Date();
    output[op1++] = output[op2++] =
      ((date.getMinutes() & 0x7) << 5) |
      (date.getSeconds() / 2 | 0);
    output[op1++] = output[op2++] =
      (date.getHours() << 3) |
      (date.getMinutes() >> 3);
    //
    output[op1++] = output[op2++] =
      ((date.getMonth() + 1 & 0x7) << 5) |
      (date.getDate());
    output[op1++] = output[op2++] =
      ((date.getFullYear() - 1980 & 0x7f) << 1) |
      (date.getMonth() + 1 >> 3);

    // CRC-32
    crc32 = file.crc32;
    output[op1++] = output[op2++] = crc32 & 0xff;
    output[op1++] = output[op2++] = (crc32 >> 8) & 0xff;
    output[op1++] = output[op2++] = (crc32 >> 16) & 0xff;
    output[op1++] = output[op2++] = (crc32 >> 24) & 0xff;

    // compressed size
    size = file.buffer.length;
    output[op1++] = output[op2++] = size & 0xff;
    output[op1++] = output[op2++] = (size >> 8) & 0xff;
    output[op1++] = output[op2++] = (size >> 16) & 0xff;
    output[op1++] = output[op2++] = (size >> 24) & 0xff;

    // uncompressed size
    plainSize = file.size;
    output[op1++] = output[op2++] = plainSize & 0xff;
    output[op1++] = output[op2++] = (plainSize >> 8) & 0xff;
    output[op1++] = output[op2++] = (plainSize >> 16) & 0xff;
    output[op1++] = output[op2++] = (plainSize >> 24) & 0xff;

    // filename length
    output[op1++] = output[op2++] = filenameLength & 0xff;
    output[op1++] = output[op2++] = (filenameLength >> 8) & 0xff;

    // extra field length
    output[op1++] = output[op2++] = extraFieldLength & 0xff;
    output[op1++] = output[op2++] = (extraFieldLength >> 8) & 0xff;

    // file comment length
    output[op2++] = commentLength & 0xff;
    output[op2++] = (commentLength >> 8) & 0xff;

    // disk number start
    output[op2++] = 0;
    output[op2++] = 0;

    // internal file attributes
    output[op2++] = 0;
    output[op2++] = 0;

    // external file attributes
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;

    // relative offset of local header
    output[op2++] = offset & 0xff;
    output[op2++] = (offset >> 8) & 0xff;
    output[op2++] = (offset >> 16) & 0xff;
    output[op2++] = (offset >> 24) & 0xff;

    // filename
    filename = file.option['filename'];
    if (filename) {
      {
        output.set(filename, op1);
        output.set(filename, op2);
        op1 += filenameLength;
        op2 += filenameLength;
      }
    }

    // extra field
    extraField = file.option['extraField'];
    if (extraField) {
      {
        output.set(extraField, op1);
        output.set(extraField, op2);
        op1 += extraFieldLength;
        op2 += extraFieldLength;
      }
    }

    // comment
    comment = file.option['comment'];
    if (comment) {
      {
        output.set(comment, op2);
        op2 += commentLength;
      }
    }

    //-------------------------------------------------------------------------
    // file data
    //-------------------------------------------------------------------------

    {
      output.set(file.buffer, op1);
      op1 += file.buffer.length;
    }
  }

  //-------------------------------------------------------------------------
  // end of central directory
  //-------------------------------------------------------------------------

  // signature
  output[op3++] = Zlib.Zip.CentralDirectorySignature[0];
  output[op3++] = Zlib.Zip.CentralDirectorySignature[1];
  output[op3++] = Zlib.Zip.CentralDirectorySignature[2];
  output[op3++] = Zlib.Zip.CentralDirectorySignature[3];

  // number of this disk
  output[op3++] = 0;
  output[op3++] = 0;

  // number of the disk with the start of the central directory
  output[op3++] = 0;
  output[op3++] = 0;

  // total number of entries in the central directory on this disk
  output[op3++] = il & 0xff;
  output[op3++] = (il >> 8) & 0xff;

  // total number of entries in the central directory
  output[op3++] = il & 0xff;
  output[op3++] = (il >> 8) & 0xff;

  // size of the central directory
  output[op3++] = centralDirectorySize & 0xff;
  output[op3++] = (centralDirectorySize >> 8) & 0xff;
  output[op3++] = (centralDirectorySize >> 16) & 0xff;
  output[op3++] = (centralDirectorySize >> 24) & 0xff;

  // offset of start of central directory with respect to the starting disk number
  output[op3++] = localFileSize & 0xff;
  output[op3++] = (localFileSize >> 8) & 0xff;
  output[op3++] = (localFileSize >> 16) & 0xff;
  output[op3++] = (localFileSize >> 24) & 0xff;

  // .ZIP file comment length
  commentLength = this.comment ? this.comment.length : 0;
  output[op3++] = commentLength & 0xff;
  output[op3++] = (commentLength >> 8) & 0xff;

  // .ZIP file comment
  if (this.comment) {
    {
      output.set(this.comment, op3);
      op3 += commentLength;
    }
  }

  return output;
};

/**
* @param {!(Array.<number>|Uint8Array)} input
* @param {Object=} opt_params options.
* @return {!(Array.<number>|Uint8Array)}
*/
Zlib.Zip.prototype.deflateWithOption = function (input, opt_params) {
  /** @type {Zlib.RawDeflate} */
  var deflator = new Zlib.RawDeflate(input, opt_params['deflateOption']);

  return deflator.compress();
};

/**
* @param {(Array.<number>|Uint32Array)} key
* @return {number}
*/
Zlib.Zip.prototype.getByte = function (key) {
  /** @type {number} */
  var tmp = ((key[2] & 0xffff) | 2);

  return ((tmp * (tmp ^ 1)) >> 8) & 0xff;
};

/**
* @param {(Array.<number>|Uint32Array|Object)} key
* @param {number} n
* @return {number}
*/
Zlib.Zip.prototype.encode = function (key, n) {
  /** @type {number} */
  var tmp = this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));

  this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);

  return tmp ^ n;
};

/**
* @param {(Array.<number>|Uint32Array)} key
* @param {number} n
*/
Zlib.Zip.prototype.updateKeys = function (key, n) {
  key[0] = Zlib.CRC32.single(key[0], n);
  key[1] =
    (((((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681) >>> 0) + 1) >>> 0;
  key[2] = Zlib.CRC32.single(key[2], key[1] >>> 24);
};

/**
* @param {(Array.<number>|Uint8Array)} password
* @return {!(Array.<number>|Uint32Array|Object)}
*/
Zlib.Zip.prototype.createEncryptionKey = function (password) {
  /** @type {!(Array.<number>|Uint32Array)} */
  var key = [305419896, 591751049, 878082192];
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  {
    key = new Uint32Array(key);
  }

  for (i = 0, il = password.length; i < il; ++i) {
    this.updateKeys(key, password[i] & 0xff);
  }

  return key;
};



/**
* build huffman table from length list.
* @param {!(Array.<number>|Uint8Array)} lengths length list.
* @return {!Array} huffman table.
*/
Zlib.Huffman.buildHuffmanTable = function (lengths) {
  /** @type {number} length list size. */
  var listSize = lengths.length;
  /** @type {number} max code length for table size. */
  var maxCodeLength = 0;
  /** @type {number} min code length for table size. */
  var minCodeLength = Number.POSITIVE_INFINITY;
  /** @type {number} table size. */
  var size;
  /** @type {!(Array|Uint8Array)} huffman code table. */
  var table;
  /** @type {number} bit length. */
  var bitLength;
  /** @type {number} huffman code. */
  var code;
  /**
   * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.
   * @type {number} skip length for table filling.
   */
  var skip;
  /** @type {number} reversed code. */
  var reversed;
  /** @type {number} reverse temp. */
  var rtemp;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limit. */
  var il;
  /** @type {number} loop counter. */
  var j;
  /** @type {number} table value. */
  var value;

  // Math.max は遅いので最長の値は for-loop で取得する
  for (i = 0, il = listSize; i < il; ++i) {
    if (lengths[i] > maxCodeLength) {
      maxCodeLength = lengths[i];
    }
    if (lengths[i] < minCodeLength) {
      minCodeLength = lengths[i];
    }
  }

  size = 1 << maxCodeLength;
  table = new (Uint32Array)(size);

  // ビット長の短い順からハフマン符号を割り当てる
  for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {
    for (i = 0; i < listSize; ++i) {
      if (lengths[i] === bitLength) {
        // ビットオーダーが逆になるためビット長分並びを反転する
        for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {
          reversed = (reversed << 1) | (rtemp & 1);
          rtemp >>= 1;
        }

        // 最大ビット長をもとにテーブルを作るため、
        // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる
        // そのどちらでも良い場所は同じ値で埋めることで
        // 本来のビット長以上のビット数取得しても問題が起こらないようにする
        value = (bitLength << 16) | i;
        for (j = reversed; j < size; j += skip) {
          table[j] = value;
        }

        ++code;
      }
    }

    // 次のビット長へ
    ++bitLength;
    code <<= 1;
    skip <<= 1;
  }

  return [table, maxCodeLength, minCodeLength];
};




//-----------------------------------------------------------------------------

/** @define {number} buffer block size. */
var ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]

//-----------------------------------------------------------------------------


var buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;

/**
* @constructor
* @param {!(Uint8Array|Array.<number>)} input input buffer.
* @param {Object} opt_params option parameter.
*
* opt_params は以下のプロパティを指定する事ができます。
*   - index: input buffer の deflate コンテナの開始位置.
*   - blockSize: バッファのブロックサイズ.
*   - bufferType: Zlib.RawInflate.BufferType の値によってバッファの管理方法を指定する.
*   - resize: 確保したバッファが実際の大きさより大きかった場合に切り詰める.
*/
Zlib.RawInflate = function (input, opt_params) {
  /** @type {!(Array.<number>|Uint8Array)} inflated buffer */
  this.buffer;
  /** @type {!Array.<(Array.<number>|Uint8Array)>} */
  this.blocks = [];
  /** @type {number} block size. */
  this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;
  /** @type {!number} total output buffer pointer. */
  this.totalpos = 0;
  /** @type {!number} input buffer pointer. */
  this.ip = 0;
  /** @type {!number} bit stream reader buffer. */
  this.bitsbuf = 0;
  /** @type {!number} bit stream reader buffer size. */
  this.bitsbuflen = 0;
  /** @type {!(Array.<number>|Uint8Array)} input buffer. */
  this.input = new Uint8Array(input);
  /** @type {!(Uint8Array|Array.<number>)} output buffer. */
  this.output;
  /** @type {!number} output buffer pointer. */
  this.op;
  /** @type {boolean} is final block flag. */
  this.bfinal = false;
  /** @type {Zlib.RawInflate.BufferType} buffer management. */
  this.bufferType = Zlib.RawInflate.BufferType.ADAPTIVE;
  /** @type {boolean} resize flag for memory size optimization. */
  this.resize = false;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (opt_params['index']) {
      this.ip = opt_params['index'];
    }
    if (opt_params['bufferSize']) {
      this.bufferSize = opt_params['bufferSize'];
    }
    if (opt_params['bufferType']) {
      this.bufferType = opt_params['bufferType'];
    }
    if (opt_params['resize']) {
      this.resize = opt_params['resize'];
    }
  }

  // initialize
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.BLOCK:
      this.op = Zlib.RawInflate.MaxBackwardLength;
      this.output =
        new (Uint8Array)(
          Zlib.RawInflate.MaxBackwardLength +
          this.bufferSize +
          Zlib.RawInflate.MaxCopyLength
        );
      break;
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      this.op = 0;
      this.output = new (Uint8Array)(this.bufferSize);
      break;
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
* @enum {number}
*/
Zlib.RawInflate.BufferType = {
  BLOCK: 0,
  ADAPTIVE: 1
};

/**
* decompress.
* @return {!(Uint8Array|Array.<number>)} inflated buffer.
*/
Zlib.RawInflate.prototype.decompress = function () {
  while (!this.bfinal) {
    this.parseBlock();
  }

  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.BLOCK:
      return this.concatBufferBlock();
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      return this.concatBufferDynamic();
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
* @const
* @type {number} max backward length for LZ77.
*/
Zlib.RawInflate.MaxBackwardLength = 32768;

/**
* @const
* @type {number} max copy length for LZ77.
*/
Zlib.RawInflate.MaxCopyLength = 258;

/**
* huffman order
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib.RawInflate.Order = (function (table) {
  return new Uint16Array(table);
})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

/**
* huffman length code table.
* @const
* @type {!(Array.<number>|Uint16Array)}
*/
Zlib.RawInflate.LengthCodeTable = (function (table) {
  return new Uint16Array(table);
})([
  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,
  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,
  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,
  0x00e3, 0x0102, 0x0102, 0x0102
]);

/**
* huffman length extra-bits table.
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib.RawInflate.LengthExtraTable = (function (table) {
  return new Uint8Array(table);
})([
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 5, 0, 0, 0
]);

/**
* huffman dist code table.
* @const
* @type {!(Array.<number>|Uint16Array)}
*/
Zlib.RawInflate.DistCodeTable = (function (table) {
  return new Uint16Array(table);
})([
  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,
  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,
  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,
  0x3001, 0x4001, 0x6001
]);

/**
* huffman dist extra-bits table.
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib.RawInflate.DistExtraTable = (function (table) {
  return new Uint8Array(table);
})([
  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
  11, 12, 12, 13, 13
]);

/**
* fixed huffman length code table
* @const
* @type {!Array}
*/
Zlib.RawInflate.FixedLiteralLengthTable = (function (table) {
  return table;
})((function () {
  var lengths = new (Uint8Array)(288);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] =
      (i <= 143) ? 8 :
        (i <= 255) ? 9 :
          (i <= 279) ? 7 :
            8;
  }

  return buildHuffmanTable(lengths);
})());

/**
* fixed huffman distance code table
* @const
* @type {!Array}
*/
Zlib.RawInflate.FixedDistanceTable = (function (table) {
  return table;
})((function () {
  var lengths = new (Uint8Array)(30);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = 5;
  }

  return buildHuffmanTable(lengths);
})());

/**
* parse deflated block.
*/
Zlib.RawInflate.prototype.parseBlock = function () {
  /** @type {number} header */
  var hdr = this.readBits(3);

  // BFINAL
  if (hdr & 0x1) {
    this.bfinal = true;
  }

  // BTYPE
  hdr >>>= 1;
  switch (hdr) {
    // uncompressed
    case 0:
      this.parseUncompressedBlock();
      break;
    // fixed huffman
    case 1:
      this.parseFixedHuffmanBlock();
      break;
    // dynamic huffman
    case 2:
      this.parseDynamicHuffmanBlock();
      break;
    // reserved or other
    default:
      throw new Error('unknown BTYPE: ' + hdr);
  }
};

/**
* read inflate bits
* @param {number} length bits length.
* @return {number} read bits.
*/
Zlib.RawInflate.prototype.readBits = function (length) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} */
  var inputLength = input.length;
  /** @type {number} input and output byte. */
  var octet;

  // input byte
  if (ip + ((length - bitsbuflen + 7) >> 3) >= inputLength) {
    throw new Error('input buffer is broken');
  }

  // not enough buffer
  while (bitsbuflen < length) {
    bitsbuf |= input[ip++] << bitsbuflen;
    bitsbuflen += 8;
  }

  // output byte
  octet = bitsbuf & /* MASK */ ((1 << length) - 1);
  bitsbuf >>>= length;
  bitsbuflen -= length;

  this.bitsbuf = bitsbuf;
  this.bitsbuflen = bitsbuflen;
  this.ip = ip;

  return octet;
};

/**
* read huffman code using table
* @param {!(Array.<number>|Uint8Array|Uint16Array)} table huffman code table.
* @return {number} huffman code.
*/
Zlib.RawInflate.prototype.readCodeByTable = function (table) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} */
  var inputLength = input.length;
  /** @type {!(Array.<number>|Uint8Array)} huffman code table */
  var codeTable = table[0];
  /** @type {number} */
  var maxCodeLength = table[1];
  /** @type {number} code length & code (16bit, 16bit) */
  var codeWithLength;
  /** @type {number} code bits length */
  var codeLength;

  // not enough buffer
  while (bitsbuflen < maxCodeLength) {
    if (ip >= inputLength) {
      break;
    }
    bitsbuf |= input[ip++] << bitsbuflen;
    bitsbuflen += 8;
  }

  // read max length
  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];
  codeLength = codeWithLength >>> 16;

  if (codeLength > bitsbuflen) {
    throw new Error('invalid code length: ' + codeLength);
  }

  this.bitsbuf = bitsbuf >> codeLength;
  this.bitsbuflen = bitsbuflen - codeLength;
  this.ip = ip;

  return codeWithLength & 0xffff;
};

/**
* parse uncompressed block.
*/
Zlib.RawInflate.prototype.parseUncompressedBlock = function () {
  var input = this.input;
  var ip = this.ip;
  var output = this.output;
  var op = this.op;

  /** @type {number} */
  var inputLength = input.length;
  /** @type {number} block length */
  var len;
  /** @type {number} number for check block length */
  var nlen;
  /** @type {number} output buffer length */
  var olength = output.length;
  /** @type {number} copy counter */
  var preCopy;

  // skip buffered header bits
  this.bitsbuf = 0;
  this.bitsbuflen = 0;

  // len
  if (ip + 1 >= inputLength) {
    throw new Error('invalid uncompressed block header: LEN');
  }
  len = input[ip++] | (input[ip++] << 8);

  // nlen
  if (ip + 1 >= inputLength) {
    throw new Error('invalid uncompressed block header: NLEN');
  }
  nlen = input[ip++] | (input[ip++] << 8);

  // check len & nlen
  if (len === ~nlen) {
    throw new Error('invalid uncompressed block header: length verify');
  }

  // check size
  if (ip + len > input.length) { throw new Error('input buffer is broken'); }

  // expand buffer
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.BLOCK:
      // pre copy
      while (op + len > output.length) {
        preCopy = olength - op;
        len -= preCopy;
        {
          output.set(input.subarray(ip, ip + preCopy), op);
          op += preCopy;
          ip += preCopy;
        }
        this.op = op;
        output = this.expandBufferBlock();
        op = this.op;
      }
      break;
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      while (op + len > output.length) {
        output = this.expandBufferAdaptive({ fixRatio: 2 });
      }
      break;
    default:
      throw new Error('invalid inflate mode');
  }

  // copy
  {
    output.set(input.subarray(ip, ip + len), op);
    op += len;
    ip += len;
  }

  this.ip = ip;
  this.op = op;
  this.output = output;
};

/**
* parse fixed huffman block.
*/
Zlib.RawInflate.prototype.parseFixedHuffmanBlock = function () {
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      this.decodeHuffmanAdaptive(
        Zlib.RawInflate.FixedLiteralLengthTable,
        Zlib.RawInflate.FixedDistanceTable
      );
      break;
    case Zlib.RawInflate.BufferType.BLOCK:
      this.decodeHuffmanBlock(
        Zlib.RawInflate.FixedLiteralLengthTable,
        Zlib.RawInflate.FixedDistanceTable
      );
      break;
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
* parse dynamic huffman block.
*/
Zlib.RawInflate.prototype.parseDynamicHuffmanBlock = function () {
  /** @type {number} number of literal and length codes. */
  var hlit = this.readBits(5) + 257;
  /** @type {number} number of distance codes. */
  var hdist = this.readBits(5) + 1;
  /** @type {number} number of code lengths. */
  var hclen = this.readBits(4) + 4;
  /** @type {!(Uint8Array|Array.<number>)} code lengths. */
  var codeLengths =
    new (Uint8Array)(Zlib.RawInflate.Order.length);
  /** @type {!Array} code lengths table. */
  var codeLengthsTable;
  /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */
  var litlenTable;
  /** @type {!(Uint8Array|Array.<number>)} distance code table. */
  var distTable;
  /** @type {!(Uint8Array|Array.<number>)} code length table. */
  var lengthTable;
  /** @type {number} */
  var code;
  /** @type {number} */
  var prev;
  /** @type {number} */
  var repeat;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limit. */
  var il;

  // decode code lengths
  for (i = 0; i < hclen; ++i) {
    codeLengths[Zlib.RawInflate.Order[i]] = this.readBits(3);
  }

  // decode length table
  codeLengthsTable = buildHuffmanTable(codeLengths);
  lengthTable = new (Uint8Array)(hlit + hdist);
  for (i = 0, il = hlit + hdist; i < il;) {
    code = this.readCodeByTable(codeLengthsTable);
    switch (code) {
      case 16:
        repeat = 3 + this.readBits(2);
        while (repeat--) { lengthTable[i++] = prev; }
        break;
      case 17:
        repeat = 3 + this.readBits(3);
        while (repeat--) { lengthTable[i++] = 0; }
        prev = 0;
        break;
      case 18:
        repeat = 11 + this.readBits(7);
        while (repeat--) { lengthTable[i++] = 0; }
        prev = 0;
        break;
      default:
        lengthTable[i++] = code;
        prev = code;
        break;
    }
  }

  litlenTable = buildHuffmanTable(lengthTable.subarray(0, hlit))
    ;
  distTable = buildHuffmanTable(lengthTable.subarray(hlit))
    ;

  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      this.decodeHuffmanAdaptive(litlenTable, distTable);
      break;
    case Zlib.RawInflate.BufferType.BLOCK:
      this.decodeHuffmanBlock(litlenTable, distTable);
      break;
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
* decode huffman code
* @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.
* @param {!(Array.<number>|Uint8Array)} dist distination code table.
*/
Zlib.RawInflate.prototype.decodeHuffmanBlock = function (litlen, dist) {
  var output = this.output;
  var op = this.op;

  this.currentLitlenTable = litlen;

  /** @type {number} output position limit. */
  var olength = output.length - Zlib.RawInflate.MaxCopyLength;
  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  var lengthCodeTable = Zlib.RawInflate.LengthCodeTable;
  var lengthExtraTable = Zlib.RawInflate.LengthExtraTable;
  var distCodeTable = Zlib.RawInflate.DistCodeTable;
  var distExtraTable = Zlib.RawInflate.DistExtraTable;

  while ((code = this.readCodeByTable(litlen)) !== 256) {
    // literal
    if (code < 256) {
      if (op >= olength) {
        this.op = op;
        output = this.expandBufferBlock();
        op = this.op;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = lengthCodeTable[ti];
    if (lengthExtraTable[ti] > 0) {
      codeLength += this.readBits(lengthExtraTable[ti]);
    }

    // dist code
    code = this.readCodeByTable(dist);
    codeDist = distCodeTable[code];
    if (distExtraTable[code] > 0) {
      codeDist += this.readBits(distExtraTable[code]);
    }

    // lz77 decode
    if (op >= olength) {
      this.op = op;
      output = this.expandBufferBlock();
      op = this.op;
    }
    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};

/**
* decode huffman code (adaptive)
* @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.
* @param {!(Array.<number>|Uint8Array)} dist distination code table.
*/
Zlib.RawInflate.prototype.decodeHuffmanAdaptive = function (litlen, dist) {
  var output = this.output;
  var op = this.op;

  this.currentLitlenTable = litlen;

  /** @type {number} output position limit. */
  var olength = output.length;
  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  var lengthCodeTable = Zlib.RawInflate.LengthCodeTable;
  var lengthExtraTable = Zlib.RawInflate.LengthExtraTable;
  var distCodeTable = Zlib.RawInflate.DistCodeTable;
  var distExtraTable = Zlib.RawInflate.DistExtraTable;

  while ((code = this.readCodeByTable(litlen)) !== 256) {
    // literal
    if (code < 256) {
      if (op >= olength) {
        output = this.expandBufferAdaptive();
        olength = output.length;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = lengthCodeTable[ti];
    if (lengthExtraTable[ti] > 0) {
      codeLength += this.readBits(lengthExtraTable[ti]);
    }

    // dist code
    code = this.readCodeByTable(dist);
    codeDist = distCodeTable[code];
    if (distExtraTable[code] > 0) {
      codeDist += this.readBits(distExtraTable[code]);
    }

    // lz77 decode
    if (op + codeLength > olength) {
      output = this.expandBufferAdaptive();
      olength = output.length;
    }
    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};

/**
* expand output buffer.
* @param {Object=} opt_param option parameters.
* @return {!(Array.<number>|Uint8Array)} output buffer.
*/
Zlib.RawInflate.prototype.expandBufferBlock = function (opt_param) {
  /** @type {!(Array.<number>|Uint8Array)} store buffer. */
  var buffer =
    new (Uint8Array)(
      this.op - Zlib.RawInflate.MaxBackwardLength
    );
  /** @type {number} backward base point */
  var backward = this.op - Zlib.RawInflate.MaxBackwardLength;

  var output = this.output;

  // copy to output buffer
  {
    buffer.set(output.subarray(Zlib.RawInflate.MaxBackwardLength, buffer.length));
  }

  this.blocks.push(buffer);
  this.totalpos += buffer.length;

  // copy to backward buffer
  {
    output.set(
      output.subarray(backward, backward + Zlib.RawInflate.MaxBackwardLength)
    );
  }

  this.op = Zlib.RawInflate.MaxBackwardLength;

  return output;
};

/**
* expand output buffer. (adaptive)
* @param {Object=} opt_param option parameters.
* @return {!(Array.<number>|Uint8Array)} output buffer pointer.
*/
Zlib.RawInflate.prototype.expandBufferAdaptive = function (opt_param) {
  /** @type {!(Array.<number>|Uint8Array)} store buffer. */
  var buffer;
  /** @type {number} expantion ratio. */
  var ratio = (this.input.length / this.ip + 1) | 0;
  /** @type {number} maximum number of huffman code. */
  var maxHuffCode;
  /** @type {number} new output buffer size. */
  var newSize;
  /** @type {number} max inflate size. */
  var maxInflateSize;

  var input = this.input;
  var output = this.output;

  if (opt_param) {
    if (typeof opt_param.fixRatio === 'number') {
      ratio = opt_param.fixRatio;
    }
    if (typeof opt_param.addRatio === 'number') {
      ratio += opt_param.addRatio;
    }
  }

  // calculate new buffer size
  if (ratio < 2) {
    maxHuffCode =
      (input.length - this.ip) / this.currentLitlenTable[2];
    maxInflateSize = (maxHuffCode / 2 * 258) | 0;
    newSize = maxInflateSize < output.length ?
      output.length + maxInflateSize :
      output.length << 1;
  } else {
    newSize = output.length * ratio;
  }

  // buffer expantion
  {
    buffer = new Uint8Array(newSize);
    buffer.set(output);
  }

  this.output = buffer;

  return this.output;
};

/**
* concat output buffer.
* @return {!(Array.<number>|Uint8Array)} output buffer.
*/
Zlib.RawInflate.prototype.concatBufferBlock = function () {
  /** @type {number} buffer pointer. */
  var pos = 0;
  /** @type {number} buffer pointer. */
  var limit = this.totalpos + (this.op - Zlib.RawInflate.MaxBackwardLength);
  /** @type {!(Array.<number>|Uint8Array)} output block array. */
  var output = this.output;
  /** @type {!Array} blocks array. */
  var blocks = this.blocks;
  /** @type {!(Array.<number>|Uint8Array)} output block array. */
  var block;
  /** @type {!(Array.<number>|Uint8Array)} output buffer. */
  var buffer = new (Uint8Array)(limit);
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limiter. */
  var il;
  /** @type {number} loop counter. */
  var j;
  /** @type {number} loop limiter. */
  var jl;

  // single buffer
  if (blocks.length === 0) {
    return this.output.subarray(Zlib.RawInflate.MaxBackwardLength, this.op);
  }

  // copy to buffer
  for (i = 0, il = blocks.length; i < il; ++i) {
    block = blocks[i];
    for (j = 0, jl = block.length; j < jl; ++j) {
      buffer[pos++] = block[j];
    }
  }

  // current buffer
  for (i = Zlib.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {
    buffer[pos++] = output[i];
  }

  this.blocks = [];
  this.buffer = buffer;

  return this.buffer;
};

/**
* concat output buffer. (dynamic)
* @return {!(Array.<number>|Uint8Array)} output buffer.
*/
Zlib.RawInflate.prototype.concatBufferDynamic = function () {
  /** @type {Array.<number>|Uint8Array} output buffer. */
  var buffer;
  var op = this.op;

  {
    if (this.resize) {
      buffer = new Uint8Array(op);
      buffer.set(this.output.subarray(0, op));
    } else {
      buffer = this.output.subarray(0, op);
    }
  }

  this.buffer = buffer;

  return this.buffer;
};




var buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;

/**
* @param {!(Uint8Array|Array.<number>)} input input buffer.
* @param {number} ip input buffer pointer.
* @param {number=} opt_buffersize buffer block size.
* @constructor
*/
Zlib.RawInflateStream = function (input, ip, opt_buffersize) {
  /** @type {!Array.<(Array|Uint8Array)>} */
  this.blocks = [];
  /** @type {number} block size. */
  this.bufferSize =
    opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE;
  /** @type {!number} total output buffer pointer. */
  this.totalpos = 0;
  /** @type {!number} input buffer pointer. */
  this.ip = ip === void 0 ? 0 : ip;
  /** @type {!number} bit stream reader buffer. */
  this.bitsbuf = 0;
  /** @type {!number} bit stream reader buffer size. */
  this.bitsbuflen = 0;
  /** @type {!(Array|Uint8Array)} input buffer. */
  this.input = new Uint8Array(input);
  /** @type {!(Uint8Array|Array)} output buffer. */
  this.output = new (Uint8Array)(this.bufferSize);
  /** @type {!number} output buffer pointer. */
  this.op = 0;
  /** @type {boolean} is final block flag. */
  this.bfinal = false;
  /** @type {number} uncompressed block length. */
  this.blockLength;
  /** @type {boolean} resize flag for memory size optimization. */
  this.resize = false;
  /** @type {Array} */
  this.litlenTable;
  /** @type {Array} */
  this.distTable;
  /** @type {number} */
  this.sp = 0; // stream pointer
  /** @type {Zlib.RawInflateStream.Status} */
  this.status = Zlib.RawInflateStream.Status.INITIALIZED;

  //
  // backup
  //
  /** @type {!number} */
  this.ip_;
  /** @type {!number} */
  this.bitsbuflen_;
  /** @type {!number} */
  this.bitsbuf_;
};

/**
* @enum {number}
*/
Zlib.RawInflateStream.BlockType = {
  UNCOMPRESSED: 0,
  FIXED: 1,
  DYNAMIC: 2
};

/**
* @enum {number}
*/
Zlib.RawInflateStream.Status = {
  INITIALIZED: 0,
  BLOCK_HEADER_START: 1,
  BLOCK_HEADER_END: 2,
  BLOCK_BODY_START: 3,
  BLOCK_BODY_END: 4,
  DECODE_BLOCK_START: 5,
  DECODE_BLOCK_END: 6
};

/**
* decompress.
* @return {!(Uint8Array|Array)} inflated buffer.
*/
Zlib.RawInflateStream.prototype.decompress = function (newInput, ip) {
  /** @type {boolean} */
  var stop = false;

  if (newInput !== void 0) {
    this.input = newInput;
  }

  if (ip !== void 0) {
    this.ip = ip;
  }

  // decompress
  while (!stop) {
    switch (this.status) {
      // block header
      case Zlib.RawInflateStream.Status.INITIALIZED:
      case Zlib.RawInflateStream.Status.BLOCK_HEADER_START:
        if (this.readBlockHeader() < 0) {
          stop = true;
        }
        break;
      // block body
      case Zlib.RawInflateStream.Status.BLOCK_HEADER_END: /* FALLTHROUGH */
      case Zlib.RawInflateStream.Status.BLOCK_BODY_START:
        switch (this.currentBlockType) {
          case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:
            if (this.readUncompressedBlockHeader() < 0) {
              stop = true;
            }
            break;
          case Zlib.RawInflateStream.BlockType.FIXED:
            if (this.parseFixedHuffmanBlock() < 0) {
              stop = true;
            }
            break;
          case Zlib.RawInflateStream.BlockType.DYNAMIC:
            if (this.parseDynamicHuffmanBlock() < 0) {
              stop = true;
            }
            break;
        }
        break;
      // decode data
      case Zlib.RawInflateStream.Status.BLOCK_BODY_END:
      case Zlib.RawInflateStream.Status.DECODE_BLOCK_START:
        switch (this.currentBlockType) {
          case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:
            if (this.parseUncompressedBlock() < 0) {
              stop = true;
            }
            break;
          case Zlib.RawInflateStream.BlockType.FIXED: /* FALLTHROUGH */
          case Zlib.RawInflateStream.BlockType.DYNAMIC:
            if (this.decodeHuffman() < 0) {
              stop = true;
            }
            break;
        }
        break;
      case Zlib.RawInflateStream.Status.DECODE_BLOCK_END:
        if (this.bfinal) {
          stop = true;
        } else {
          this.status = Zlib.RawInflateStream.Status.INITIALIZED;
        }
        break;
    }
  }

  return this.concatBuffer();
};

/**
* @const
* @type {number} max backward length for LZ77.
*/
Zlib.RawInflateStream.MaxBackwardLength = 32768;

/**
* @const
* @type {number} max copy length for LZ77.
*/
Zlib.RawInflateStream.MaxCopyLength = 258;

/**
* huffman order
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib.RawInflateStream.Order = (function (table) {
  return new Uint16Array(table);
})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

/**
* huffman length code table.
* @const
* @type {!(Array.<number>|Uint16Array)}
*/
Zlib.RawInflateStream.LengthCodeTable = (function (table) {
  return new Uint16Array(table);
})([
  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,
  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,
  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,
  0x00e3, 0x0102, 0x0102, 0x0102
]);

/**
* huffman length extra-bits table.
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib.RawInflateStream.LengthExtraTable = (function (table) {
  return new Uint8Array(table);
})([
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 5, 0, 0, 0
]);

/**
* huffman dist code table.
* @const
* @type {!(Array.<number>|Uint16Array)}
*/
Zlib.RawInflateStream.DistCodeTable = (function (table) {
  return new Uint16Array(table);
})([
  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,
  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,
  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,
  0x3001, 0x4001, 0x6001
]);

/**
* huffman dist extra-bits table.
* @const
* @type {!(Array.<number>|Uint8Array)}
*/
Zlib.RawInflateStream.DistExtraTable = (function (table) {
  return new Uint8Array(table);
})([
  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
  11, 12, 12, 13, 13
]);

/**
* fixed huffman length code table
* @const
* @type {!Array}
*/
Zlib.RawInflateStream.FixedLiteralLengthTable = (function (table) {
  return table;
})((function () {
  var lengths = new (Uint8Array)(288);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] =
      (i <= 143) ? 8 :
        (i <= 255) ? 9 :
          (i <= 279) ? 7 :
            8;
  }

  return buildHuffmanTable(lengths);
})());

/**
* fixed huffman distance code table
* @const
* @type {!Array}
*/
Zlib.RawInflateStream.FixedDistanceTable = (function (table) {
  return table;
})((function () {
  var lengths = new (Uint8Array)(30);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = 5;
  }

  return buildHuffmanTable(lengths);
})());

/**
* parse deflated block.
*/
Zlib.RawInflateStream.prototype.readBlockHeader = function () {
  /** @type {number} header */
  var hdr;

  this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_START;

  this.save_();
  if ((hdr = this.readBits(3)) < 0) {
    this.restore_();
    return -1;
  }

  // BFINAL
  if (hdr & 0x1) {
    this.bfinal = true;
  }

  // BTYPE
  hdr >>>= 1;
  switch (hdr) {
    case 0: // uncompressed
      this.currentBlockType = Zlib.RawInflateStream.BlockType.UNCOMPRESSED;
      break;
    case 1: // fixed huffman
      this.currentBlockType = Zlib.RawInflateStream.BlockType.FIXED;
      break;
    case 2: // dynamic huffman
      this.currentBlockType = Zlib.RawInflateStream.BlockType.DYNAMIC;
      break;
    default: // reserved or other
      throw new Error('unknown BTYPE: ' + hdr);
  }

  this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_END;
};

/**
* read inflate bits
* @param {number} length bits length.
* @return {number} read bits.
*/
Zlib.RawInflateStream.prototype.readBits = function (length) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} input and output byte. */
  var octet;

  // not enough buffer
  while (bitsbuflen < length) {
    // input byte
    if (input.length <= ip) {
      return -1;
    }
    octet = input[ip++];

    // concat octet
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }

  // output byte
  octet = bitsbuf & /* MASK */ ((1 << length) - 1);
  bitsbuf >>>= length;
  bitsbuflen -= length;

  this.bitsbuf = bitsbuf;
  this.bitsbuflen = bitsbuflen;
  this.ip = ip;

  return octet;
};

/**
* read huffman code using table
* @param {Array} table huffman code table.
* @return {number} huffman code.
*/
Zlib.RawInflateStream.prototype.readCodeByTable = function (table) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {!(Array|Uint8Array)} huffman code table */
  var codeTable = table[0];
  /** @type {number} */
  var maxCodeLength = table[1];
  /** @type {number} input byte */
  var octet;
  /** @type {number} code length & code (16bit, 16bit) */
  var codeWithLength;
  /** @type {number} code bits length */
  var codeLength;

  // not enough buffer
  while (bitsbuflen < maxCodeLength) {
    if (input.length <= ip) {
      return -1;
    }
    octet = input[ip++];
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }

  // read max length
  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];
  codeLength = codeWithLength >>> 16;

  if (codeLength > bitsbuflen) {
    throw new Error('invalid code length: ' + codeLength);
  }

  this.bitsbuf = bitsbuf >> codeLength;
  this.bitsbuflen = bitsbuflen - codeLength;
  this.ip = ip;

  return codeWithLength & 0xffff;
};

/**
* read uncompressed block header
*/
Zlib.RawInflateStream.prototype.readUncompressedBlockHeader = function () {
  /** @type {number} block length */
  var len;
  /** @type {number} number for check block length */
  var nlen;

  var input = this.input;
  var ip = this.ip;

  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;

  if (ip + 4 >= input.length) {
    return -1;
  }

  len = input[ip++] | (input[ip++] << 8);
  nlen = input[ip++] | (input[ip++] << 8);

  // check len & nlen
  if (len === ~nlen) {
    throw new Error('invalid uncompressed block header: length verify');
  }

  // skip buffered header bits
  this.bitsbuf = 0;
  this.bitsbuflen = 0;

  this.ip = ip;
  this.blockLength = len;
  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;
};

/**
* parse uncompressed block.
*/
Zlib.RawInflateStream.prototype.parseUncompressedBlock = function () {
  var input = this.input;
  var ip = this.ip;
  var output = this.output;
  var op = this.op;
  var len = this.blockLength;

  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;

  // copy
  // XXX: とりあえず素直にコピー
  while (len--) {
    if (op === output.length) {
      output = this.expandBuffer({ fixRatio: 2 });
    }

    // not enough input buffer
    if (ip >= input.length) {
      this.ip = ip;
      this.op = op;
      this.blockLength = len + 1; // コピーしてないので戻す
      return -1;
    }

    output[op++] = input[ip++];
  }

  if (len < 0) {
    this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;
  }

  this.ip = ip;
  this.op = op;

  return 0;
};

/**
* parse fixed huffman block.
*/
Zlib.RawInflateStream.prototype.parseFixedHuffmanBlock = function () {
  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;

  this.litlenTable = Zlib.RawInflateStream.FixedLiteralLengthTable;
  this.distTable = Zlib.RawInflateStream.FixedDistanceTable;

  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;

  return 0;
};

/**
* オブジェクトのコンテキストを別のプロパティに退避する.
* @private
*/
Zlib.RawInflateStream.prototype.save_ = function () {
  this.ip_ = this.ip;
  this.bitsbuflen_ = this.bitsbuflen;
  this.bitsbuf_ = this.bitsbuf;
};

/**
* 別のプロパティに退避したコンテキストを復元する.
* @private
*/
Zlib.RawInflateStream.prototype.restore_ = function () {
  this.ip = this.ip_;
  this.bitsbuflen = this.bitsbuflen_;
  this.bitsbuf = this.bitsbuf_;
};

/**
* parse dynamic huffman block.
*/
Zlib.RawInflateStream.prototype.parseDynamicHuffmanBlock = function () {
  /** @type {number} number of literal and length codes. */
  var hlit;
  /** @type {number} number of distance codes. */
  var hdist;
  /** @type {number} number of code lengths. */
  var hclen;
  /** @type {!(Uint8Array|Array)} code lengths. */
  var codeLengths =
    new (Uint8Array)(Zlib.RawInflateStream.Order.length);
  /** @type {!Array} code lengths table. */
  var codeLengthsTable;

  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;

  this.save_();
  hlit = this.readBits(5) + 257;
  hdist = this.readBits(5) + 1;
  hclen = this.readBits(4) + 4;
  if (hlit < 0 || hdist < 0 || hclen < 0) {
    this.restore_();
    return -1;
  }

  try {
    parseDynamicHuffmanBlockImpl.call(this);
  } catch (e) {
    this.restore_();
    return -1;
  }

  function parseDynamicHuffmanBlockImpl() {
    /** @type {number} */
    var bits;
    var code;
    var prev = 0;
    var repeat;
    /** @type {!(Uint8Array|Array.<number>)} code length table. */
    var lengthTable;
    /** @type {number} loop counter. */
    var i;
    /** @type {number} loop limit. */
    var il;

    // decode code lengths
    for (i = 0; i < hclen; ++i) {
      if ((bits = this.readBits(3)) < 0) {
        throw new Error('not enough input');
      }
      codeLengths[Zlib.RawInflateStream.Order[i]] = bits;
    }

    // decode length table
    codeLengthsTable = buildHuffmanTable(codeLengths);
    lengthTable = new (Uint8Array)(hlit + hdist);
    for (i = 0, il = hlit + hdist; i < il;) {
      code = this.readCodeByTable(codeLengthsTable);
      if (code < 0) {
        throw new Error('not enough input');
      }
      switch (code) {
        case 16:
          if ((bits = this.readBits(2)) < 0) {
            throw new Error('not enough input');
          }
          repeat = 3 + bits;
          while (repeat--) { lengthTable[i++] = prev; }
          break;
        case 17:
          if ((bits = this.readBits(3)) < 0) {
            throw new Error('not enough input');
          }
          repeat = 3 + bits;
          while (repeat--) { lengthTable[i++] = 0; }
          prev = 0;
          break;
        case 18:
          if ((bits = this.readBits(7)) < 0) {
            throw new Error('not enough input');
          }
          repeat = 11 + bits;
          while (repeat--) { lengthTable[i++] = 0; }
          prev = 0;
          break;
        default:
          lengthTable[i++] = code;
          prev = code;
          break;
      }
    }

    this.litlenTable = buildHuffmanTable(lengthTable.subarray(0, hlit))
      ;
    this.distTable = buildHuffmanTable(lengthTable.subarray(hlit))
      ;
  }

  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;

  return 0;
};

/**
* decode huffman code (dynamic)
* @return {(number|undefined)} -1 is error.
*/
Zlib.RawInflateStream.prototype.decodeHuffman = function () {
  var output = this.output;
  var op = this.op;

  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  var litlen = this.litlenTable;
  var dist = this.distTable;

  var olength = output.length;
  var bits;

  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;

  while (true) {
    this.save_();

    code = this.readCodeByTable(litlen);
    if (code < 0) {
      this.op = op;
      this.restore_();
      return -1;
    }

    if (code === 256) {
      break;
    }

    // literal
    if (code < 256) {
      if (op === olength) {
        output = this.expandBuffer();
        olength = output.length;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = Zlib.RawInflateStream.LengthCodeTable[ti];
    if (Zlib.RawInflateStream.LengthExtraTable[ti] > 0) {
      bits = this.readBits(Zlib.RawInflateStream.LengthExtraTable[ti]);
      if (bits < 0) {
        this.op = op;
        this.restore_();
        return -1;
      }
      codeLength += bits;
    }

    // dist code
    code = this.readCodeByTable(dist);
    if (code < 0) {
      this.op = op;
      this.restore_();
      return -1;
    }
    codeDist = Zlib.RawInflateStream.DistCodeTable[code];
    if (Zlib.RawInflateStream.DistExtraTable[code] > 0) {
      bits = this.readBits(Zlib.RawInflateStream.DistExtraTable[code]);
      if (bits < 0) {
        this.op = op;
        this.restore_();
        return -1;
      }
      codeDist += bits;
    }

    // lz77 decode
    if (op + codeLength >= olength) {
      output = this.expandBuffer();
      olength = output.length;
    }

    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }

    // break
    if (this.ip === this.input.length) {
      this.op = op;
      return -1;
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }

  this.op = op;
  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;
};

/**
* expand output buffer. (dynamic)
* @param {Object=} opt_param option parameters.
* @return {!(Array|Uint8Array)} output buffer pointer.
*/
Zlib.RawInflateStream.prototype.expandBuffer = function (opt_param) {
  /** @type {!(Array|Uint8Array)} store buffer. */
  var buffer;
  /** @type {number} expantion ratio. */
  var ratio = (this.input.length / this.ip + 1) | 0;
  /** @type {number} maximum number of huffman code. */
  var maxHuffCode;
  /** @type {number} new output buffer size. */
  var newSize;
  /** @type {number} max inflate size. */
  var maxInflateSize;

  var input = this.input;
  var output = this.output;

  if (opt_param) {
    if (typeof opt_param.fixRatio === 'number') {
      ratio = opt_param.fixRatio;
    }
    if (typeof opt_param.addRatio === 'number') {
      ratio += opt_param.addRatio;
    }
  }

  // calculate new buffer size
  if (ratio < 2) {
    maxHuffCode =
      (input.length - this.ip) / this.litlenTable[2];
    maxInflateSize = (maxHuffCode / 2 * 258) | 0;
    newSize = maxInflateSize < output.length ?
      output.length + maxInflateSize :
      output.length << 1;
  } else {
    newSize = output.length * ratio;
  }

  // buffer expantion
  {
    buffer = new Uint8Array(newSize);
    buffer.set(output);
  }

  this.output = buffer;

  return this.output;
};

/**
* concat output buffer. (dynamic)
* @return {!(Array|Uint8Array)} output buffer.
*/
Zlib.RawInflateStream.prototype.concatBuffer = function () {
  /** @type {!(Array|Uint8Array)} output buffer. */
  var buffer;
  /** @type {number} */
  var op = this.op;
  /** @type {Uint8Array} */
  var tmp;

  if (this.resize) {
    {
      buffer = new Uint8Array(this.output.subarray(this.sp, op));
    }
  } else {
    buffer =
      this.output.subarray(this.sp, op);
  }

  this.sp = op;

  // compaction
  if (op > Zlib.RawInflateStream.MaxBackwardLength + this.bufferSize) {
    this.op = this.sp = Zlib.RawInflateStream.MaxBackwardLength;
    {
      tmp = /** @type {Uint8Array} */(this.output);
      this.output = new Uint8Array(this.bufferSize + Zlib.RawInflateStream.MaxBackwardLength);
      this.output.set(tmp.subarray(op - Zlib.RawInflateStream.MaxBackwardLength, op));
    }
  }

  return buffer;
};


/**
* @constructor
* @param {!(Uint8Array|Array)} input deflated buffer.
* @param {Object=} opt_params option parameters.
*
* opt_params は以下のプロパティを指定する事ができます。
*   - index: input buffer の deflate コンテナの開始位置.
*   - blockSize: バッファのブロックサイズ.
*   - verify: 伸張が終わった後 adler-32 checksum の検証を行うか.
*   - bufferType: Zlib.Inflate.BufferType の値によってバッファの管理方法を指定する.
*       Zlib.Inflate.BufferType は Zlib.RawInflate.BufferType のエイリアス.
*/
Zlib.Inflate = function (input, opt_params) {
  /** @type {number} */
  var cmf;
  /** @type {number} */
  var flg;

  /** @type {!(Uint8Array|Array)} */
  this.input = input;
  /** @type {number} */
  this.ip = 0;
  /** @type {Zlib.RawInflate} */
  this.rawinflate;
  /** @type {(boolean|undefined)} verify flag. */
  this.verify;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (opt_params['index']) {
      this.ip = opt_params['index'];
    }
    if (opt_params['verify']) {
      this.verify = opt_params['verify'];
    }
  }

  // Compression Method and Flags
  cmf = input[this.ip++];
  flg = input[this.ip++];

  // compression method
  switch (cmf & 0x0f) {
    case Zlib.CompressionMethod.DEFLATE:
      this.method = Zlib.CompressionMethod.DEFLATE;
      break;
    default:
      throw new Error('unsupported compression method');
  }

  // fcheck
  if (((cmf << 8) + flg) % 31 !== 0) {
    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
  }

  // fdict (not supported)
  if (flg & 0x20) {
    throw new Error('fdict flag is not supported');
  }

  // RawInflate
  this.rawinflate = new Zlib.RawInflate(input, {
    'index': this.ip,
    'bufferSize': opt_params['bufferSize'],
    'bufferType': opt_params['bufferType'],
    'resize': opt_params['resize']
  });
};

/**
* @enum {number}
*/
Zlib.Inflate.BufferType = Zlib.RawInflate.BufferType;

/**
* decompress.
* @return {!(Uint8Array|Array)} inflated buffer.
*/
Zlib.Inflate.prototype.decompress = function () {
  /** @type {!(Array|Uint8Array)} input buffer. */
  var input = this.input;
  /** @type {!(Uint8Array|Array)} inflated buffer. */
  var buffer;
  /** @type {number} adler-32 checksum */
  var adler32;

  buffer = this.rawinflate.decompress();
  this.ip = this.rawinflate.ip;

  // verify adler-32
  if (this.verify) {
    adler32 = (
      input[this.ip++] << 24 | input[this.ip++] << 16 |
      input[this.ip++] << 8 | input[this.ip++]
    ) >>> 0;

    if (adler32 !== Zlib.Adler32(buffer)) {
      throw new Error('invalid adler-32 checksum');
    }
  }

  return buffer;
};


/* vim:set expandtab ts=2 sw=2 tw=80: */


/**
* @param {!(Uint8Array|Array)} input deflated buffer.
* @constructor
*/
Zlib.InflateStream = function (input) {
  /** @type {!(Uint8Array|Array)} */
  this.input = input === void 0 ? new (Uint8Array)() : input;
  /** @type {number} */
  this.ip = 0;
  /** @type {Zlib.RawInflateStream} */
  this.rawinflate = new Zlib.RawInflateStream(this.input, this.ip);
  /** @type {Zlib.CompressionMethod} */
  this.method;
  /** @type {!(Array|Uint8Array)} */
  this.output = this.rawinflate.output;
};

/**
* decompress.
* @return {!(Uint8Array|Array)} inflated buffer.
*/
Zlib.InflateStream.prototype.decompress = function (input) {
  /** @type {!(Uint8Array|Array)} inflated buffer. */
  var buffer;

  // 新しい入力を入力バッファに結合する
  // XXX Array, Uint8Array のチェックを行うか確認する
  if (input !== void 0) {
    {
      var tmp = new Uint8Array(this.input.length + input.length);
      tmp.set(this.input, 0);
      tmp.set(input, this.input.length);
      this.input = tmp;
    }
  }

  if (this.method === void 0) {
    if (this.readHeader() < 0) {
      return new (Uint8Array)();
    }
  }

  buffer = this.rawinflate.decompress(this.input, this.ip);
  if (this.rawinflate.ip !== 0) {
    this.input = this.input.subarray(this.rawinflate.ip);
    this.ip = 0;
  }

  // verify adler-32
  /*
  if (this.verify) {
    adler32 =
      input[this.ip++] << 24 | input[this.ip++] << 16 |
      input[this.ip++] << 8 | input[this.ip++];
  
    if (adler32 !== Zlib.Adler32(buffer)) {
      throw new Error('invalid adler-32 checksum');
    }
  }
  */

  return buffer;
};

Zlib.InflateStream.prototype.readHeader = function () {
  var ip = this.ip;
  var input = this.input;

  // Compression Method and Flags
  var cmf = input[ip++];
  var flg = input[ip++];

  if (cmf === void 0 || flg === void 0) {
    return -1;
  }

  // compression method
  switch (cmf & 0x0f) {
    case Zlib.CompressionMethod.DEFLATE:
      this.method = Zlib.CompressionMethod.DEFLATE;
      break;
    default:
      throw new Error('unsupported compression method');
  }

  // fcheck
  if (((cmf << 8) + flg) % 31 !== 0) {
    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
  }

  // fdict (not supported)
  if (flg & 0x20) {
    throw new Error('fdict flag is not supported');
  }

  this.ip = ip;
};


/**
* @fileoverview GZIP (RFC1952) 展開コンテナ実装.
*/

/**
* @constructor
* @param {!(Array|Uint8Array)} input input buffer.
* @param {Object=} opt_params option parameters.
*/
Zlib.Gunzip = function (input, opt_params) {
  /** @type {!(Array.<number>|Uint8Array)} input buffer. */
  this.input = input;
  /** @type {number} input buffer pointer. */
  this.ip = 0;
  /** @type {Array.<Zlib.GunzipMember>} */
  this.member = [];
  /** @type {boolean} */
  this.decompressed = false;
};

/**
* @return {Array.<Zlib.GunzipMember>}
*/
Zlib.Gunzip.prototype.getMembers = function () {
  if (!this.decompressed) {
    this.decompress();
  }

  return this.member.slice();
};

/**
* inflate gzip data.
* @return {!(Array.<number>|Uint8Array)} inflated buffer.
*/
Zlib.Gunzip.prototype.decompress = function () {
  /** @type {number} input length. */
  var il = this.input.length;

  while (this.ip < il) {
    this.decodeMember();
  }

  this.decompressed = true;

  return this.concatMember();
};

/**
* decode gzip member.
*/
Zlib.Gunzip.prototype.decodeMember = function () {
  /** @type {Zlib.GunzipMember} */
  var member = new Zlib.GunzipMember();
  /** @type {number} */
  var isize;
  /** @type {Zlib.RawInflate} RawInflate implementation. */
  var rawinflate;
  /** @type {!(Array.<number>|Uint8Array)} inflated data. */
  var inflated;
  /** @type {number} inflate size */
  var inflen;
  /** @type {number} character code */
  var c;
  /** @type {number} character index in string. */
  var ci;
  /** @type {Array.<string>} character array. */
  var str;
  /** @type {number} modification time. */
  var mtime;
  /** @type {number} */
  var crc32;

  var input = this.input;
  var ip = this.ip;

  member.id1 = input[ip++];
  member.id2 = input[ip++];

  // check signature
  if (member.id1 !== 0x1f || member.id2 !== 0x8b) {
    throw new Error('invalid file signature:' + member.id1 + ',' + member.id2);
  }

  // check compression method
  member.cm = input[ip++];
  switch (member.cm) {
    case 8: /* XXX: use Zlib const */
      break;
    default:
      throw new Error('unknown compression method: ' + member.cm);
  }

  // flags
  member.flg = input[ip++];

  // modification time
  mtime = (input[ip++]) |
    (input[ip++] << 8) |
    (input[ip++] << 16) |
    (input[ip++] << 24);
  member.mtime = new Date(mtime * 1000);

  // extra flags
  member.xfl = input[ip++];

  // operating system
  member.os = input[ip++];

  // extra
  if ((member.flg & Zlib.Gzip.FlagsMask.FEXTRA) > 0) {
    member.xlen = input[ip++] | (input[ip++] << 8);
    ip = this.decodeSubField(ip, member.xlen);
  }

  // fname
  if ((member.flg & Zlib.Gzip.FlagsMask.FNAME) > 0) {
    for (str = [], ci = 0; (c = input[ip++]) > 0;) {
      str[ci++] = String.fromCharCode(c);
    }
    member.name = str.join('');
  }

  // fcomment
  if ((member.flg & Zlib.Gzip.FlagsMask.FCOMMENT) > 0) {
    for (str = [], ci = 0; (c = input[ip++]) > 0;) {
      str[ci++] = String.fromCharCode(c);
    }
    member.comment = str.join('');
  }

  // fhcrc
  if ((member.flg & Zlib.Gzip.FlagsMask.FHCRC) > 0) {
    member.crc16 = Zlib.CRC32.calc(input, 0, ip) & 0xffff;
    if (member.crc16 !== (input[ip++] | (input[ip++] << 8))) {
      throw new Error('invalid header crc16');
    }
  }

  // isize を事前に取得すると展開後のサイズが分かるため、
  // inflate処理のバッファサイズが事前に分かり、高速になる
  isize = (input[input.length - 4]) | (input[input.length - 3] << 8) |
    (input[input.length - 2] << 16) | (input[input.length - 1] << 24);

  // isize の妥当性チェック
  // ハフマン符号では最小 2-bit のため、最大で 1/4 になる
  // LZ77 符号では 長さと距離 2-Byte で最大 258-Byte を表現できるため、
  // 1/128 になるとする
  // ここから入力バッファの残りが isize の 512 倍以上だったら
  // サイズ指定のバッファ確保は行わない事とする
  if (input.length - ip - /* CRC-32 */4 - /* ISIZE */4 < isize * 512) {
    inflen = isize;
  }

  // compressed block
  rawinflate = new Zlib.RawInflate(input, { 'index': ip, 'bufferSize': inflen });
  member.data = inflated = rawinflate.decompress();
  ip = rawinflate.ip;

  // crc32
  member.crc32 = crc32 =
    ((input[ip++]) | (input[ip++] << 8) |
      (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;
  if (Zlib.CRC32.calc(inflated) !== crc32) {
    throw new Error('invalid CRC-32 checksum: 0x' +
      Zlib.CRC32.calc(inflated).toString(16) + ' / 0x' + crc32.toString(16));
  }

  // input size
  member.isize = isize =
    ((input[ip++]) | (input[ip++] << 8) |
      (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;
  if ((inflated.length & 0xffffffff) !== isize) {
    throw new Error('invalid input size: ' +
      (inflated.length & 0xffffffff) + ' / ' + isize);
  }

  this.member.push(member);
  this.ip = ip;
};

/**
* サブフィールドのデコード
* XXX: 現在は何もせずスキップする
*/
Zlib.Gunzip.prototype.decodeSubField = function (ip, length) {
  return ip + length;
};

/**
* @return {!(Array.<number>|Uint8Array)}
*/
Zlib.Gunzip.prototype.concatMember = function () {
  /** @type {Array.<Zlib.GunzipMember>} */
  var member = this.member;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;
  /** @type {number} */
  var p = 0;
  /** @type {number} */
  var size = 0;
  /** @type {!(Array.<number>|Uint8Array)} */
  var buffer;

  for (i = 0, il = member.length; i < il; ++i) {
    size += member[i].data.length;
  }

  {
    buffer = new Uint8Array(size);
    for (i = 0; i < il; ++i) {
      buffer.set(member[i].data, p);
      p += member[i].data.length;
    }
  }

  return buffer;
};



/**
* @constructor
*/
Zlib.GunzipMember = function () {
  /** @type {number} signature first byte. */
  this.id1;
  /** @type {number} signature second byte. */
  this.id2;
  /** @type {number} compression method. */
  this.cm;
  /** @type {number} flags. */
  this.flg;
  /** @type {Date} modification time. */
  this.mtime;
  /** @type {number} extra flags. */
  this.xfl;
  /** @type {number} operating system number. */
  this.os;
  /** @type {number} CRC-16 value for FHCRC flag. */
  this.crc16;
  /** @type {number} extra length. */
  this.xlen;
  /** @type {number} CRC-32 value for verification. */
  this.crc32;
  /** @type {number} input size modulo 32 value. */
  this.isize;
  /** @type {string} filename. */
  this.name;
  /** @type {string} comment. */
  this.comment;
  /** @type {!(Uint8Array|Array.<number>)} */
  this.data;
};

Zlib.GunzipMember.prototype.getName = function () {
  return this.name;
};

Zlib.GunzipMember.prototype.getData = function () {
  return this.data;
};

Zlib.GunzipMember.prototype.getMtime = function () {
  return this.mtime;
};

/**
* @fileoverview GZIP (RFC1952) 実装.
*/

/**
* @constructor
* @param {!(Array|Uint8Array)} input input buffer.
* @param {Object=} opt_params option parameters.
*/
Zlib.Gzip = function (input, opt_params) {
  /** @type {!(Array.<number>|Uint8Array)} input buffer. */
  this.input = input;
  /** @type {number} input buffer pointer. */
  this.ip = 0;
  /** @type {!(Array.<number>|Uint8Array)} output buffer. */
  this.output;
  /** @type {number} output buffer. */
  this.op = 0;
  /** @type {!Object} flags option flags. */
  this.flags = {};
  /** @type {!string} filename. */
  this.filename;
  /** @type {!string} comment. */
  this.comment;
  /** @type {!Object} deflate options. */
  this.deflateOptions;

  // option parameters
  if (opt_params) {
    if (opt_params['flags']) {
      this.flags = opt_params['flags'];
    }
    if (typeof opt_params['filename'] === 'string') {
      this.filename = opt_params['filename'];
    }
    if (typeof opt_params['comment'] === 'string') {
      this.comment = opt_params['comment'];
    }
    if (opt_params['deflateOptions']) {
      this.deflateOptions = opt_params['deflateOptions'];
    }
  }

  if (!this.deflateOptions) {
    this.deflateOptions = {};
  }
};

/**
* @type {number}
* @const
*/
Zlib.Gzip.DefaultBufferSize = 0x8000;

/**
* encode gzip members.
* @return {!(Array|Uint8Array)} gzip binary array.
*/
Zlib.Gzip.prototype.compress = function () {
  /** @type {number} flags. */
  var flg;
  /** @type {number} modification time. */
  var mtime;
  /** @type {number} CRC-16 value for FHCRC flag. */
  var crc16;
  /** @type {number} CRC-32 value for verification. */
  var crc32;
  /** @type {!Zlib.RawDeflate} raw deflate object. */
  var rawdeflate;
  /** @type {number} character code */
  var c;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limiter. */
  var il;
  /** @type {!(Array|Uint8Array)} output buffer. */
  var output =
    new (Uint8Array)(Zlib.Gzip.DefaultBufferSize);
  /** @type {number} output buffer pointer. */
  var op = 0;

  var input = this.input;
  var ip = this.ip;
  var filename = this.filename;
  var comment = this.comment;

  // check signature
  output[op++] = 0x1f;
  output[op++] = 0x8b;

  // check compression method
  output[op++] = 8; /* XXX: use Zlib const */

  // flags
  flg = 0;
  if (this.flags['fname']) flg |= Zlib.Gzip.FlagsMask.FNAME;
  if (this.flags['fcomment']) flg |= Zlib.Gzip.FlagsMask.FCOMMENT;
  if (this.flags['fhcrc']) flg |= Zlib.Gzip.FlagsMask.FHCRC;
  // XXX: FTEXT
  // XXX: FEXTRA
  output[op++] = flg;

  // modification time
  mtime = (Date.now ? Date.now() : +new Date()) / 1000 | 0;
  output[op++] = mtime & 0xff;
  output[op++] = mtime >>> 8 & 0xff;
  output[op++] = mtime >>> 16 & 0xff;
  output[op++] = mtime >>> 24 & 0xff;

  // extra flags
  output[op++] = 0;

  // operating system
  output[op++] = Zlib.Gzip.OperatingSystem.UNKNOWN;

  // extra
  /* NOP */

  // fname
  if (this.flags['fname'] !== void 0) {
    for (i = 0, il = filename.length; i < il; ++i) {
      c = filename.charCodeAt(i);
      if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }
      output[op++] = c & 0xff;
    }
    output[op++] = 0; // null termination
  }

  // fcomment
  if (this.flags['comment']) {
    for (i = 0, il = comment.length; i < il; ++i) {
      c = comment.charCodeAt(i);
      if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }
      output[op++] = c & 0xff;
    }
    output[op++] = 0; // null termination
  }

  // fhcrc
  if (this.flags['fhcrc']) {
    crc16 = Zlib.CRC32.calc(output, 0, op) & 0xffff;
    output[op++] = (crc16) & 0xff;
    output[op++] = (crc16 >>> 8) & 0xff;
  }

  // add compress option
  this.deflateOptions['outputBuffer'] = output;
  this.deflateOptions['outputIndex'] = op;

  // compress
  rawdeflate = new Zlib.RawDeflate(input, this.deflateOptions);
  output = rawdeflate.compress();
  op = rawdeflate.op;

  // expand buffer
  {
    if (op + 8 > output.buffer.byteLength) {
      this.output = new Uint8Array(op + 8);
      this.output.set(new Uint8Array(output.buffer));
      output = this.output;
    } else {
      output = new Uint8Array(output.buffer);
    }
  }

  // crc32
  crc32 = Zlib.CRC32.calc(input);
  output[op++] = (crc32) & 0xff;
  output[op++] = (crc32 >>> 8) & 0xff;
  output[op++] = (crc32 >>> 16) & 0xff;
  output[op++] = (crc32 >>> 24) & 0xff;

  // input size
  il = input.length;
  output[op++] = (il) & 0xff;
  output[op++] = (il >>> 8) & 0xff;
  output[op++] = (il >>> 16) & 0xff;
  output[op++] = (il >>> 24) & 0xff;

  this.ip = ip;

  if (op < output.length) {
    this.output = output = output.subarray(0, op);
  }

  return output;
};

/** @enum {number} */
Zlib.Gzip.OperatingSystem = {
  FAT: 0,
  AMIGA: 1,
  VMS: 2,
  UNIX: 3,
  VM_CMS: 4,
  ATARI_TOS: 5,
  HPFS: 6,
  MACINTOSH: 7,
  Z_SYSTEM: 8,
  CP_M: 9,
  TOPS_20: 10,
  NTFS: 11,
  QDOS: 12,
  ACORN_RISCOS: 13,
  UNKNOWN: 255
};

/** @enum {number} */
Zlib.Gzip.FlagsMask = {
  FTEXT: 0x01,
  FHCRC: 0x02,
  FEXTRA: 0x04,
  FNAME: 0x08,
  FCOMMENT: 0x10
};


/**
* @fileoverview Heap Sort 実装. ハフマン符号化で使用する.
*/

/**
* カスタムハフマン符号で使用するヒープ実装
* @param {number} length ヒープサイズ.
* @constructor
*/
Zlib.Heap = function (length) {
  this.buffer = new (Uint16Array)(length * 2);
  this.length = 0;
};

/**
* 親ノードの index 取得
* @param {number} index 子ノードの index.
* @return {number} 親ノードの index.
*
*/
Zlib.Heap.prototype.getParent = function (index) {
  return ((index - 2) / 4 | 0) * 2;
};

/**
* 子ノードの index 取得
* @param {number} index 親ノードの index.
* @return {number} 子ノードの index.
*/
Zlib.Heap.prototype.getChild = function (index) {
  return 2 * index + 2;
};

/**
* Heap に値を追加する
* @param {number} index キー index.
* @param {number} value 値.
* @return {number} 現在のヒープ長.
*/
Zlib.Heap.prototype.push = function (index, value) {
  var current, parent,
    heap = this.buffer,
    swap;

  current = this.length;
  heap[this.length++] = value;
  heap[this.length++] = index;

  // ルートノードにたどり着くまで入れ替えを試みる
  while (current > 0) {
    parent = this.getParent(current);

    // 親ノードと比較して親の方が小さければ入れ替える
    if (heap[current] > heap[parent]) {
      swap = heap[current];
      heap[current] = heap[parent];
      heap[parent] = swap;

      swap = heap[current + 1];
      heap[current + 1] = heap[parent + 1];
      heap[parent + 1] = swap;

      current = parent;
      // 入れ替えが必要なくなったらそこで抜ける
    } else {
      break;
    }
  }

  return this.length;
};

/**
* Heapから一番大きい値を返す
* @return {{index: number, value: number, length: number}} {index: キーindex,
*     value: 値, length: ヒープ長} の Object.
*/
Zlib.Heap.prototype.pop = function () {
  var index, value,
    heap = this.buffer, swap,
    current, parent;

  value = heap[0];
  index = heap[1];

  // 後ろから値を取る
  this.length -= 2;
  heap[0] = heap[this.length];
  heap[1] = heap[this.length + 1];

  parent = 0;
  // ルートノードから下がっていく
  while (true) {
    current = this.getChild(parent);

    // 範囲チェック
    if (current >= this.length) {
      break;
    }

    // 隣のノードと比較して、隣の方が値が大きければ隣を現在ノードとして選択
    if (current + 2 < this.length && heap[current + 2] > heap[current]) {
      current += 2;
    }

    // 親ノードと比較して親の方が小さい場合は入れ替える
    if (heap[current] > heap[parent]) {
      swap = heap[parent];
      heap[parent] = heap[current];
      heap[current] = swap;

      swap = heap[parent + 1];
      heap[parent + 1] = heap[current + 1];
      heap[current + 1] = swap;
    } else {
      break;
    }

    parent = current;
  }

  return { index: index, value: value, length: this.length };
};


/* vim:set expandtab ts=2 sw=2 tw=80: */

/**
* @fileoverview Deflate (RFC1951) 符号化アルゴリズム実装.
*/


/**
* Raw Deflate 実装
*
* @constructor
* @param {!(Array.<number>|Uint8Array)} input 符号化する対象のバッファ.
* @param {Object=} opt_params option parameters.
*
* typed array が使用可能なとき、outputBuffer が Array は自動的に Uint8Array に
* 変換されます.
* 別のオブジェクトになるため出力バッファを参照している変数などは
* 更新する必要があります.
*/
Zlib.RawDeflate = function (input, opt_params) {
  /** @type {Zlib.RawDeflate.CompressionType} */
  this.compressionType = Zlib.RawDeflate.CompressionType.DYNAMIC;
  /** @type {number} */
  this.lazy = 0;
  /** @type {!(Array.<number>|Uint32Array)} */
  this.freqsLitLen;
  /** @type {!(Array.<number>|Uint32Array)} */
  this.freqsDist;
  /** @type {!(Array.<number>|Uint8Array)} */
  this.input =
    (input instanceof Array) ? new Uint8Array(input) : input;
  /** @type {!(Array.<number>|Uint8Array)} output output buffer. */
  this.output;
  /** @type {number} pos output buffer position. */
  this.op = 0;

  // option parameters
  if (opt_params) {
    if (opt_params['lazy']) {
      this.lazy = opt_params['lazy'];
    }
    if (typeof opt_params['compressionType'] === 'number') {
      this.compressionType = opt_params['compressionType'];
    }
    if (opt_params['outputBuffer']) {
      this.output =
        (opt_params['outputBuffer'] instanceof Array) ?
          new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];
    }
    if (typeof opt_params['outputIndex'] === 'number') {
      this.op = opt_params['outputIndex'];
    }
  }

  if (!this.output) {
    this.output = new (Uint8Array)(0x8000);
  }
};

/**
* @enum {number}
*/
Zlib.RawDeflate.CompressionType = {
  NONE: 0,
  FIXED: 1,
  DYNAMIC: 2,
  RESERVED: 3
};


/**
* LZ77 の最小マッチ長
* @const
* @type {number}
*/
Zlib.RawDeflate.Lz77MinLength = 3;

/**
* LZ77 の最大マッチ長
* @const
* @type {number}
*/
Zlib.RawDeflate.Lz77MaxLength = 258;

/**
* LZ77 のウィンドウサイズ
* @const
* @type {number}
*/
Zlib.RawDeflate.WindowSize = 0x8000;

/**
* 最長の符号長
* @const
* @type {number}
*/
Zlib.RawDeflate.MaxCodeLength = 16;

/**
* ハフマン符号の最大数値
* @const
* @type {number}
*/
Zlib.RawDeflate.HUFMAX = 286;

/**
* 固定ハフマン符号の符号化テーブル
* @const
* @type {Array.<Array.<number, number>>}
*/
Zlib.RawDeflate.FixedHuffmanTable = (function () {
  var table = [], i;

  for (i = 0; i < 288; i++) {
    switch (true) {
      case (i <= 143): table.push([i + 0x030, 8]); break;
      case (i <= 255): table.push([i - 144 + 0x190, 9]); break;
      case (i <= 279): table.push([i - 256 + 0x000, 7]); break;
      case (i <= 287): table.push([i - 280 + 0x0C0, 8]); break;
      default:
        throw 'invalid literal: ' + i;
    }
  }

  return table;
})();

/**
* DEFLATE ブロックの作成
* @return {!(Array.<number>|Uint8Array)} 圧縮済み byte array.
*/
Zlib.RawDeflate.prototype.compress = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var blockArray;
  /** @type {number} */
  var position;
  /** @type {number} */
  var length;

  var input = this.input;

  // compression
  switch (this.compressionType) {
    case Zlib.RawDeflate.CompressionType.NONE:
      // each 65535-Byte (length header: 16-bit)
      for (position = 0, length = input.length; position < length;) {
        blockArray = input.subarray(position, position + 0xffff);
        position += blockArray.length;
        this.makeNocompressBlock(blockArray, (position === length));
      }
      break;
    case Zlib.RawDeflate.CompressionType.FIXED:
      this.output = this.makeFixedHuffmanBlock(input, true);
      this.op = this.output.length;
      break;
    case Zlib.RawDeflate.CompressionType.DYNAMIC:
      this.output = this.makeDynamicHuffmanBlock(input, true);
      this.op = this.output.length;
      break;
    default:
      throw 'invalid compression type';
  }

  return this.output;
};

/**
* 非圧縮ブロックの作成
* @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
* @param {!boolean} isFinalBlock 最後のブロックならばtrue.
* @return {!(Array.<number>|Uint8Array)} 非圧縮ブロック byte array.
*/
Zlib.RawDeflate.prototype.makeNocompressBlock =
  function (blockArray, isFinalBlock) {
    /** @type {number} */
    var bfinal;
    /** @type {Zlib.RawDeflate.CompressionType} */
    var btype;
    /** @type {number} */
    var len;
    /** @type {number} */
    var nlen;

    var output = this.output;
    var op = this.op;

    // expand buffer
    {
      output = new Uint8Array(this.output.buffer);
      while (output.length <= op + blockArray.length + 5) {
        output = new Uint8Array(output.length << 1);
      }
      output.set(this.output);
    }

    // header
    bfinal = isFinalBlock ? 1 : 0;
    btype = Zlib.RawDeflate.CompressionType.NONE;
    output[op++] = (bfinal) | (btype << 1);

    // length
    len = blockArray.length;
    nlen = (~len + 0x10000) & 0xffff;
    output[op++] = len & 0xff;
    output[op++] = (len >>> 8) & 0xff;
    output[op++] = nlen & 0xff;
    output[op++] = (nlen >>> 8) & 0xff;

    // copy buffer
    {
      output.set(blockArray, op);
      op += blockArray.length;
      output = output.subarray(0, op);
    }

    this.op = op;
    this.output = output;

    return output;
  };

/**
* 固定ハフマンブロックの作成
* @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
* @param {!boolean} isFinalBlock 最後のブロックならばtrue.
* @return {!(Array.<number>|Uint8Array)} 固定ハフマン符号化ブロック byte array.
*/
Zlib.RawDeflate.prototype.makeFixedHuffmanBlock =
  function (blockArray, isFinalBlock) {
    /** @type {Zlib.BitStream} */
    var stream = new Zlib.BitStream(new Uint8Array(this.output.buffer), this.op);
    /** @type {number} */
    var bfinal;
    /** @type {Zlib.RawDeflate.CompressionType} */
    var btype;
    /** @type {!(Array.<number>|Uint16Array)} */
    var data;

    // header
    bfinal = isFinalBlock ? 1 : 0;
    btype = Zlib.RawDeflate.CompressionType.FIXED;

    stream.writeBits(bfinal, 1, true);
    stream.writeBits(btype, 2, true);

    data = this.lz77(blockArray);
    this.fixedHuffman(data, stream);

    return stream.finish();
  };

/**
* 動的ハフマンブロックの作成
* @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
* @param {!boolean} isFinalBlock 最後のブロックならばtrue.
* @return {!(Array.<number>|Uint8Array)} 動的ハフマン符号ブロック byte array.
*/
Zlib.RawDeflate.prototype.makeDynamicHuffmanBlock =
  function (blockArray, isFinalBlock) {
    /** @type {Zlib.BitStream} */
    var stream = new Zlib.BitStream(new Uint8Array(this.output.buffer), this.op);
    /** @type {number} */
    var bfinal;
    /** @type {Zlib.RawDeflate.CompressionType} */
    var btype;
    /** @type {!(Array.<number>|Uint16Array)} */
    var data;
    /** @type {number} */
    var hlit;
    /** @type {number} */
    var hdist;
    /** @type {number} */
    var hclen;
    /** @const @type {Array.<number>} */
    var hclenOrder =
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    /** @type {!(Array.<number>|Uint8Array)} */
    var litLenLengths;
    /** @type {!(Array.<number>|Uint16Array)} */
    var litLenCodes;
    /** @type {!(Array.<number>|Uint8Array)} */
    var distLengths;
    /** @type {!(Array.<number>|Uint16Array)} */
    var distCodes;
    /** @type {{
     *   codes: !(Array.<number>|Uint32Array),
     *   freqs: !(Array.<number>|Uint8Array)
     * }} */
    var treeSymbols;
    /** @type {!(Array.<number>|Uint8Array)} */
    var treeLengths;
    /** @type {Array} */
    var transLengths = new Array(19);
    /** @type {!(Array.<number>|Uint16Array)} */
    var treeCodes;
    /** @type {number} */
    var code;
    /** @type {number} */
    var bitlen;
    /** @type {number} */
    var i;
    /** @type {number} */
    var il;

    // header
    bfinal = isFinalBlock ? 1 : 0;
    btype = Zlib.RawDeflate.CompressionType.DYNAMIC;

    stream.writeBits(bfinal, 1, true);
    stream.writeBits(btype, 2, true);

    data = this.lz77(blockArray);

    // リテラル・長さ, 距離のハフマン符号と符号長の算出
    litLenLengths = this.getLengths_(this.freqsLitLen, 15);
    litLenCodes = this.getCodesFromLengths_(litLenLengths);
    distLengths = this.getLengths_(this.freqsDist, 7);
    distCodes = this.getCodesFromLengths_(distLengths);

    // HLIT, HDIST の決定
    for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) { }
    for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) { }

    // HCLEN
    treeSymbols =
      this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);
    treeLengths = this.getLengths_(treeSymbols.freqs, 7);
    for (i = 0; i < 19; i++) {
      transLengths[i] = treeLengths[hclenOrder[i]];
    }
    for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) { }

    treeCodes = this.getCodesFromLengths_(treeLengths);

    // 出力
    stream.writeBits(hlit - 257, 5, true);
    stream.writeBits(hdist - 1, 5, true);
    stream.writeBits(hclen - 4, 4, true);
    for (i = 0; i < hclen; i++) {
      stream.writeBits(transLengths[i], 3, true);
    }

    // ツリーの出力
    for (i = 0, il = treeSymbols.codes.length; i < il; i++) {
      code = treeSymbols.codes[i];

      stream.writeBits(treeCodes[code], treeLengths[code], true);

      // extra bits
      if (code >= 16) {
        i++;
        switch (code) {
          case 16: bitlen = 2; break;
          case 17: bitlen = 3; break;
          case 18: bitlen = 7; break;
          default:
            throw 'invalid code: ' + code;
        }

        stream.writeBits(treeSymbols.codes[i], bitlen, true);
      }
    }

    this.dynamicHuffman(
      data,
      [litLenCodes, litLenLengths],
      [distCodes, distLengths],
      stream
    );

    return stream.finish();
  };


/**
* 動的ハフマン符号化(カスタムハフマンテーブル)
* @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
* @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
* @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
*/
Zlib.RawDeflate.prototype.dynamicHuffman =
  function (dataArray, litLen, dist, stream) {
    /** @type {number} */
    var index;
    /** @type {number} */
    var length;
    /** @type {number} */
    var literal;
    /** @type {number} */
    var code;
    /** @type {number} */
    var litLenCodes;
    /** @type {number} */
    var litLenLengths;
    /** @type {number} */
    var distCodes;
    /** @type {number} */
    var distLengths;

    litLenCodes = litLen[0];
    litLenLengths = litLen[1];
    distCodes = dist[0];
    distLengths = dist[1];

    // 符号を BitStream に書き込んでいく
    for (index = 0, length = dataArray.length; index < length; ++index) {
      literal = dataArray[index];

      // literal or length
      stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);

      // 長さ・距離符号
      if (literal > 256) {
        // length extra
        stream.writeBits(dataArray[++index], dataArray[++index], true);
        // distance
        code = dataArray[++index];
        stream.writeBits(distCodes[code], distLengths[code], true);
        // distance extra
        stream.writeBits(dataArray[++index], dataArray[++index], true);
        // 終端
      } else if (literal === 256) {
        break;
      }
    }

    return stream;
  };

/**
* 固定ハフマン符号化
* @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
* @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
* @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
*/
Zlib.RawDeflate.prototype.fixedHuffman = function (dataArray, stream) {
  /** @type {number} */
  var index;
  /** @type {number} */
  var length;
  /** @type {number} */
  var literal;

  // 符号を BitStream に書き込んでいく
  for (index = 0, length = dataArray.length; index < length; index++) {
    literal = dataArray[index];

    // 符号の書き込み
    Zlib.BitStream.prototype.writeBits.apply(
      stream,
      Zlib.RawDeflate.FixedHuffmanTable[literal]
    );

    // 長さ・距離符号
    if (literal > 0x100) {
      // length extra
      stream.writeBits(dataArray[++index], dataArray[++index], true);
      // distance
      stream.writeBits(dataArray[++index], 5);
      // distance extra
      stream.writeBits(dataArray[++index], dataArray[++index], true);
      // 終端
    } else if (literal === 0x100) {
      break;
    }
  }

  return stream;
};

/**
* マッチ情報
* @param {!number} length マッチした長さ.
* @param {!number} backwardDistance マッチ位置との距離.
* @constructor
*/
Zlib.RawDeflate.Lz77Match = function (length, backwardDistance) {
  /** @type {number} match length. */
  this.length = length;
  /** @type {number} backward distance. */
  this.backwardDistance = backwardDistance;
};

/**
* 長さ符号テーブル.
* [コード, 拡張ビット, 拡張ビット長] の配列となっている.
* @const
* @type {!(Array.<number>|Uint32Array)}
*/
Zlib.RawDeflate.Lz77Match.LengthCodeTable = (function (table) {
  return new Uint32Array(table);
})((function () {
  /** @type {!Array} */
  var table = [];
  /** @type {number} */
  var i;
  /** @type {!Array.<number>} */
  var c;

  for (i = 3; i <= 258; i++) {
    c = code(i);
    table[i] = (c[2] << 24) | (c[1] << 16) | c[0];
  }

  /**
   * @param {number} length lz77 length.
   * @return {!Array.<number>} lz77 codes.
   */
  function code(length) {
    switch (true) {
      case (length === 3): return [257, length - 3, 0]; case (length === 4): return [258, length - 4, 0]; case (length === 5): return [259, length - 5, 0]; case (length === 6): return [260, length - 6, 0]; case (length === 7): return [261, length - 7, 0]; case (length === 8): return [262, length - 8, 0]; case (length === 9): return [263, length - 9, 0]; case (length === 10): return [264, length - 10, 0]; case (length <= 12): return [265, length - 11, 1]; case (length <= 14): return [266, length - 13, 1]; case (length <= 16): return [267, length - 15, 1]; case (length <= 18): return [268, length - 17, 1]; case (length <= 22): return [269, length - 19, 2]; case (length <= 26): return [270, length - 23, 2]; case (length <= 30): return [271, length - 27, 2]; case (length <= 34): return [272, length - 31, 2]; case (length <= 42): return [273, length - 35, 3]; case (length <= 50): return [274, length - 43, 3]; case (length <= 58): return [275, length - 51, 3]; case (length <= 66): return [276, length - 59, 3]; case (length <= 82): return [277, length - 67, 4]; case (length <= 98): return [278, length - 83, 4]; case (length <= 114): return [279, length - 99, 4]; case (length <= 130): return [280, length - 115, 4]; case (length <= 162): return [281, length - 131, 5]; case (length <= 194): return [282, length - 163, 5]; case (length <= 226): return [283, length - 195, 5]; case (length <= 257): return [284, length - 227, 5]; case (length === 258): return [285, length - 258, 0]; default: throw 'invalid length: ' + length;
    }
  }

  return table;
})());

/**
* 距離符号テーブル
* @param {!number} dist 距離.
* @return {!Array.<number>} コード、拡張ビット、拡張ビット長の配列.
* @private
*/
Zlib.RawDeflate.Lz77Match.prototype.getDistanceCode_ = function (dist) {
  /** @type {!Array.<number>} distance code table. */
  var r;

  switch (true) {
    case (dist === 1): r = [0, dist - 1, 0]; break;
    case (dist === 2): r = [1, dist - 2, 0]; break;
    case (dist === 3): r = [2, dist - 3, 0]; break;
    case (dist === 4): r = [3, dist - 4, 0]; break;
    case (dist <= 6): r = [4, dist - 5, 1]; break;
    case (dist <= 8): r = [5, dist - 7, 1]; break;
    case (dist <= 12): r = [6, dist - 9, 2]; break;
    case (dist <= 16): r = [7, dist - 13, 2]; break;
    case (dist <= 24): r = [8, dist - 17, 3]; break;
    case (dist <= 32): r = [9, dist - 25, 3]; break;
    case (dist <= 48): r = [10, dist - 33, 4]; break;
    case (dist <= 64): r = [11, dist - 49, 4]; break;
    case (dist <= 96): r = [12, dist - 65, 5]; break;
    case (dist <= 128): r = [13, dist - 97, 5]; break;
    case (dist <= 192): r = [14, dist - 129, 6]; break;
    case (dist <= 256): r = [15, dist - 193, 6]; break;
    case (dist <= 384): r = [16, dist - 257, 7]; break;
    case (dist <= 512): r = [17, dist - 385, 7]; break;
    case (dist <= 768): r = [18, dist - 513, 8]; break;
    case (dist <= 1024): r = [19, dist - 769, 8]; break;
    case (dist <= 1536): r = [20, dist - 1025, 9]; break;
    case (dist <= 2048): r = [21, dist - 1537, 9]; break;
    case (dist <= 3072): r = [22, dist - 2049, 10]; break;
    case (dist <= 4096): r = [23, dist - 3073, 10]; break;
    case (dist <= 6144): r = [24, dist - 4097, 11]; break;
    case (dist <= 8192): r = [25, dist - 6145, 11]; break;
    case (dist <= 12288): r = [26, dist - 8193, 12]; break;
    case (dist <= 16384): r = [27, dist - 12289, 12]; break;
    case (dist <= 24576): r = [28, dist - 16385, 13]; break;
    case (dist <= 32768): r = [29, dist - 24577, 13]; break;
    default: throw 'invalid distance';
  }

  return r;
};

/**
* マッチ情報を LZ77 符号化配列で返す.
* なお、ここでは以下の内部仕様で符号化している
* [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]
* @return {!Array.<number>} LZ77 符号化 byte array.
*/
Zlib.RawDeflate.Lz77Match.prototype.toLz77Array = function () {
  /** @type {number} */
  var length = this.length;
  /** @type {number} */
  var dist = this.backwardDistance;
  /** @type {Array} */
  var codeArray = [];
  /** @type {number} */
  var pos = 0;
  /** @type {!Array.<number>} */
  var code;

  // length
  code = Zlib.RawDeflate.Lz77Match.LengthCodeTable[length];
  codeArray[pos++] = code & 0xffff;
  codeArray[pos++] = (code >> 16) & 0xff;
  codeArray[pos++] = code >> 24;

  // distance
  code = this.getDistanceCode_(dist);
  codeArray[pos++] = code[0];
  codeArray[pos++] = code[1];
  codeArray[pos++] = code[2];

  return codeArray;
};

/**
* LZ77 実装
* @param {!(Array.<number>|Uint8Array)} dataArray LZ77 符号化するバイト配列.
* @return {!(Array.<number>|Uint16Array)} LZ77 符号化した配列.
*/
Zlib.RawDeflate.prototype.lz77 = function (dataArray) {
  /** @type {number} input position */
  var position;
  /** @type {number} input length */
  var length;
  /** @type {number} loop counter */
  var i;
  /** @type {number} loop limiter */
  var il;
  /** @type {number} chained-hash-table key */
  var matchKey;
  /** @type {Object.<number, Array.<number>>} chained-hash-table */
  var table = {};
  /** @const @type {number} */
  var windowSize = Zlib.RawDeflate.WindowSize;
  /** @type {Array.<number>} match list */
  var matchList;
  /** @type {Zlib.RawDeflate.Lz77Match} longest match */
  var longestMatch;
  /** @type {Zlib.RawDeflate.Lz77Match} previous longest match */
  var prevMatch;
  /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */
  var lz77buf = new Uint16Array(dataArray.length * 2);
  /** @type {number} lz77 output buffer pointer */
  var pos = 0;
  /** @type {number} lz77 skip length */
  var skipLength = 0;
  /** @type {!(Array.<number>|Uint32Array)} */
  var freqsLitLen = new (Uint32Array)(286);
  /** @type {!(Array.<number>|Uint32Array)} */
  var freqsDist = new (Uint32Array)(30);
  /** @type {number} */
  var lazy = this.lazy;
  /** @type {*} temporary variable */
  var tmp;
  freqsLitLen[256] = 1; // EOB の最低出現回数は 1

  /**
   * マッチデータの書き込み
   * @param {Zlib.RawDeflate.Lz77Match} match LZ77 Match data.
   * @param {!number} offset スキップ開始位置(相対指定).
   * @private
   */
  function writeMatch(match, offset) {
    /** @type {Array.<number>} */
    var lz77Array = match.toLz77Array();
    /** @type {number} */
    var i;
    /** @type {number} */
    var il;

    for (i = 0, il = lz77Array.length; i < il; ++i) {
      lz77buf[pos++] = lz77Array[i];
    }
    freqsLitLen[lz77Array[0]]++;
    freqsDist[lz77Array[3]]++;
    skipLength = match.length + offset - 1;
    prevMatch = null;
  }

  // LZ77 符号化
  for (position = 0, length = dataArray.length; position < length; ++position) {
    // ハッシュキーの作成
    for (matchKey = 0, i = 0, il = Zlib.RawDeflate.Lz77MinLength; i < il; ++i) {
      if (position + i === length) {
        break;
      }
      matchKey = (matchKey << 8) | dataArray[position + i];
    }

    // テーブルが未定義だったら作成する
    if (table[matchKey] === void 0) { table[matchKey] = []; }
    matchList = table[matchKey];

    // skip
    if (skipLength-- > 0) {
      matchList.push(position);
      continue;
    }

    // マッチテーブルの更新 (最大戻り距離を超えているものを削除する)
    while (matchList.length > 0 && position - matchList[0] > windowSize) {
      matchList.shift();
    }

    // データ末尾でマッチしようがない場合はそのまま流しこむ
    if (position + Zlib.RawDeflate.Lz77MinLength >= length) {
      if (prevMatch) {
        writeMatch(prevMatch, -1);
      }

      for (i = 0, il = length - position; i < il; ++i) {
        tmp = dataArray[position + i];
        lz77buf[pos++] = tmp;
        ++freqsLitLen[tmp];
      }
      break;
    }

    // マッチ候補から最長のものを探す
    if (matchList.length > 0) {
      longestMatch = this.searchLongestMatch_(dataArray, position, matchList);

      if (prevMatch) {
        // 現在のマッチの方が前回のマッチよりも長い
        if (prevMatch.length < longestMatch.length) {
          // write previous literal
          tmp = dataArray[position - 1];
          lz77buf[pos++] = tmp;
          ++freqsLitLen[tmp];

          // write current match
          writeMatch(longestMatch, 0);
        } else {
          // write previous match
          writeMatch(prevMatch, -1);
        }
      } else if (longestMatch.length < lazy) {
        prevMatch = longestMatch;
      } else {
        writeMatch(longestMatch, 0);
      }
      // 前回マッチしていて今回マッチがなかったら前回のを採用
    } else if (prevMatch) {
      writeMatch(prevMatch, -1);
    } else {
      tmp = dataArray[position];
      lz77buf[pos++] = tmp;
      ++freqsLitLen[tmp];
    }

    matchList.push(position); // マッチテーブルに現在の位置を保存
  }

  // 終端処理
  lz77buf[pos++] = 256;
  freqsLitLen[256]++;
  this.freqsLitLen = freqsLitLen;
  this.freqsDist = freqsDist;

  return /** @type {!(Uint16Array|Array.<number>)} */ (
    lz77buf.subarray(0, pos)
  );
};

/**
* マッチした候補の中から最長一致を探す
* @param {!Object} data plain data byte array.
* @param {!number} position plain data byte array position.
* @param {!Array.<number>} matchList 候補となる位置の配列.
* @return {!Zlib.RawDeflate.Lz77Match} 最長かつ最短距離のマッチオブジェクト.
* @private
*/
Zlib.RawDeflate.prototype.searchLongestMatch_ =
  function (data, position, matchList) {
    var match,
      currentMatch,
      matchMax = 0, matchLength,
      i, j, l, dl = data.length;

    // 候補を後ろから 1 つずつ絞り込んでゆく
    permatch:
    for (i = 0, l = matchList.length; i < l; i++) {
      match = matchList[l - i - 1];
      matchLength = Zlib.RawDeflate.Lz77MinLength;

      // 前回までの最長一致を末尾から一致検索する
      if (matchMax > Zlib.RawDeflate.Lz77MinLength) {
        for (j = matchMax; j > Zlib.RawDeflate.Lz77MinLength; j--) {
          if (data[match + j - 1] !== data[position + j - 1]) {
            continue permatch;
          }
        }
        matchLength = matchMax;
      }

      // 最長一致探索
      while (matchLength < Zlib.RawDeflate.Lz77MaxLength &&
        position + matchLength < dl &&
        data[match + matchLength] === data[position + matchLength]) {
        ++matchLength;
      }

      // マッチ長が同じ場合は後方を優先
      if (matchLength > matchMax) {
        currentMatch = match;
        matchMax = matchLength;
      }

      // 最長が確定したら後の処理は省略
      if (matchLength === Zlib.RawDeflate.Lz77MaxLength) {
        break;
      }
    }

    return new Zlib.RawDeflate.Lz77Match(matchMax, position - currentMatch);
  };

/**
* Tree-Transmit Symbols の算出
* reference: PuTTY Deflate implementation
* @param {number} hlit HLIT.
* @param {!(Array.<number>|Uint8Array)} litlenLengths リテラルと長さ符号の符号長配列.
* @param {number} hdist HDIST.
* @param {!(Array.<number>|Uint8Array)} distLengths 距離符号の符号長配列.
* @return {{
*   codes: !(Array.<number>|Uint32Array),
*   freqs: !(Array.<number>|Uint8Array)
* }} Tree-Transmit Symbols.
*/
Zlib.RawDeflate.prototype.getTreeSymbols_ =
  function (hlit, litlenLengths, hdist, distLengths) {
    var src = new (Uint32Array)(hlit + hdist),
      i, j, runLength, l,
      result = new (Uint32Array)(286 + 30),
      nResult,
      rpt,
      freqs = new (Uint8Array)(19);

    j = 0;
    for (i = 0; i < hlit; i++) {
      src[j++] = litlenLengths[i];
    }
    for (i = 0; i < hdist; i++) {
      src[j++] = distLengths[i];
    }

    // 符号化
    nResult = 0;
    for (i = 0, l = src.length; i < l; i += j) {
      // Run Length Encoding
      for (j = 1; i + j < l && src[i + j] === src[i]; ++j) { }

      runLength = j;

      if (src[i] === 0) {
        // 0 の繰り返しが 3 回未満ならばそのまま
        if (runLength < 3) {
          while (runLength-- > 0) {
            result[nResult++] = 0;
            freqs[0]++;
          }
        } else {
          while (runLength > 0) {
            // 繰り返しは最大 138 までなので切り詰める
            rpt = (runLength < 138 ? runLength : 138);

            if (rpt > runLength - 3 && rpt < runLength) {
              rpt = runLength - 3;
            }

            // 3-10 回 -> 17
            if (rpt <= 10) {
              result[nResult++] = 17;
              result[nResult++] = rpt - 3;
              freqs[17]++;
              // 11-138 回 -> 18
            } else {
              result[nResult++] = 18;
              result[nResult++] = rpt - 11;
              freqs[18]++;
            }

            runLength -= rpt;
          }
        }
      } else {
        result[nResult++] = src[i];
        freqs[src[i]]++;
        runLength--;

        // 繰り返し回数が3回未満ならばランレングス符号は要らない
        if (runLength < 3) {
          while (runLength-- > 0) {
            result[nResult++] = src[i];
            freqs[src[i]]++;
          }
          // 3 回以上ならばランレングス符号化
        } else {
          while (runLength > 0) {
            // runLengthを 3-6 で分割
            rpt = (runLength < 6 ? runLength : 6);

            if (rpt > runLength - 3 && rpt < runLength) {
              rpt = runLength - 3;
            }

            result[nResult++] = 16;
            result[nResult++] = rpt - 3;
            freqs[16]++;

            runLength -= rpt;
          }
        }
      }
    }

    return {
      codes:
        result.subarray(0, nResult),
      freqs: freqs
    };
  };

/**
* ハフマン符号の長さを取得する
* @param {!(Array.<number>|Uint8Array|Uint32Array)} freqs 出現カウント.
* @param {number} limit 符号長の制限.
* @return {!(Array.<number>|Uint8Array)} 符号長配列.
* @private
*/
Zlib.RawDeflate.prototype.getLengths_ = function (freqs, limit) {
  /** @type {number} */
  var nSymbols = freqs.length;
  /** @type {Zlib.Heap} */
  var heap = new Zlib.Heap(2 * Zlib.RawDeflate.HUFMAX);
  /** @type {!(Array.<number>|Uint8Array)} */
  var length = new (Uint8Array)(nSymbols);
  /** @type {Array} */
  var nodes;
  /** @type {!(Array.<number>|Uint32Array)} */
  var values;
  /** @type {!(Array.<number>|Uint8Array)} */
  var codeLength;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  // ヒープの構築
  for (i = 0; i < nSymbols; ++i) {
    if (freqs[i] > 0) {
      heap.push(i, freqs[i]);
    }
  }
  nodes = new Array(heap.length / 2);
  values = new (Uint32Array)(heap.length / 2);

  // 非 0 の要素が一つだけだった場合は、そのシンボルに符号長 1 を割り当てて終了
  if (nodes.length === 1) {
    length[heap.pop().index] = 1;
    return length;
  }

  // Reverse Package Merge Algorithm による Canonical Huffman Code の符号長決定
  for (i = 0, il = heap.length / 2; i < il; ++i) {
    nodes[i] = heap.pop();
    values[i] = nodes[i].value;
  }
  codeLength = this.reversePackageMerge_(values, values.length, limit);

  for (i = 0, il = nodes.length; i < il; ++i) {
    length[nodes[i].index] = codeLength[i];
  }

  return length;
};

/**
* Reverse Package Merge Algorithm.
* @param {!(Array.<number>|Uint32Array)} freqs sorted probability.
* @param {number} symbols number of symbols.
* @param {number} limit code length limit.
* @return {!(Array.<number>|Uint8Array)} code lengths.
*/
Zlib.RawDeflate.prototype.reversePackageMerge_ = function (freqs, symbols, limit) {
  /** @type {!(Array.<number>|Uint16Array)} */
  var minimumCost = new (Uint16Array)(limit);
  /** @type {!(Array.<number>|Uint8Array)} */
  var flag = new (Uint8Array)(limit);
  /** @type {!(Array.<number>|Uint8Array)} */
  var codeLength = new (Uint8Array)(symbols);
  /** @type {Array} */
  var value = new Array(limit);
  /** @type {Array} */
  var type = new Array(limit);
  /** @type {Array.<number>} */
  var currentPosition = new Array(limit);
  /** @type {number} */
  var excess = (1 << limit) - symbols;
  /** @type {number} */
  var half = (1 << (limit - 1));
  /** @type {number} */
  var i;
  /** @type {number} */
  var j;
  /** @type {number} */
  var t;
  /** @type {number} */
  var weight;
  /** @type {number} */
  var next;

  /**
   * @param {number} j
   */
  function takePackage(j) {
    /** @type {number} */
    var x = type[j][currentPosition[j]];

    if (x === symbols) {
      takePackage(j + 1);
      takePackage(j + 1);
    } else {
      --codeLength[x];
    }

    ++currentPosition[j];
  }

  minimumCost[limit - 1] = symbols;

  for (j = 0; j < limit; ++j) {
    if (excess < half) {
      flag[j] = 0;
    } else {
      flag[j] = 1;
      excess -= half;
    }
    excess <<= 1;
    minimumCost[limit - 2 - j] = (minimumCost[limit - 1 - j] / 2 | 0) + symbols;
  }
  minimumCost[0] = flag[0];

  value[0] = new Array(minimumCost[0]);
  type[0] = new Array(minimumCost[0]);
  for (j = 1; j < limit; ++j) {
    if (minimumCost[j] > 2 * minimumCost[j - 1] + flag[j]) {
      minimumCost[j] = 2 * minimumCost[j - 1] + flag[j];
    }
    value[j] = new Array(minimumCost[j]);
    type[j] = new Array(minimumCost[j]);
  }

  for (i = 0; i < symbols; ++i) {
    codeLength[i] = limit;
  }

  for (t = 0; t < minimumCost[limit - 1]; ++t) {
    value[limit - 1][t] = freqs[t];
    type[limit - 1][t] = t;
  }

  for (i = 0; i < limit; ++i) {
    currentPosition[i] = 0;
  }
  if (flag[limit - 1] === 1) {
    --codeLength[0];
    ++currentPosition[limit - 1];
  }

  for (j = limit - 2; j >= 0; --j) {
    i = 0;
    weight = 0;
    next = currentPosition[j + 1];

    for (t = 0; t < minimumCost[j]; t++) {
      weight = value[j + 1][next] + value[j + 1][next + 1];

      if (weight > freqs[i]) {
        value[j][t] = weight;
        type[j][t] = symbols;
        next += 2;
      } else {
        value[j][t] = freqs[i];
        type[j][t] = i;
        ++i;
      }
    }

    currentPosition[j] = 0;
    if (flag[j] === 1) {
      takePackage(j);
    }
  }

  return codeLength;
};

/**
* 符号長配列からハフマン符号を取得する
* reference: PuTTY Deflate implementation
* @param {!(Array.<number>|Uint8Array)} lengths 符号長配列.
* @return {!(Array.<number>|Uint16Array)} ハフマン符号配列.
* @private
*/
Zlib.RawDeflate.prototype.getCodesFromLengths_ = function (lengths) {
  var codes = new (Uint16Array)(lengths.length),
    count = [],
    startCode = [],
    code = 0, i, il, j, m;

  // Count the codes of each length.
  for (i = 0, il = lengths.length; i < il; i++) {
    count[lengths[i]] = (count[lengths[i]] | 0) + 1;
  }

  // Determine the starting code for each length block.
  for (i = 1, il = Zlib.RawDeflate.MaxCodeLength; i <= il; i++) {
    startCode[i] = code;
    code += count[i] | 0;
    code <<= 1;
  }

  // Determine the code for each symbol. Mirrored, of course.
  for (i = 0, il = lengths.length; i < il; i++) {
    code = startCode[lengths[i]];
    startCode[lengths[i]] += 1;
    codes[i] = 0;

    for (j = 0, m = lengths[i]; j < m; j++) {
      codes[i] = (codes[i] << 1) | (code & 1);
      code >>>= 1;
    }
  }

  return codes;
};


/**
* @param {!(Array.<number>|Uint8Array)} input input buffer.
* @param {Object=} opt_params options.
* @constructor
*/
Zlib.Unzip = function (input, opt_params) {
  opt_params = opt_params || {};
  /** @type {!(Array.<number>|Uint8Array)} */
  this.input =
    ((input instanceof Array)) ?
      new Uint8Array(input) : input;
  /** @type {number} */
  this.ip = 0;
  /** @type {number} */
  this.eocdrOffset;
  /** @type {number} */
  this.numberOfThisDisk;
  /** @type {number} */
  this.startDisk;
  /** @type {number} */
  this.totalEntriesThisDisk;
  /** @type {number} */
  this.totalEntries;
  /** @type {number} */
  this.centralDirectorySize;
  /** @type {number} */
  this.centralDirectoryOffset;
  /** @type {number} */
  this.commentLength;
  /** @type {(Array.<number>|Uint8Array)} */
  this.comment;
  /** @type {Array.<Zlib.Unzip.FileHeader>} */
  this.fileHeaderList;
  /** @type {Object.<string, number>} */
  this.filenameToIndex;
  /** @type {boolean} */
  this.verify = opt_params['verify'] || false;
  /** @type {(Array.<number>|Uint8Array)} */
  this.password = opt_params['password'];
};

Zlib.Unzip.CompressionMethod = Zlib.Zip.CompressionMethod;

/**
* @type {Array.<number>}
* @const
*/
Zlib.Unzip.FileHeaderSignature = Zlib.Zip.FileHeaderSignature;

/**
* @type {Array.<number>}
* @const
*/
Zlib.Unzip.LocalFileHeaderSignature = Zlib.Zip.LocalFileHeaderSignature;

/**
* @type {Array.<number>}
* @const
*/
Zlib.Unzip.CentralDirectorySignature = Zlib.Zip.CentralDirectorySignature;

/**
* @param {!(Array.<number>|Uint8Array)} input input buffer.
* @param {number} ip input position.
* @constructor
*/
Zlib.Unzip.FileHeader = function (input, ip) {
  /** @type {!(Array.<number>|Uint8Array)} */
  this.input = input;
  /** @type {number} */
  this.offset = ip;
  /** @type {number} */
  this.length;
  /** @type {number} */
  this.version;
  /** @type {number} */
  this.os;
  /** @type {number} */
  this.needVersion;
  /** @type {number} */
  this.flags;
  /** @type {number} */
  this.compression;
  /** @type {number} */
  this.time;
  /** @type {number} */
  this.date;
  /** @type {number} */
  this.crc32;
  /** @type {number} */
  this.compressedSize;
  /** @type {number} */
  this.plainSize;
  /** @type {number} */
  this.fileNameLength;
  /** @type {number} */
  this.extraFieldLength;
  /** @type {number} */
  this.fileCommentLength;
  /** @type {number} */
  this.diskNumberStart;
  /** @type {number} */
  this.internalFileAttributes;
  /** @type {number} */
  this.externalFileAttributes;
  /** @type {number} */
  this.relativeOffset;
  /** @type {string} */
  this.filename;
  /** @type {!(Array.<number>|Uint8Array)} */
  this.extraField;
  /** @type {!(Array.<number>|Uint8Array)} */
  this.comment;
};

Zlib.Unzip.FileHeader.prototype.parse = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip = this.offset;

  // central file header signature
  if (input[ip++] !== Zlib.Unzip.FileHeaderSignature[0] ||
    input[ip++] !== Zlib.Unzip.FileHeaderSignature[1] ||
    input[ip++] !== Zlib.Unzip.FileHeaderSignature[2] ||
    input[ip++] !== Zlib.Unzip.FileHeaderSignature[3]) {
    throw new Error('invalid file header signature');
  }

  // version made by
  this.version = input[ip++];
  this.os = input[ip++];

  // version needed to extract
  this.needVersion = input[ip++] | (input[ip++] << 8);

  // general purpose bit flag
  this.flags = input[ip++] | (input[ip++] << 8);

  // compression method
  this.compression = input[ip++] | (input[ip++] << 8);

  // last mod file time
  this.time = input[ip++] | (input[ip++] << 8);

  //last mod file date
  this.date = input[ip++] | (input[ip++] << 8);

  // crc-32
  this.crc32 = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // compressed size
  this.compressedSize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // uncompressed size
  this.plainSize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // file name length
  this.fileNameLength = input[ip++] | (input[ip++] << 8);

  // extra field length
  this.extraFieldLength = input[ip++] | (input[ip++] << 8);

  // file comment length
  this.fileCommentLength = input[ip++] | (input[ip++] << 8);

  // disk number start
  this.diskNumberStart = input[ip++] | (input[ip++] << 8);

  // internal file attributes
  this.internalFileAttributes = input[ip++] | (input[ip++] << 8);

  // external file attributes
  this.externalFileAttributes =
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24);

  // relative offset of local header
  this.relativeOffset = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // file name
  this.filename = String.fromCharCode.apply(null, input.subarray(ip, ip += this.fileNameLength)
  );

  // extra field
  this.extraField = input.subarray(ip, ip += this.extraFieldLength);

  // file comment
  this.comment = input.subarray(ip, ip + this.fileCommentLength);

  this.length = ip - this.offset;
};

/**
* @param {!(Array.<number>|Uint8Array)} input input buffer.
* @param {number} ip input position.
* @constructor
*/
Zlib.Unzip.LocalFileHeader = function (input, ip) {
  /** @type {!(Array.<number>|Uint8Array)} */
  this.input = input;
  /** @type {number} */
  this.offset = ip;
  /** @type {number} */
  this.length;
  /** @type {number} */
  this.needVersion;
  /** @type {number} */
  this.flags;
  /** @type {number} */
  this.compression;
  /** @type {number} */
  this.time;
  /** @type {number} */
  this.date;
  /** @type {number} */
  this.crc32;
  /** @type {number} */
  this.compressedSize;
  /** @type {number} */
  this.plainSize;
  /** @type {number} */
  this.fileNameLength;
  /** @type {number} */
  this.extraFieldLength;
  /** @type {string} */
  this.filename;
  /** @type {!(Array.<number>|Uint8Array)} */
  this.extraField;
};

Zlib.Unzip.LocalFileHeader.Flags = Zlib.Zip.Flags;

Zlib.Unzip.LocalFileHeader.prototype.parse = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip = this.offset;

  // local file header signature
  if (input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[0] ||
    input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[1] ||
    input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[2] ||
    input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[3]) {
    throw new Error('invalid local file header signature');
  }

  // version needed to extract
  this.needVersion = input[ip++] | (input[ip++] << 8);

  // general purpose bit flag
  this.flags = input[ip++] | (input[ip++] << 8);

  // compression method
  this.compression = input[ip++] | (input[ip++] << 8);

  // last mod file time
  this.time = input[ip++] | (input[ip++] << 8);

  //last mod file date
  this.date = input[ip++] | (input[ip++] << 8);

  // crc-32
  this.crc32 = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // compressed size
  this.compressedSize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // uncompressed size
  this.plainSize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // file name length
  this.fileNameLength = input[ip++] | (input[ip++] << 8);

  // extra field length
  this.extraFieldLength = input[ip++] | (input[ip++] << 8);

  // file name
  this.filename = String.fromCharCode.apply(null, input.subarray(ip, ip += this.fileNameLength)
  );

  // extra field
  this.extraField = input.subarray(ip, ip += this.extraFieldLength);

  this.length = ip - this.offset;
};


Zlib.Unzip.prototype.searchEndOfCentralDirectoryRecord = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip;

  for (ip = input.length - 12; ip > 0; --ip) {
    if (input[ip] === Zlib.Unzip.CentralDirectorySignature[0] &&
      input[ip + 1] === Zlib.Unzip.CentralDirectorySignature[1] &&
      input[ip + 2] === Zlib.Unzip.CentralDirectorySignature[2] &&
      input[ip + 3] === Zlib.Unzip.CentralDirectorySignature[3]) {
      this.eocdrOffset = ip;
      return;
    }
  }

  throw new Error('End of Central Directory Record not found');
};

Zlib.Unzip.prototype.parseEndOfCentralDirectoryRecord = function () {
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip;

  if (!this.eocdrOffset) {
    this.searchEndOfCentralDirectoryRecord();
  }
  ip = this.eocdrOffset;

  // signature
  if (input[ip++] !== Zlib.Unzip.CentralDirectorySignature[0] ||
    input[ip++] !== Zlib.Unzip.CentralDirectorySignature[1] ||
    input[ip++] !== Zlib.Unzip.CentralDirectorySignature[2] ||
    input[ip++] !== Zlib.Unzip.CentralDirectorySignature[3]) {
    throw new Error('invalid signature');
  }

  // number of this disk
  this.numberOfThisDisk = input[ip++] | (input[ip++] << 8);

  // number of the disk with the start of the central directory
  this.startDisk = input[ip++] | (input[ip++] << 8);

  // total number of entries in the central directory on this disk
  this.totalEntriesThisDisk = input[ip++] | (input[ip++] << 8);

  // total number of entries in the central directory
  this.totalEntries = input[ip++] | (input[ip++] << 8);

  // size of the central directory
  this.centralDirectorySize = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // offset of start of central directory with respect to the starting disk number
  this.centralDirectoryOffset = (
    (input[ip++]) | (input[ip++] << 8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // .ZIP file comment length
  this.commentLength = input[ip++] | (input[ip++] << 8);

  // .ZIP file comment
  this.comment = input.subarray(ip, ip + this.commentLength);
};

Zlib.Unzip.prototype.parseFileHeader = function () {
  /** @type {Array.<Zlib.Unzip.FileHeader>} */
  var filelist = [];
  /** @type {Object.<string, number>} */
  var filetable = {};
  /** @type {number} */
  var ip;
  /** @type {Zlib.Unzip.FileHeader} */
  var fileHeader;
  /*: @type {number} */
  var i;
  /*: @type {number} */
  var il;

  if (this.fileHeaderList) {
    return;
  }

  if (this.centralDirectoryOffset === void 0) {
    this.parseEndOfCentralDirectoryRecord();
  }
  ip = this.centralDirectoryOffset;

  for (i = 0, il = this.totalEntries; i < il; ++i) {
    fileHeader = new Zlib.Unzip.FileHeader(this.input, ip);
    fileHeader.parse();
    ip += fileHeader.length;
    filelist[i] = fileHeader;
    filetable[fileHeader.filename] = i;
  }

  if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {
    throw new Error('invalid file header size');
  }

  this.fileHeaderList = filelist;
  this.filenameToIndex = filetable;
};

/**
* @param {number} index file header index.
* @param {Object=} opt_params
* @return {!(Array.<number>|Uint8Array)} file data.
*/
Zlib.Unzip.prototype.getFileData = function (index, opt_params) {
  opt_params = opt_params || {};
  /** @type {!(Array.<number>|Uint8Array)} */
  var input = this.input;
  /** @type {Array.<Zlib.Unzip.FileHeader>} */
  var fileHeaderList = this.fileHeaderList;
  /** @type {Zlib.Unzip.LocalFileHeader} */
  var localFileHeader;
  /** @type {number} */
  var offset;
  /** @type {number} */
  var length;
  /** @type {!(Array.<number>|Uint8Array)} */
  var buffer;
  /** @type {number} */
  var crc32;
  /** @type {Array.<number>|Uint32Array|Object} */
  var key;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  if (!fileHeaderList) {
    this.parseFileHeader();
  }

  if (fileHeaderList[index] === void 0) {
    throw new Error('wrong index');
  }

  offset = fileHeaderList[index].relativeOffset;
  localFileHeader = new Zlib.Unzip.LocalFileHeader(this.input, offset);
  localFileHeader.parse();
  offset += localFileHeader.length;
  length = localFileHeader.compressedSize;

  // decryption
  if ((localFileHeader.flags & Zlib.Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {
    if (!(opt_params['password'] || this.password)) {
      throw new Error('please set password');
    }
    key = this.createDecryptionKey(opt_params['password'] || this.password);

    // encryption header
    for (i = offset, il = offset + 12; i < il; ++i) {
      this.decode(key, input[i]);
    }
    offset += 12;
    length -= 12;

    // decryption
    for (i = offset, il = offset + length; i < il; ++i) {
      input[i] = this.decode(key, input[i]);
    }
  }

  switch (localFileHeader.compression) {
    case Zlib.Unzip.CompressionMethod.STORE:
      buffer = this.input.subarray(offset, offset + length);
      break;
    case Zlib.Unzip.CompressionMethod.DEFLATE:
      buffer = new Zlib.RawInflate(this.input, {
        'index': offset,
        'bufferSize': localFileHeader.plainSize
      }).decompress();
      break;
    default:
      throw new Error('unknown compression type');
  }

  if (this.verify) {
    crc32 = Zlib.CRC32.calc(buffer);
    if (localFileHeader.crc32 !== crc32) {
      throw new Error(
        'wrong crc: file=0x' + localFileHeader.crc32.toString(16) +
        ', data=0x' + crc32.toString(16)
      );
    }
  }

  return buffer;
};

/**
* @return {Array.<string>}
*/
Zlib.Unzip.prototype.getFilenames = function () {
  /** @type {Array.<string>} */
  var filenameList = [];
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;
  /** @type {Array.<Zlib.Unzip.FileHeader>} */
  var fileHeaderList;

  if (!this.fileHeaderList) {
    this.parseFileHeader();
  }
  fileHeaderList = this.fileHeaderList;

  for (i = 0, il = fileHeaderList.length; i < il; ++i) {
    filenameList[i] = fileHeaderList[i].filename;
  }

  return filenameList;
};

/**
* @param {string} filename extract filename.
* @param {Object=} opt_params
* @return {!(Array.<number>|Uint8Array)} decompressed data.
*/
Zlib.Unzip.prototype.decompress = function (filename, opt_params) {
  /** @type {number} */
  var index;

  if (!this.filenameToIndex) {
    this.parseFileHeader();
  }
  index = this.filenameToIndex[filename];

  if (index === void 0) {
    throw new Error(filename + ' not found');
  }

  return this.getFileData(index, opt_params);
};

/**
* @param {(Array.<number>|Uint8Array)} password
*/
Zlib.Unzip.prototype.setPassword = function (password) {
  this.password = password;
};

/**
* @param {(Array.<number>|Uint32Array|Object)} key
* @param {number} n
* @return {number}
*/
Zlib.Unzip.prototype.decode = function (key, n) {
  n ^= this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));
  this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);

  return n;
};

// common method
Zlib.Unzip.prototype.updateKeys = Zlib.Zip.prototype.updateKeys;
Zlib.Unzip.prototype.createDecryptionKey = Zlib.Zip.prototype.createEncryptionKey;
Zlib.Unzip.prototype.getByte = Zlib.Zip.prototype.getByte;

/**
* @fileoverview 雑多な関数群をまとめたモジュール実装.
*/


/**
* Byte String から Byte Array に変換.
* @param {!string} str byte string.
* @return {!Array.<number>} byte array.
*/
Zlib.Util.stringToByteArray = function (str) {
  /** @type {!Array.<(string|number)>} */
  var tmp = str.split('');
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  for (i = 0, il = tmp.length; i < il; i++) {
    tmp[i] = (tmp[i].charCodeAt(0) & 0xff) >>> 0;
  }

  return tmp;
};


/**
* @fileoverview Adler32 checksum 実装.
*/


/**
* Adler32 ハッシュ値の作成
* @param {!(Array|Uint8Array|string)} array 算出に使用する byte array.
* @return {number} Adler32 ハッシュ値.
*/
Zlib.Adler32 = function (array) {
  if (typeof (array) === 'string') {
    array = Zlib.Util.stringToByteArray(array);
  }
  return Zlib.Adler32.update(1, array);
};

/**
* Adler32 ハッシュ値の更新
* @param {number} adler 現在のハッシュ値.
* @param {!(Array|Uint8Array)} array 更新に使用する byte array.
* @return {number} Adler32 ハッシュ値.
*/
Zlib.Adler32.update = function (adler, array) {
  /** @type {number} */
  var s1 = adler & 0xffff;
  /** @type {number} */
  var s2 = (adler >>> 16) & 0xffff;
  /** @type {number} array length */
  var len = array.length;
  /** @type {number} loop length (don't overflow) */
  var tlen;
  /** @type {number} array index */
  var i = 0;

  while (len > 0) {
    tlen = len > Zlib.Adler32.OptimizationParameter ?
      Zlib.Adler32.OptimizationParameter : len;
    len -= tlen;
    do {
      s1 += array[i++];
      s2 += s1;
    } while (--tlen);

    s1 %= 65521;
    s2 %= 65521;
  }

  return ((s2 << 16) | s1) >>> 0;
};

/**
* Adler32 最適化パラメータ
* 現状では 1024 程度が最適.
* @see http://jsperf.com/adler-32-simple-vs-optimized/3
* @define {number}
*/
Zlib.Adler32.OptimizationParameter = 1024;




/**
* ビットストリーム
* @constructor
* @param {!(Array|Uint8Array)=} buffer output buffer.
* @param {number=} bufferPosition start buffer pointer.
*/
Zlib.BitStream = function (buffer, bufferPosition) {
  /** @type {number} buffer index. */
  this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;
  /** @type {number} bit index. */
  this.bitindex = 0;
  /** @type {!(Array|Uint8Array)} bit-stream output buffer. */
  this.buffer = buffer instanceof (Uint8Array) ?
    buffer :
    new (Uint8Array)(Zlib.BitStream.DefaultBlockSize);

  // 入力された index が足りなかったら拡張するが、倍にしてもダメなら不正とする
  if (this.buffer.length * 2 <= this.index) {
    throw new Error("invalid index");
  } else if (this.buffer.length <= this.index) {
    this.expandBuffer();
  }
};

/**
* デフォルトブロックサイズ.
* @const
* @type {number}
*/
Zlib.BitStream.DefaultBlockSize = 0x8000;

/**
* expand buffer.
* @return {!(Array|Uint8Array)} new buffer.
*/
Zlib.BitStream.prototype.expandBuffer = function () {
  /** @type {!(Array|Uint8Array)} old buffer. */
  var oldbuf = this.buffer;
  /** @type {number} loop limiter. */
  var il = oldbuf.length;
  /** @type {!(Array|Uint8Array)} new buffer. */
  var buffer =
    new (Uint8Array)(il << 1);

  // copy buffer
  {
    buffer.set(oldbuf);
  }

  return (this.buffer = buffer);
};


/**
* 数値をビットで指定した数だけ書き込む.
* @param {number} number 書き込む数値.
* @param {number} n 書き込むビット数.
* @param {boolean=} reverse 逆順に書き込むならば true.
*/
Zlib.BitStream.prototype.writeBits = function (number, n, reverse) {
  var buffer = this.buffer;
  var index = this.index;
  var bitindex = this.bitindex;

  /** @type {number} current octet. */
  var current = buffer[index];
  /** @type {number} loop counter. */
  var i;

  /**
   * 32-bit 整数のビット順を逆にする
   * @param {number} n 32-bit integer.
   * @return {number} reversed 32-bit integer.
   * @private
   */
  function rev32_(n) {
    return (Zlib.BitStream.ReverseTable[n & 0xFF] << 24) |
      (Zlib.BitStream.ReverseTable[n >>> 8 & 0xFF] << 16) |
      (Zlib.BitStream.ReverseTable[n >>> 16 & 0xFF] << 8) |
      Zlib.BitStream.ReverseTable[n >>> 24 & 0xFF];
  }

  if (reverse && n > 1) {
    number = n > 8 ?
      rev32_(number) >> (32 - n) :
      Zlib.BitStream.ReverseTable[number] >> (8 - n);
  }

  // Byte 境界を超えないとき
  if (n + bitindex < 8) {
    current = (current << n) | number;
    bitindex += n;
    // Byte 境界を超えるとき
  } else {
    for (i = 0; i < n; ++i) {
      current = (current << 1) | ((number >> n - i - 1) & 1);

      // next byte
      if (++bitindex === 8) {
        bitindex = 0;
        buffer[index++] = Zlib.BitStream.ReverseTable[current];
        current = 0;

        // expand
        if (index === buffer.length) {
          buffer = this.expandBuffer();
        }
      }
    }
  }
  buffer[index] = current;

  this.buffer = buffer;
  this.bitindex = bitindex;
  this.index = index;
};


/**
* ストリームの終端処理を行う
* @return {!(Array|Uint8Array)} 終端処理後のバッファを byte array で返す.
*/
Zlib.BitStream.prototype.finish = function () {
  var buffer = this.buffer;
  var index = this.index;

  /** @type {!(Array|Uint8Array)} output buffer. */
  var output;

  // bitindex が 0 の時は余分に index が進んでいる状態
  if (this.bitindex > 0) {
    buffer[index] <<= 8 - this.bitindex;
    buffer[index] = Zlib.BitStream.ReverseTable[buffer[index]];
    index++;
  }

  // array truncation
  {
    output = buffer.subarray(0, index);
  }

  return output;
};

/**
* 0-255 のビット順を反転したテーブル
* @const
* @type {!(Uint8Array|Array.<number>)}
*/
Zlib.BitStream.ReverseTable = (function (table) {
  return table;
})((function () {
  /** @type {!(Array|Uint8Array)} reverse table. */
  var table = new (Uint8Array)(256);
  /** @type {number} loop counter. */
  var i;

  // generate
  for (i = 0; i < 256; ++i) {
    table[i] = (function (n) {
      var r = n;
      var s = 7;

      for (n >>>= 1; n; n >>>= 1) {
        r <<= 1;
        r |= n & 1;
        --s;
      }

      return (r << s & 0xff) >>> 0;
    })(i);
  }

  return table;
})());

/**
* CRC32 ハッシュ値を取得
* @param {!(Array.<number>|Uint8Array)} data data byte array.
* @param {number=} pos data position.
* @param {number=} length data length.
* @return {number} CRC32.
*/
Zlib.CRC32.calc = function (data, pos, length) {
  return Zlib.CRC32.update(data, 0, pos, length);
};

/**
* CRC32ハッシュ値を更新
* @param {!(Array.<number>|Uint8Array)} data data byte array.
* @param {number} crc CRC32.
* @param {number=} pos data position.
* @param {number=} length data length.
* @return {number} CRC32.
*/
Zlib.CRC32.update = function (data, crc, pos, length) {
  var table = Zlib.CRC32.Table;
  var i = (typeof pos === 'number') ? pos : (pos = 0);
  var il = (typeof length === 'number') ? length : data.length;

  crc ^= 0xffffffff;

  // loop unrolling for performance
  for (i = il & 7; i--; ++pos) {
    crc = (crc >>> 8) ^ table[(crc ^ data[pos]) & 0xff];
  }
  for (i = il >> 3; i--; pos += 8) {
    crc = (crc >>> 8) ^ table[(crc ^ data[pos]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 1]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 2]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 3]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 4]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 5]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 6]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 7]) & 0xff];
  }

  return (crc ^ 0xffffffff) >>> 0;
};

/**
* @param {number} num
* @param {number} crc
* @returns {number}
*/
Zlib.CRC32.single = function (num, crc) {
  return (Zlib.CRC32.Table[(num ^ crc) & 0xff] ^ (num >>> 8)) >>> 0;
};

/**
* @type {Array.<number>}
* @const
* @private
*/
Zlib.CRC32.Table_ = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
  0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
  0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
  0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
  0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
  0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
  0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
  0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
  0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
  0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
  0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
  0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
  0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
  0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
  0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
  0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
  0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
  0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
];

/**
* @type {!(Array.<number>|Uint32Array)} CRC-32 Table.
* @const
*/
Zlib.CRC32.Table = new Uint32Array(Zlib.CRC32.Table_);

/**
* @fileoverview Deflate (RFC1951) 実装.
* Deflateアルゴリズム本体は Zlib.RawDeflate で実装されている.
*/

/**
* Zlib Deflate
* @constructor
* @param {!(Array|Uint8Array)} input 符号化する対象の byte array.
* @param {Object=} opt_params option parameters.
*/
Zlib.Deflate = function (input, opt_params) {
  /** @type {!(Array|Uint8Array)} */
  this.input = input;
  /** @type {!(Array|Uint8Array)} */
  this.output =
    new (Uint8Array)(Zlib.Deflate.DefaultBufferSize);
  /** @type {Zlib.Deflate.CompressionType} */
  this.compressionType = Zlib.Deflate.CompressionType.DYNAMIC;
  /** @type {Zlib.RawDeflate} */
  this.rawDeflate;
  /** @type {Object} */
  var rawDeflateOption = {};
  /** @type {string} */
  var prop;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (typeof opt_params['compressionType'] === 'number') {
      this.compressionType = opt_params['compressionType'];
    }
  }

  // copy options
  for (prop in opt_params) {
    rawDeflateOption[prop] = opt_params[prop];
  }

  // set raw-deflate output buffer
  rawDeflateOption['outputBuffer'] = this.output;

  this.rawDeflate = new Zlib.RawDeflate(this.input, rawDeflateOption);
};

/**
* @const
* @type {number} デフォルトバッファサイズ.
*/
Zlib.Deflate.DefaultBufferSize = 0x8000;

/**
* @enum {number}
*/
Zlib.Deflate.CompressionType = Zlib.RawDeflate.CompressionType;

/**
* 直接圧縮に掛ける.
* @param {!(Array|Uint8Array)} input target buffer.
* @param {Object=} opt_params option parameters.
* @return {!(Array|Uint8Array)} compressed data byte array.
*/
Zlib.Deflate.compress = function (input, opt_params) {
  return (new Zlib.Deflate(input, opt_params)).compress();
};

/**
* Deflate Compression.
* @return {!(Array|Uint8Array)} compressed data byte array.
*/
Zlib.Deflate.prototype.compress = function () {
  /** @type {Zlib.CompressionMethod} */
  var cm;
  /** @type {number} */
  var cinfo;
  /** @type {number} */
  var cmf;
  /** @type {number} */
  var flg;
  /** @type {number} */
  var fcheck;
  /** @type {number} */
  var fdict;
  /** @type {number} */
  var flevel;
  /** @type {number} */
  var adler;
  /** @type {!(Array|Uint8Array)} */
  var output;
  /** @type {number} */
  var pos = 0;

  output = this.output;

  // Compression Method and Flags
  cm = Zlib.CompressionMethod.DEFLATE;
  switch (cm) {
    case Zlib.CompressionMethod.DEFLATE:
      cinfo = Math.LOG2E * Math.log(Zlib.RawDeflate.WindowSize) - 8;
      break;
    default:
      throw new Error('invalid compression method');
  }
  cmf = (cinfo << 4) | cm;
  output[pos++] = cmf;

  // Flags
  fdict = 0;
  switch (cm) {
    case Zlib.CompressionMethod.DEFLATE:
      switch (this.compressionType) {
        case Zlib.Deflate.CompressionType.NONE: flevel = 0; break;
        case Zlib.Deflate.CompressionType.FIXED: flevel = 1; break;
        case Zlib.Deflate.CompressionType.DYNAMIC: flevel = 2; break;
        default: throw new Error('unsupported compression type');
      }
      break;
    default:
      throw new Error('invalid compression method');
  }
  flg = (flevel << 6) | (fdict << 5);
  fcheck = 31 - (cmf * 256 + flg) % 31;
  flg |= fcheck;
  output[pos++] = flg;

  // Adler-32 checksum
  adler = Zlib.Adler32(this.input);

  this.rawDeflate.op = pos;
  output = this.rawDeflate.compress();
  pos = output.length;

  {
    // subarray 分を元にもどす
    output = new Uint8Array(output.buffer);
    // expand buffer
    if (output.length <= pos + 4) {
      this.output = new Uint8Array(output.length + 4);
      this.output.set(output);
      output = this.output;
    }
    output = output.subarray(0, pos + 4);
  }

  // adler32
  output[pos++] = (adler >> 24) & 0xff;
  output[pos++] = (adler >> 16) & 0xff;
  output[pos++] = (adler >> 8) & 0xff;
  output[pos++] = (adler) & 0xff;

  return output;
};

const isNode$3 =
  typeof process !== 'undefined' &&
  process.versions != null &&
  process.versions.node != null;


const crossFetch = isNode$3 ? require("node-fetch") : fetch;

class BrowserLocalFile {

  constructor(blob) {
    this.file = blob;
  }

  async read(position, length) {
    const file = this.file;
    if (position !== undefined) {
      return file.slice(position, position + length).arrayBuffer()

    } else {
      return file.arrayBuffer()

    }
  }
}

const isNode$2 = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;

let fs;
let fsOpen;
let fsRead;

if (isNode$2) {
  const util = require('util');
  fs = require('fs');
  fsOpen = fs && util.promisify(fs.open);
  fsRead = fs && util.promisify(fs.read);
}

class NodeLocalFile {

  constructor(args) {
    this.path = args.path;
  }


  async read(position, length) {

    const buffer = Buffer.alloc(length);
    const fd = await fsOpen(this.path, 'r');
    const result = await fsRead(fd, buffer, 0, length, position);

    fs.close(fd, function (error) {
      // TODO Do something with error
    });

    //TODO -- compare result.bytesRead with length
    const b = result.buffer;
    const arrayBuffer = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);
    return arrayBuffer
  }
}

const isNode$1 = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;

class RemoteFile {

  constructor(args) {
    this.config = args;
    this.url = mapUrl(args.path || args.url);
  }


  async read(position, length) {

    length = Math.ceil(length);
    const headers = this.config.headers || {};
    const rangeString = "bytes=" + position + "-" + (position + length - 1);
    headers['Range'] = rangeString;

    let url = this.url.slice();    // slice => copy
    if (isNode$1) {
      headers['User-Agent'] = 'straw';
    } else {
      if (this.config.oauthToken) {
        const token = resolveToken(this.config.oauthToken);
        headers['Authorization'] = `Bearer ${token}`;
      }
      navigator.vendor.indexOf("Apple") == 0 && /\sSafari\//.test(navigator.userAgent);
      const isChrome = navigator.userAgent.indexOf('Chrome') > -1;
      const isAmazonV4Signed = this.url.indexOf("X-Amz-Signature") > -1;

      if (isChrome && !isAmazonV4Signed) {
        url = addParameter(url, "randomSeed", Math.random().toString(36));
      }
    }

    if (this.config.apiKey) {
      url = addParameter(url, "key", this.config.apiKey);
    }

    const response = await crossFetch(url, {
      method: 'GET',
      headers: headers,
      redirect: 'follow',
      mode: 'cors',

    });

    const status = response.status;

    if (status >= 400) {
      console.error(`${status}  ${this.config.url}`);
      const err = Error(response.statusText);
      err.code = status;
      throw err
    } else {
      return response.arrayBuffer();
    }

    /**
     * token can be a string, a function that returns a string, or a function that returns a Promise for a string
     * @param token
     * @returns {Promise<*>}
     */
    async function resolveToken(token) {
      if (typeof token === 'function') {
        return await Promise.resolve(token())    // Normalize the result to a promise, since we don't know what the function returns
      } else {
        return token
      }
    }

  }
}


function mapUrl(url) {

  if (url.includes("//www.dropbox.com")) {
    return url.replace("//www.dropbox.com", "//dl.dropboxusercontent.com");
  } else if (url.startsWith("ftp://ftp.ncbi.nlm.nih.gov")) {
    return url.replace("ftp://", "https://")
  } else {
    return url
  }
}


function addParameter(url, name, value) {
  const paramSeparator = url.includes("?") ? "&" : "?";
  return url + paramSeparator + name + "=" + value;
}

class ThrottledFile {

  constructor(file, rateLimiter) {
    this.file = file;
    this.rateLimiter = rateLimiter;
  }


  async read(position, length) {

    const file = this.file;
    const rateLimiter = this.rateLimiter;

    return new Promise(function (fulfill, reject) {
      rateLimiter.limiter(async function (f) {
        try {
          const result = await f.read(position, length);
          fulfill(result);
        } catch (e) {
          reject(e);
        }
      })(file);
    })
  }
}

class RateLimiter {

  constructor(wait) {
    this.wait = wait === undefined ? 100 : wait;

    this.isCalled = false;
    this.calls = [];
  }


  limiter(fn) {

    const self = this;

    let caller = function () {

      if (self.calls.length && !self.isCalled) {
        self.isCalled = true;
        self.calls.shift().call();
        setTimeout(function () {
          self.isCalled = false;
          caller();
        }, self.wait);
      }
    };

    return function () {
      self.calls.push(fn.bind(this, ...arguments));
      caller();
    };
  }

}

class BufferedFile {

  constructor(args) {
    this.file = args.file;
    this.size = args.size || 64000;
    this.position = 0;
    this.bufferStart = 0;
    this.bufferLength = 0;
    this.buffer = undefined;
  }


  async read(position, length) {

    const start = position;
    const end = position + length;
    const bufferStart = this.bufferStart;
    const bufferEnd = this.bufferStart + this.bufferLength;


    if (length > this.size) {
      // Request larger than max buffer size,  pass through to underlying file
      //console.log("0")
      this.buffer = undefined;
      this.bufferStart = 0;
      this.bufferLength = 0;
      return this.file.read(position, length)
    }

    if (start >= bufferStart && end <= bufferEnd) {
      // Request within buffer bounds
      //console.log("1")
      const sliceStart = start - bufferStart;
      const sliceEnd = sliceStart + length;
      return this.buffer.slice(sliceStart, sliceEnd)
    }

    else if (start < bufferStart && end > bufferStart) {
      // Overlap left, here for completness but this is an unexpected case in straw.  We don't adjust the buffer.
      //console.log("2")
      const l1 = bufferStart - start;
      const a1 = await this.file.read(position, l1);
      const l2 = length - l1;
      if (l2 > 0) {
        //this.buffer = await this.file.read(bufferStart, this.size)
        const a2 = this.buffer.slice(0, l2);
        return concatBuffers(a1, a2)
      } else {
        return a1
      }

    }

    else if (start < bufferEnd && end > bufferEnd) {
      // Overlap right
      // console.log("3")
      const l1 = bufferEnd - start;
      const sliceStart = this.bufferLength - l1;
      const a1 = this.buffer.slice(sliceStart, this.bufferLength);

      const l2 = length - l1;
      if (l2 > 0) {
        try {
          this.buffer = await this.file.read(bufferEnd, this.size);
          this.bufferStart = bufferEnd;
          this.bufferLength = this.buffer.byteLength;
          const a2 = this.buffer.slice(0, l2);
          return concatBuffers(a1, a2)
        } catch (e) {
          // A "unsatisfiable range" error is expected here if we overlap past the end of file
          if (e.code && e.code === 416) {
            return a1
          }
          else {
            throw e
          }
        }

      } else {
        return a1
      }

    }

    else {
      // No overlap with buffer
      // console.log("4")
      this.buffer = await this.file.read(position, this.size);
      this.bufferStart = position;
      this.bufferLength = this.buffer.byteLength;
      return this.buffer.slice(0, length)
    }

  }

}

/**
* concatenates 2 array buffers.
* Credit: https://gist.github.com/72lions/4528834
*
* @private
* @param {ArrayBuffers} buffer1 The first buffer.
* @param {ArrayBuffers} buffer2 The second buffer.
* @return {ArrayBuffers} The new ArrayBuffer created out of the two.
*/
var concatBuffers = function (buffer1, buffer2) {
  var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
};

// TODO -- big endian

const BinaryParser = function (dataView, littleEndian) {

  this.littleEndian = littleEndian !== undefined ? littleEndian : true;
  this.position = 0;
  this.view = dataView;
  this.length = dataView.byteLength;
};

BinaryParser.prototype.available = function () {
  return this.length - this.position;
};

BinaryParser.prototype.remLength = function () {
  return this.length - this.position;
};

BinaryParser.prototype.hasNext = function () {
  return this.position < this.length - 1;
};

BinaryParser.prototype.getByte = function () {
  var retValue = this.view.getUint8(this.position, this.littleEndian);
  this.position++;
  return retValue;
};

BinaryParser.prototype.getShort = function () {

  var retValue = this.view.getInt16(this.position, this.littleEndian);
  this.position += 2;
  return retValue;
};

BinaryParser.prototype.getUShort = function () {

  // var byte1 = this.getByte(),
  //     byte2 = this.getByte(),
  //     retValue = ((byte2 << 24 >>> 16) + (byte1 << 24 >>> 24));
  //     return retValue;

  //
  var retValue = this.view.getUint16(this.position, this.littleEndian);
  this.position += 2;
  return retValue;
};


BinaryParser.prototype.getInt = function () {

  var retValue = this.view.getInt32(this.position, this.littleEndian);
  this.position += 4;
  return retValue;
};


BinaryParser.prototype.getUInt = function () {
  var retValue = this.view.getUint32(this.position, this.littleEndian);
  this.position += 4;
  return retValue;
};

BinaryParser.prototype.getLong = function () {

  // DataView doesn't support long. So we'll try manually

  var b = [];
  b[0] = this.view.getUint8(this.position);
  b[1] = this.view.getUint8(this.position + 1);
  b[2] = this.view.getUint8(this.position + 2);
  b[3] = this.view.getUint8(this.position + 3);
  b[4] = this.view.getUint8(this.position + 4);
  b[5] = this.view.getUint8(this.position + 5);
  b[6] = this.view.getUint8(this.position + 6);
  b[7] = this.view.getUint8(this.position + 7);

  var value = 0;
  if (this.littleEndian) {
    for (var i = b.length - 1; i >= 0; i--) {
      value = (value * 256) + b[i];
    }
  } else {
    for (var i = 0; i < b.length; i++) {
      value = (value * 256) + b[i];
    }
  }


  this.position += 8;
  return value;
};

BinaryParser.prototype.getString = function (len) {

  var s = "";
  var c;
  while ((c = this.view.getUint8(this.position++)) != 0) {
    s += String.fromCharCode(c);
    if (len && s.length == len) break;
  }
  return s;
};

BinaryParser.prototype.getFixedLengthString = function (len) {

  var s = "";
  var i;
  var c;
  for (i = 0; i < len; i++) {
    c = this.view.getUint8(this.position++);
    if (c > 0) {
      s += String.fromCharCode(c);
    }
  }
  return s;
};

BinaryParser.prototype.getFixedLengthTrimmedString = function (len) {

  var s = "";
  var i;
  var c;
  for (i = 0; i < len; i++) {
    c = this.view.getUint8(this.position++);
    if (c > 32) {
      s += String.fromCharCode(c);
    }
  }
  return s;
};

BinaryParser.prototype.getFloat = function () {

  var retValue = this.view.getFloat32(this.position, this.littleEndian);
  this.position += 4;
  return retValue;


};

BinaryParser.prototype.getDouble = function () {

  var retValue = this.view.getFloat64(this.position, this.littleEndian);
  this.position += 8;
  return retValue;
};

BinaryParser.prototype.skip = function (n) {

  this.position += n;
  return this.position;
};


/**
* Return a bgzip (bam and tabix) virtual pointer
* TODO -- why isn't 8th byte used ?
* @returns {*}
*/
BinaryParser.prototype.getVPointer = function () {

  var position = this.position,
    offset = (this.view.getUint8(position + 1) << 8) | (this.view.getUint8(position)),
    byte6 = ((this.view.getUint8(position + 6) & 0xff) * 0x100000000),
    byte5 = ((this.view.getUint8(position + 5) & 0xff) * 0x1000000),
    byte4 = ((this.view.getUint8(position + 4) & 0xff) * 0x10000),
    byte3 = ((this.view.getUint8(position + 3) & 0xff) * 0x100),
    byte2 = ((this.view.getUint8(position + 2) & 0xff)),
    block = byte6 + byte5 + byte4 + byte3 + byte2;
  this.position += 8;

  //       if (block == 0 && offset == 0) {
  //           return null;
  //       } else {
  return new VPointer(block, offset);
  //       }
};


function VPointer(block, offset) {
  this.block = block;
  this.offset = offset;
}

VPointer.prototype.isLessThan = function (vp) {
  return this.block < vp.block ||
    (this.block === vp.block && this.offset < vp.offset);
};

VPointer.prototype.isGreaterThan = function (vp) {
  return this.block > vp.block ||
    (this.block === vp.block && this.offset > vp.offset);
};

VPointer.prototype.print = function () {
  return "" + this.block + ":" + this.offset;
};

class MatrixZoomData {

  constructor(chr1, chr2) {

    this.chr1 = chr1;    // chromosome index
    this.chr2 = chr2;
  }

  getKey() {
    return this.chr1.name + "_" + this.chr2.name + "_" + this.zoom.unit + "_" + this.zoom.binSize;
  }

  getBlockNumbers(region1, region2, version) {

    // Verify region chromosomes and swap if neccessary
    if (region1.chr == this.chr2 && region2.chr === this.chr1) {
      const tmp = region1;
      region1 = region2;
      region2 = tmp;
    }

    const sameChr = this.chr1 === this.chr2;
    const binsize = this.zoom.binSize;
    const blockBinCount = this.blockBinCount;
    const blockColumnCount = this.blockColumnCount;
    return (version < 9 || !sameChr) ? getBlockNumbersV8() : getBlockNumbersV9();

    function getBlockNumbersV8() {
      const x1 = region1.start / binsize;
      const x2 = region1.end / binsize;
      const y1 = region2.start / binsize;
      const y2 = region2.end / binsize;

      const col1 = Math.floor(x1 / blockBinCount);
      const col2 = Math.floor((x2 - 1) / blockBinCount);
      const row1 = Math.floor(y1 / blockBinCount);
      const row2 = Math.floor((y2 - 1) / blockBinCount);

      const blockNumbers = [];
      for (let row = row1; row <= row2; row++) {
        for (let column = col1; column <= col2; column++) {
          let blockNumber;
          if (sameChr && row < column) {
            blockNumber = column * blockColumnCount + row;
          } else {
            blockNumber = row * blockColumnCount + column;
          }
          if (!blockNumbers.includes(blockNumber)) {  // possible from transposition
            blockNumbers.push(blockNumber);
          }
        }
      }
      return blockNumbers
    }

    function getBlockNumbersV9() {

      const binX1 = region1.start / binsize;
      const binX2 = region1.end / binsize;
      const binY1 = region2.start / binsize;
      const binY2 = region2.end / binsize;

      // PAD = positionAlongDiagonal (~projected)
      // Depth is axis perpendicular to diagonal; nearer means closer to diagonal
      const translatedLowerPAD = Math.floor((binX1 + binY1) / 2 / blockBinCount);
      const translatedHigherPAD = Math.floor((binX2 + binY2) / 2 / blockBinCount);
      const translatedNearerDepth = Math.floor(Math.log2(1 + Math.abs(binX1 - binY2) / Math.sqrt(2) / blockBinCount));
      const translatedFurtherDepth = Math.floor(Math.log2(1 + Math.abs(binX2 - binY1) / Math.sqrt(2) / blockBinCount));

      // because code above assume above diagonal; but we could be below diagonal
      const containsDiagonal = (binX2 - binY1) * (binX1 - binY2) < 0;   // i.e. sign of (x-y) opposite on 2 corners
      const nearerDepth = containsDiagonal ? 0 : Math.min(translatedNearerDepth, translatedFurtherDepth);
      const furtherDepth = Math.max(translatedNearerDepth, translatedFurtherDepth);

      const blockNumbers = [];
      for (let depth = nearerDepth; depth <= furtherDepth; depth++) {
        for (let pad = translatedLowerPAD; pad <= translatedHigherPAD; pad++) {
          const block_number = depth * blockColumnCount + pad;
          blockNumbers.push(block_number);
        }
      }
      return blockNumbers
    }
  }

  static parseMatrixZoomData(chr1, chr2, dis) {

    const zd = new MatrixZoomData(chr1, chr2);

    const unit = dis.getString();
    const zoomIndex = dis.getInt();
    const sumCounts = dis.getFloat();
    const occupiedCellCount = dis.getFloat();
    const stdDev = dis.getFloat();
    const percent95 = dis.getFloat();
    const binSize = dis.getInt();
    zd.blockBinCount = dis.getInt();
    zd.blockColumnCount = dis.getInt();
    const nBlocks = dis.getInt();

    zd.zoom = { index: zoomIndex, unit: unit, binSize: binSize };

    zd.blockIndex = new StaticBlockIndex(nBlocks, dis);

    const nBins1 = (chr1.size / binSize);
    const nBins2 = (chr2.size / binSize);
    const avgCount = (sumCounts / nBins1) / nBins2;   // <= trying to avoid overflows

    zd.averageCount = avgCount;
    zd.sumCounts = sumCounts;
    zd.stdDev = stdDev;
    zd.occupiedCellCount = occupiedCellCount;
    zd.percent95 = percent95;

    return zd;
  }
}


class StaticBlockIndex {

  constructor(nBlocks, dis) {
    this.blockIndex = {};
    while (nBlocks-- > 0) {
      const blockNumber = dis.getInt();
      const filePosition = dis.getLong();
      const size = dis.getInt();
      this.blockIndex[blockNumber] = { filePosition, size };
    }
  }

  getBlockIndexEntry(blockNumber) {
    return this.blockIndex[blockNumber];
  }
}

class Matrix {

  constructor(chr1, chr2, zoomDataList) {
    this.chr1 = chr1;
    this.chr2 = chr2;
    this.bpZoomData = [];
    this.fragZoomData = [];
    for (let zd of zoomDataList) {
      if (zd.zoom.unit === "BP") {
        this.bpZoomData.push(zd);
      } else {
        this.fragZoomData.push(zd);
      }
    }
  }

  /**
   * Find the best zoom level for the given bin size
   * @param binSize
   * @param unit
   * @returns {number}
   */
  findZoomForResolution(binSize, unit) {
    const zdArray = "FRAG" === unit ? this.fragZoomData : this.bpZoomData;
    for (let i = 1; i < zdArray.length; i++) {
      var zd = zdArray[i];
      if (zd.zoom.binSize < binSize) {
        return i - 1
      }
    }
    return zdArray.length - 1
  }

  /**
   * Fetch zoom data by bin size.  If no matching level exists return undefined.
   *
   * @param unit
   * @param binSize
   * @param zoom
   * @returns {undefined|*}
   */
  getZoomData(binSize, unit) {
    unit = unit || "BP";
    const zdArray = unit === "BP" ? this.bpZoomData : this.fragZoomData;
    for (let i = 0; i < zdArray.length; i++) {
      var zd = zdArray[i];
      if (binSize === zd.zoom.binSize) {
        return zd
      }
    }
    return undefined
  }

  /**
   * Return zoom data by resolution index.
   * @param index
   * @param unit
   * @returns {*}
   */
  getZoomDataByIndex(index, unit) {
    const zdArray = "FRAG" === unit ? this.fragZoomData : this.bpZoomData;
    return zdArray[index]
  }

  static getKey(chrIdx1, chrIdx2) {
    if (chrIdx1 > chrIdx2) {
      const tmp = chrIdx1;
      chrIdx1 = chrIdx2;
      chrIdx2 = tmp;
    }
    return `${chrIdx1}_${chrIdx2}`;
  }

  static parseMatrix(data, chromosomes) {

    const dis = new BinaryParser(new DataView(data));
    const c1 = dis.getInt();     // Should equal chrIdx1
    const c2 = dis.getInt();     // Should equal chrIdx2

    // TODO validate this
    const chr1 = chromosomes[c1];
    const chr2 = chromosomes[c2];

    // # of resolution levels (bp and frags)
    let nResolutions = dis.getInt();
    const zdList = [];

    while (nResolutions-- > 0) {
      const zd = MatrixZoomData.parseMatrixZoomData(chr1, chr2, dis);
      zdList.push(zd);
    }
    return new Matrix(c1, c2, zdList);
  }

}

class ContactRecord {

  constructor(bin1, bin2, counts) {
    this.bin1 = bin1;
    this.bin2 = bin2;
    this.counts = counts;
  };

  getKey() {
    return "" + this.bin1 + "_" + this.bin2;
  }
}

class LRU {
  constructor(max = 10) {
    this.max = max;
    this.map = new Map();
  }

  get(key) {
    let item = this.map.get(key);
    if (item) {
      // refresh key
      this.map.delete(key);
      this.map.set(key, item);
    }
    return item;
  }

  set(key, val) {
    // refresh key
    if (this.map.has(key)) this.map.delete(key);
    // evict oldest
    else if (this.map.size === this.max) {
      this.map.delete(this.first());
    }
    this.map.set(key, val);
  }

  has(key) {
    return this.map.has(key);
  }

  clear() {
    this.map.clear();
  }

  first() {
    return this.map.keys().next().value;
  }
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/
const DOUBLE$1 = 8;

class NormalizationVector {

  constructor(file, filePosition, nValues, dataType) {
    this.file = file;
    this.filePosition = filePosition;
    this.nValues = nValues;
    this.dataType = dataType;
    this.cache = undefined;
  }

  async getValues(start, end) {

    if (!this.cache || start < this.cache.start || end > this.cache.end) {
      const adjustedStart = Math.max(0, start - 1000);
      const adjustedEnd = Math.min(this.nValues, end + 1000);
      const startPosition = this.filePosition + adjustedStart * this.dataType;
      const n = adjustedEnd - adjustedStart;
      const sizeInBytes = n * this.dataType;
      const data = await this.file.read(startPosition, sizeInBytes);
      if (!data) {
        return undefined;
      }
      const parser = new BinaryParser(new DataView(data));

      const values = [];
      for (let i = 0; i < n; i++) {
        values[i] = this.dataType === DOUBLE$1 ? parser.getDouble() : parser.getFloat();

      }
      this.cache = {
        start: adjustedStart,
        end: adjustedEnd,
        values: values
      };
    }

    const sliceStart = start - this.cache.start;
    const sliceEnd = sliceStart + (end - start);
    return this.cache.values.slice(sliceStart, sliceEnd);
  }

  getKey() {
    return NormalizationVector.getKey(this.type, this.chrIdx, this.unit, this.resolution);
  }


  static getNormalizationVectorKey(type, chrIdx, unit, resolution) {
    return type + "_" + chrIdx + "_" + unit + "_" + resolution;
  }
}

const isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
const Short_MIN_VALUE = -32768;
const DOUBLE = 8;
const FLOAT = 4;
const INT = 4;
const GoogleRateLimiter = new RateLimiter(100);


class HicFile {

  constructor(args) {

    this.config = args;

    this.loadFragData = args.loadFragData;
    this.fragmentSitesCache = {};
    this.normVectorCache = new LRU(10);
    this.normalizationTypes = ['NONE'];
    this.matrixCache = new LRU(10);
    this.blockCache = new BlockCache();

    // args may specify an io.File object, a local path (Node only), or a url
    if (args.file) {
      this.file = args.file;
    } else if (args.blob) {
      this.file = new BrowserLocalFile(args.blob);
    } else if (args.url || (args.path && !isNode)) {
      this.url = args.url || this.path;
      this.remote = true;

      // Google drive must be rate limited.  Perhaps all remote files should be rate limited?
      const remoteFile = new RemoteFile(args);
      if (isGoogleDrive(this.url)) {
        this.file = new ThrottledFile(remoteFile, GoogleRateLimiter);
      } else {
        this.file = remoteFile;
      }
    } else if (args.path) {
      // path argument, assumed local file
      this.file = new NodeLocalFile({ path: args.path });

    } else {
      throw Error("Arguments must include file, blob, url, or path")
    }
  }


  async init() {

    if (this.initialized) {
      return;
    } else {
      await this.readHeaderAndFooter();
      // Footer is read with header
      //await this.readFooter()
      this.initialized = true;
    }
  }

  async getVersion() {
    if (this.version === undefined) {
      const data = await this.file.read(0, 128);
      if (!data) {
        return undefined;
      }
      const binaryParser = new BinaryParser(new DataView(data));
      this.magic = binaryParser.getString();
      this.version = binaryParser.getInt();
      return this.version
    } else {
      return this.version
    }
  }

  async getMetaData() {
    await this.init();
    return this.meta
  }

  async readHeaderAndFooter() {

    // Read initial fields magic, version, and footer position
    let data = await this.file.read(0, 16);
    if (!data || data.byteLength === 0) {
      throw Error("File content is empty")
    }
    let binaryParser = new BinaryParser(new DataView(data));
    this.magic = binaryParser.getString();
    this.version = binaryParser.getInt();
    if (this.version < 5) {
      throw Error("Unsupported hic version: " + this.version)
    }
    this.footerPosition = binaryParser.getLong();

    // Read footer and determine file position for body section (i.e. end of header)

    await this.readFooter();

    const bodyPostion = Object.values(this.masterIndex).reduce((min, currentValue) => {
      return Math.min(min, currentValue.start)
    }, Number.MAX_VALUE);

    const remainingSize = bodyPostion - 16;
    data = await this.file.read(16, remainingSize);
    binaryParser = new BinaryParser(new DataView(data));

    this.genomeId = binaryParser.getString();

    if (this.version >= 9) {
      this.normVectorIndexPosition = binaryParser.getLong();
      this.normVectorIndexSize = binaryParser.getLong();
    }

    this.attributes = {};
    let nAttributes = binaryParser.getInt();
    while (nAttributes-- > 0) {
      this.attributes[binaryParser.getString()] = binaryParser.getString();
    }

    this.chromosomes = [];
    this.chromosomeIndexMap = {};
    let nChrs = binaryParser.getInt();
    let i = 0;
    while (nChrs-- > 0) {
      const chr = {
        index: i,
        name: binaryParser.getString(),
        size: this.version < 9 ? binaryParser.getInt() : binaryParser.getLong()
      };
      if (chr.name.toLowerCase() === "all") {
        this.wholeGenomeChromosome = chr;
        this.wholeGenomeResolution = Math.round(chr.size * (1000 / 500));    // Hardcoded in juicer
      }
      this.chromosomes.push(chr);
      this.chromosomeIndexMap[chr.name] = chr.index;
      i++;
    }

    this.bpResolutions = [];
    let nBpResolutions = binaryParser.getInt();
    while (nBpResolutions-- > 0) {
      this.bpResolutions.push(binaryParser.getInt());
    }

    if (this.loadFragData) {
      this.fragResolutions = [];
      let nFragResolutions = binaryParser.getInt();
      if (nFragResolutions > 0) {
        while (nFragResolutions-- > 0) {
          this.fragResolutions.push(binaryParser.getInt());
        }

        // this.sites = [];
        // for(let i=0; i<this.chromosomes.length - 1; i++) {
        //     const chrSites = [];
        //     this.sites.push(chrSites);
        //     let nSites = binaryParser.getInt();
        //     console.log(nSites);
        //     for(let s=0; s<nSites; s++) {
        //         chrSites.push(binaryParser.getInt());
        //     }
        // }
      }
    }

    // Build lookup table for well-known chr aliases
    this.chrAliasTable = {};
    for (let chrName of Object.keys(this.chromosomeIndexMap)) {

      if (chrName.startsWith("chr")) {
        this.chrAliasTable[chrName.substr(3)] = chrName;
      } else if (chrName === "MT") {
        this.chrAliasTable["chrM"] = chrName;
      } else {
        this.chrAliasTable["chr" + chrName] = chrName;
      }
    }


    // Meta data for the API
    this.meta = {
      "version": this.version,
      "genome": this.genomeId,
      "chromosomes": this.chromosomes,
      "resolutions": this.bpResolutions,
    };


  }

  async readFooter() {


    const skip = this.version < 9 ? 8 : 12;
    let data = await this.file.read(this.footerPosition, skip);
    if (!data) {
      return null;
    }

    let binaryParser = new BinaryParser(new DataView(data));
    const nBytes = this.version < 9 ? binaryParser.getInt() : binaryParser.getLong();  // Total size, master index + expected values
    let nEntries = binaryParser.getInt();

    // Estimate the size of the master index. String length of key is unknown, be conservative (100 bytes)

    const miSize = nEntries * (100 + 64 + 32);
    data = await this.file.read(this.footerPosition + skip, Math.min(miSize, nBytes));

    binaryParser = new BinaryParser(new DataView(data));

    this.masterIndex = {};
    while (nEntries-- > 0) {
      const key = binaryParser.getString();
      const pos = binaryParser.getLong();
      const size = binaryParser.getInt();
      this.masterIndex[key] = { start: pos, size: size };
    }

    this.expectedValueVectors = {};

    // Expected values
    // const nExpValues = binaryParser.readInt();
    // while (nExpValues-- > 0) {
    //     type = "NONE";
    //     unit = binaryParser.getString();
    //     binSize = binaryParser.getInt();
    //     nValues = binaryParser.getInt();
    //     values = [];
    //     while (nValues-- > 0) {
    //         values.push(binaryParser.getDouble());
    //     }
    //
    //     nChrScaleFactors = binaryParser.getInt();
    //     normFactors = {};
    //     while (nChrScaleFactors-- > 0) {
    //         normFactors[binaryParser.getInt()] = binaryParser.getDouble();
    //     }
    //
    //     // key = unit + "_" + binSize + "_" + type;
    //     //  NOT USED YET SO DON'T STORE
    //     //  dataset.expectedValueVectors[key] =
    //     //      new ExpectedValueFunction(type, unit, binSize, values, normFactors);
    // }

    // normalized expected values start after expected value.  Add 4 for
    if (this.version > 5) {
      const skip = this.version < 9 ? 4 : 8;
      this.normExpectedValueVectorsPosition = this.footerPosition + skip + nBytes;
    }
    return this;
  };

  async printIndexStats() {

    let totalSize = 0;
    let maxSize = 0;
    let maxKey;
    await await this.init();
    for (let key of Object.keys(this.masterIndex)) {
      const entry = this.masterIndex[key];
      //  console.log(`${key}\t${entry.start}\t${entry.size}`)
      totalSize += entry.size;
      if (entry.size > maxSize) {
        maxSize = entry.size;
        maxKey = key;
      }
    }
    // console.log(`Total size  = ${totalSize}`);
    console.log(`${maxSize}  ${maxKey}  ${this.config.url}`);
  }

  async getMatrix(chrIdx1, chrIdx2) {
    const key = Matrix.getKey(chrIdx1, chrIdx2);
    if (this.matrixCache.has(key)) {
      return this.matrixCache.get(key);
    } else {
      const matrix = await this.readMatrix(chrIdx1, chrIdx2);
      this.matrixCache.set(key, matrix);
      return matrix;
    }
  }

  async readMatrix(chrIdx1, chrIdx2) {

    await this.init();

    if (chrIdx1 > chrIdx2) {
      const tmp = chrIdx1;
      chrIdx1 = chrIdx2;
      chrIdx2 = tmp;
    }

    const key = Matrix.getKey(chrIdx1, chrIdx2);
    const idx = this.masterIndex[key];
    if (!idx) {
      return undefined
    }
    const data = await this.file.read(idx.start, idx.size);
    if (!data) {
      return undefined
    }

    return Matrix.parseMatrix(data, this.chromosomes);

  }

  async getContactRecords(normalization, region1, region2, units, binsize, allRecords = false) {

    await this.init();

    const idx1 = this.chromosomeIndexMap[this.getFileChrName(region1.chr)];
    const idx2 = this.chromosomeIndexMap[this.getFileChrName(region2.chr)];

    const transpose = (idx1 > idx2) || (idx1 === idx2 && region1.start >= region2.end);
    if (transpose) {
      const tmp = region1;
      region1 = region2;
      region2 = tmp;
    }

    const blocks = await this.getBlocks(region1, region2, units, binsize);
    if (!blocks || blocks.length === 0) {
      return []
    }

    const contactRecords = [];
    const x1 = region1.start / binsize;
    const x2 = region1.end / binsize;
    const y1 = region2.start / binsize;
    const y2 = region2.end / binsize;
    const nvX1 = Math.floor(x1);
    const nvX2 = Math.ceil(x2);
    const nvY1 = Math.floor(y1);
    const nvY2 = Math.ceil(y2);
    for (let block of blocks) {
      if (block) { // An undefined block is most likely caused by a base pair range outside the chromosome
        let normVector1;
        let normVector2;
        let isNorm = normalization && normalization !== "NONE";
        const chr1 = this.getFileChrName(region1.chr);
        const chr2 = this.getFileChrName(region2.chr);
        if (isNorm) {
          const nv1 = await this.getNormalizationVector(normalization, chr1, units, binsize);
          const nv2 = (chr1 === chr2) ? nv1 : await this.getNormalizationVector(normalization, chr2, units, binsize);

          if (nv1 && nv2) {
            normVector1 = await nv1.getValues(nvX1, nvX2);
            normVector2 = await nv2.getValues(nvY1, nvY2);
          } else {
            isNorm = false;
            // Raise message and switch pulldown
          }
        }

        for (let rec of block.records) {
          if (allRecords || (rec.bin1 >= x1 && rec.bin1 < x2 && rec.bin2 >= y1 && rec.bin2 < y2)) {
            if (isNorm) {
              const x = rec.bin1;
              const y = rec.bin2;
              const nvnv = normVector1[x - nvX1] * normVector2[y - nvY1];
              if (nvnv !== 0 && !isNaN(nvnv)) {
                const counts = rec.counts / nvnv;
                contactRecords.push(new ContactRecord(x, y, counts));
              }
            } else {
              contactRecords.push(rec);
            }
          }
        }
      }
    }

    return contactRecords;
  }

  async getBlocks(region1, region2, unit, binSize) {

    await this.init();
    const chr1 = this.getFileChrName(region1.chr);
    const chr2 = this.getFileChrName(region2.chr);
    const idx1 = this.chromosomeIndexMap[chr1];
    const idx2 = this.chromosomeIndexMap[chr2];

    if (idx1 === undefined) {
      console.log("No chromosome named: " + region1.chr);
      return []
    }
    if (idx2 === undefined) {
      console.log("No chromosome named: " + region2.chr);
      return []
    }

    const matrix = await this.getMatrix(idx1, idx2);
    if (!matrix) {
      console.log("No matrix for " + region1.chr + "-" + region2.chr);
      return []
    }

    const zd = matrix.getZoomData(binSize, unit);
    if (!zd) {
      let msg = `No data avalailble for resolution: ${binSize}  for map ${region1.chr}-${region2.chr}`;
      throw new Error(msg)
    }

    const blockNumbers = zd.getBlockNumbers(region1, region2, this.version);

    const blocks = [];
    const blockNumbersToQuery = [];
    for (let num of blockNumbers) {
      if (this.blockCache.has(binSize, num)) {
        blocks.push(this.blockCache.get(binSize, num));
      } else {
        blockNumbersToQuery.push(num);
      }
    }

    const promises = blockNumbersToQuery.map(blockNumber => this.readBlock(blockNumber, zd));
    const newBlocks = await Promise.all(promises);
    for (let block of newBlocks) {
      if (block) {
        this.blockCache.set(binSize, block.blockNumber, block);
      }
    }
    return blocks.concat(newBlocks);
  }

  async readBlock(blockNumber, zd) {

    const idx = await zd.blockIndex.getBlockIndexEntry(blockNumber);

    if (!idx) {
      return undefined
    } else {
      let data = await this.file.read(idx.filePosition, idx.size);
      if (!data) {
        return undefined;
      }

      const inflate = new Zlib.Inflate(new Uint8Array(data));
      const plain = inflate.decompress();
      //var plain = zlib.inflateSync(Buffer.from(data))   //.decompress();
      data = plain.buffer;

      const parser = new BinaryParser(new DataView(data));
      const nRecords = parser.getInt();
      const records = [];

      if (this.version < 7) {
        for (let i = 0; i < nRecords; i++) {
          const binX = parser.getInt();
          const binY = parser.getInt();
          const counts = parser.getFloat();
          records.push(new ContactRecord(binX, binY, counts));
        }
      } else {

        const binXOffset = parser.getInt();
        const binYOffset = parser.getInt();

        const useFloatContact = parser.getByte() === 1;
        const useIntXPos = this.version < 9 ? false : parser.getByte() == 1;
        const useIntYPos = this.version < 9 ? false : parser.getByte() == 1;
        const type = parser.getByte();

        if (type === 1) {
          // List-of-rows representation
          const rowCount = useIntYPos ? parser.getInt() : parser.getShort();
          for (let i = 0; i < rowCount; i++) {
            const dy = useIntYPos ? parser.getInt() : parser.getShort();
            const binY = binYOffset + dy;
            const colCount = useIntXPos ? parser.getInt() : parser.getShort();
            for (let j = 0; j < colCount; j++) {
              const dx = useIntXPos ? parser.getInt() : parser.getShort();
              const binX = binXOffset + dx;
              const counts = useFloatContact ? parser.getFloat() : parser.getShort();
              records.push(new ContactRecord(binX, binY, counts));
            }
          }
        } else if (type == 2) {

          const nPts = parser.getInt();
          const w = parser.getShort();

          for (let i = 0; i < nPts; i++) {
            //int idx = (p.y - binOffset2) * w + (p.x - binOffset1);
            const row = Math.floor(i / w);
            const col = i - row * w;
            const bin1 = binXOffset + col;
            const bin2 = binYOffset + row;

            if (useFloatContact) {
              const counts = parser.getFloat();
              if (!isNaN(counts)) {
                records.push(new ContactRecord(bin1, bin2, counts));
              }
            } else {
              const counts = parser.getShort();
              if (counts != Short_MIN_VALUE) {
                records.push(new ContactRecord(bin1, bin2, counts));
              }
            }
          }
        } else {
          throw new Error("Unknown block type: " + type);
        }

      }

      return new Block(blockNumber, zd, records, idx);


    }
  };

  async hasNormalizationVector(type, chr, unit, binSize) {
    await this.init();
    let chrIdx;
    if (Number.isInteger(chr)) {
      chrIdx = chr;
    } else {
      const canonicalName = this.getFileChrName(chr);
      chrIdx = this.chromosomeIndexMap[canonicalName];
    }
    const key = getNormalizationVectorKey(type, chrIdx, unit.toString(), binSize);
    const normVectorIndex = await this.getNormVectorIndex();
    return normVectorIndex && normVectorIndex[key];
  }

  async getNormalizationVector(type, chr, unit, binSize) {

    await this.init();

    let chrIdx;
    if (Number.isInteger(chr)) {
      chrIdx = chr;
    } else {
      const canonicalName = this.getFileChrName(chr);
      chrIdx = this.chromosomeIndexMap[canonicalName];
    }

    const key = getNormalizationVectorKey(type, chrIdx, unit.toString(), binSize);

    if (this.normVectorCache.has(key)) {
      return this.normVectorCache.get(key);
    }

    const normVectorIndex = await this.getNormVectorIndex();

    if (!normVectorIndex) {
      console.log("Normalization vectors not present in this file");
      return undefined
    }

    const idx = normVectorIndex[key];
    if (!idx) {
      // TODO -- alert in browsers
      console.log("Normalization option " + type + " not available at this resolution");
      return undefined;
    }

    const data = await this.file.read(idx.filePosition, 8);

    if (!data) {
      return undefined;
    }

    const parser = new BinaryParser(new DataView(data));
    const nValues = this.version < 9 ? parser.getInt() : parser.getLong();
    const dataType = this.version < 9 ? DOUBLE : FLOAT;
    const filePosition = this.version < 9 ? idx.filePosition + 4 : idx.filePosition + 8;
    const nv = new NormalizationVector(this.file, filePosition, nValues, dataType);
    this.normVectorCache.set(key, nv);
    return nv;

  }

  async getNormVectorIndex() {

    if (this.version < 6) {
      return undefined;
    }

    if (!this.normVectorIndex) {

      // If nvi is not supplied, try reading from remote lambda service
      if (!this.config.nvi && this.remote && this.url) {
        const url = new URL(this.url);
        const key = encodeURIComponent(url.hostname + url.pathname);
        const nviResponse = await crossFetch('https://t5dvc6kn3f.execute-api.us-east-1.amazonaws.com/dev/nvi/' + key);
        if (nviResponse.status === 200) {
          const nvi = await nviResponse.text();
          if (nvi) {
            this.config.nvi = nvi;
          }
        }
      }

      if (this.config.nvi) {
        const nviArray = decodeURIComponent(this.config.nvi).split(",");
        const range = { start: parseInt(nviArray[0]), size: parseInt(nviArray[1]) };
        return this.readNormVectorIndex(range)
      } else {
        try {
          await this.readNormExpectedValuesAndNormVectorIndex();
          return this.normVectorIndex
        } catch (e) {
          if (e.code === "416" || e.code === 416) {
            // This is expected if file does not contain norm vectors
            this.normExpectedValueVectorsPosition = undefined;
          } else {
            console.error(e);
          }
        }
      }
    }

    return this.normVectorIndex
  }

  async getNormalizationOptions() {
    // Normalization options are computed as a side effect of loading the index.  A bit
    // ugly but alternatives are worse.
    await this.getNormVectorIndex();
    return this.normalizationTypes;
  }

  /**
   * Return a promise to load the normalization vector index
   *
   * @param dataset
   * @param range  -- file range {position, size}
   * @returns Promise for the normalization vector index
   */
  async readNormVectorIndex(range) {

    await this.init();

    this.normalizationVectorIndexRange = range;

    const data = await this.file.read(range.start, range.size);

    const binaryParser = new BinaryParser(new DataView(data));

    this.normVectorIndex = {};

    let nEntries = binaryParser.getInt();
    while (nEntries-- > 0) {
      this.parseNormVectorEntry(binaryParser);
    }

    return this.normVectorIndex;

  }

  /**
   * This function is used when the position of the norm vector index is unknown.  We must read through the expected
   * values to find the index
   *
   * @param dataset
   * @returns {Promise}
   */
  async readNormExpectedValuesAndNormVectorIndex() {

    await this.init();

    if (this.normExpectedValueVectorsPosition === undefined) {
      return;
    }

    const nviStart = await this.skipExpectedValues(this.normExpectedValueVectorsPosition);
    let byteCount = INT;

    let data = await this.file.read(nviStart, INT);
    if (data.byteLength === 0) {
      // This is possible if there are no norm vectors.  Its a legal v8 file, though uncommon
      return;
    }
    const binaryParser = new BinaryParser(new DataView(data));
    const nEntries = binaryParser.getInt();
    const sizeEstimate = nEntries * 30;
    const range = { start: nviStart + byteCount, size: sizeEstimate };

    data = await this.file.read(range.start, range.size);
    this.normalizedExpectedValueVectors = {};
    this.normVectorIndex = {};

    // Recursively process entries
    await processEntries.call(this, nEntries, data);

    this.config.nvi = nviStart.toString() + "," + byteCount;

    async function processEntries(nEntries, data) {

      const binaryParser = new BinaryParser(new DataView(data));

      while (nEntries-- > 0) {

        if (binaryParser.available() < 100) {

          nEntries++;   // Reset counter as entry is not processed

          byteCount += binaryParser.position;
          const sizeEstimate = Math.max(1000, nEntries * 30);
          const range = { start: nviStart + byteCount, size: sizeEstimate };
          const data = await this.file.read(range.start, range.size);
          return processEntries.call(this, nEntries, data);
        }

        this.parseNormVectorEntry(binaryParser);

      }
      byteCount += binaryParser.position;
    }
  }

  /**
   * This function is used when the position of the norm vector index is unknown.  We must read through the
   * normalized expected values to find the index
   *
   * @param dataset
   * @returns {Promise}
   */
  async skipExpectedValues(start) {

    const version = this.version;
    const file = new BufferedFile({ file: this.file, size: 256000 });
    const range = { start: start, size: INT };
    const data = await file.read(range.start, range.size);
    const binaryParser = new BinaryParser(new DataView(data));
    const nEntries = binaryParser.getInt();   // Total # of expected value chunks
    if (nEntries === 0) {
      return start + INT;
    } else {
      return parseNext(start + INT, nEntries);
    }     // Skip 4 bytes for int


    async function parseNext(start, nEntries) {

      let range = { start: start, size: 500 };
      let chunkSize = 0;
      let p0 = start;

      let data = await file.read(range.start, range.size);
      let binaryParser = new BinaryParser(new DataView(data));
      binaryParser.getString(); // type
      binaryParser.getString(); // unit
      binaryParser.getInt(); // binSize
      const nValues = version < 9 ? binaryParser.getInt() : binaryParser.getLong();

      chunkSize += binaryParser.position + nValues * (version < 9 ? DOUBLE : FLOAT);

      range = { start: start + chunkSize, size: INT };
      data = await file.read(range.start, range.size);
      binaryParser = new BinaryParser(new DataView(data));
      const nChrScaleFactors = binaryParser.getInt();
      chunkSize += (INT + nChrScaleFactors * (INT + (version < 9 ? DOUBLE : FLOAT)));


      nEntries--;
      if (nEntries === 0) {
        return p0 + chunkSize;
      } else {
        return parseNext(p0 + chunkSize, nEntries);
      }
    }
  }

  getZoomIndexForBinSize(binSize, unit) {

    unit = unit || "BP";

    let resolutionArray;
    if (unit === "BP") {
      resolutionArray = this.bpResolutions;
    } else if (unit === "FRAG") {
      resolutionArray = this.fragResolutions;
    } else {
      throw new Error("Invalid unit: " + unit);
    }

    for (let i = 0; i < resolutionArray.length; i++) {
      if (resolutionArray[i] === binSize) return i;
    }

    return -1;
  }

  parseNormVectorEntry(binaryParser) {
    const type = binaryParser.getString();      //15
    const chrIdx = binaryParser.getInt();       //4
    const unit = binaryParser.getString();      //3
    const binSize = binaryParser.getInt();      //4
    const filePosition = binaryParser.getLong();  //8
    const sizeInBytes = this.version < 9 ? binaryParser.getInt() : binaryParser.getLong();     //4:8
    const key = type + "_" + chrIdx + "_" + unit + "_" + binSize;
    // TODO -- why does this not work?  NormalizationVector.getNormalizationVectorKey(type, chrIdx, unit, binSize);

    if (!this.normalizationTypes.includes(type)) {
      this.normalizationTypes.push(type);
    }
    this.normVectorIndex[key] = { filePosition: filePosition, size: sizeInBytes };
  }

  getFileChrName(chrAlias) {
    if (this.chrAliasTable.hasOwnProperty(chrAlias)) {
      return this.chrAliasTable[chrAlias]
    } else {
      return chrAlias
    }
  }


  // NOTE sties are not currently used
  // async getSites(chrName) {
  //     let sites = this.fragmentSitesCache[chrName];
  //     if (!sites) {
  //         if (this.fragmentSitesIndex) {
  //             const entry = self.fragmentSitesIndex[chrName];
  //             if (entry && entry.nSites > 0) {
  //                 sites = await this.readSites(entry.position, entry.nSites)
  //                 this.fragmentSitesCache[chrName] = sites;
  //             }
  //         }
  //     }
  //     return sites;
  // }
  //

}


function getNormalizationVectorKey(type, chrIdx, unit, resolution) {
  return type + "_" + chrIdx + "_" + unit + "_" + resolution;
}

function isGoogleDrive(url) {
  return url.indexOf("drive.google.com") >= 0 || url.indexOf("www.googleapis.com/drive") > 0
}

class Block {
  constructor(blockNumber, zoomData, records, idx) {
    this.blockNumber = blockNumber;
    this.zoomData = zoomData;
    this.records = records;
    this.idx = idx;
  }
}


class BlockCache {

  constructor() {
    this.resolution = undefined;
    this.map = new LRU(6);
  }

  set(resolution, key, value) {
    if (this.resolution !== resolution) {
      this.map.clear();
    }
    this.resolution = resolution;
    this.map.set(key, value);
  }

  get(resolution, key) {
    return this.resolution === resolution ? this.map.get(key) : undefined;
  }

  has(resolution, key) {
    return this.resolution === resolution && this.map.has(key);
  }
}

class Straw {

  constructor(config) {
    this.config = config;
    this.hicFile = new HicFile(config);
  }

  async getMetaData() {
    return await this.hicFile.getMetaData()
  }

  //straw <NONE/VC/VC_SQRT/KR> <ile> <chr1>[:x1:x2] <chr2>[:y1:y2] <BP/FRAG> <binsize>
  async getContactRecords(normalization, region1, region2, units, binsize) {
    return this.hicFile.getContactRecords(normalization, region1, region2, units, binsize);
  }

  async getNormalizationOptions() {
    return this.hicFile.getNormalizationOptions()
  }

  async getNVI() {
    await this.hicFile.getNormVectorIndex();
    return this.hicFile.config.nvi;
  }

  async printIndexStats() {
    await this.hicFile.printIndexStats();
  }

  getFileChrName(chrAlias) {
    if (this.hicFile.chrAliasTable.hasOwnProperty(chrAlias)) {
      return this.hicFile.chrAliasTable[chrAlias]
    } else {
      return chrAlias
    }
  }
}

/*
* @author Jim Robinson Dec-2020
*/

class IGVRemoteFile {


  constructor(args) {
    this.config = args;
    this.url = args.path || args.url;
  }


  async read(position, length) {

    const range = { start: position, size: length };

    return igvxhr.loadArrayBuffer(this.url, { range });

  }
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2020 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

const knownGenomes = {

  "hg19": [249250621, 243199373, 198022430],
  "hg38": [248956422, 242193529, 198295559],
  "mm10": [195471971, 182113224, 160039680],
  "mm9": [197195432, 181748087, 159599783],
  "dm6": [23513712, 25286936, 28110227]

};

class Dataset {

  constructor(config) {
    this.straw = new Straw(config);
  }

  async init() {

    this.hicFile = this.straw.hicFile;
    await this.hicFile.init();
    this.normalizationTypes = ['NONE'];

    this.genomeId = this.hicFile.genomeId;
    this.chromosomes = this.hicFile.chromosomes;
    this.bpResolutions = this.hicFile.bpResolutions;
    this.wholeGenomeChromosome = this.hicFile.wholeGenomeChromosome;
    this.wholeGenomeResolution = this.hicFile.wholeGenomeResolution;

    // Attempt to determine genomeId if not recognized
    // if (!Object.keys(knownGenomes).includes(this.genomeId)) {
    const tmp = matchGenome(this.chromosomes);
    if (tmp) this.genomeId = tmp;
    //  }
  }

  async getContactRecords(normalization, region1, region2, units, binsize) {
    return this.straw.getContactRecords(normalization, region1, region2, units, binsize)
  }

  async hasNormalizationVector(type, chr, unit, binSize) {
    return this.straw.hicFile.hasNormalizationVector(type, chr, unit, binSize);
  }

  clearCaches() {
    this.colorScaleCache = {};
  }

  async getMatrix(chr1, chr2) {
    return this.hicFile.getMatrix(chr1, chr2)
  }

  getZoomIndexForBinSize(binSize, unit) {
    var i,
      resolutionArray;

    unit = unit || "BP";

    if (unit === "BP") {
      resolutionArray = this.bpResolutions;
    } else if (unit === "FRAG") {
      resolutionArray = this.fragResolutions;
    } else {
      throw new Error("Invalid unit: " + unit);
    }

    for (i = 0; i < resolutionArray.length; i++) {
      if (resolutionArray[i] === binSize) return i;
    }

    return -1;
  }

  getBinSizeForZoomIndex(zoomIndex, unit) {
    var resolutionArray;

    unit = unit || "BP";

    if (unit === "BP") {
      resolutionArray = this.bpResolutions;
    } else if (unit === "FRAG") {
      resolutionArray = this.fragResolutions;
    } else {
      throw new Error("Invalid unit: " + unit);
    }

    return resolutionArray[zoomIndex];
  }

  getChrIndexFromName(chrName) {
    var i;
    for (i = 0; i < this.chromosomes.length; i++) {
      if (chrName === this.chromosomes[i].name) return i;
    }
    return undefined;
  }

  compareChromosomes(otherDataset) {
    const chrs = this.chromosomes;
    const otherChrs = otherDataset.chromosomes;
    if (chrs.length !== otherChrs.length) {
      return false;
    }
    for (let i = 0; i < chrs.length; i++) {
      if (chrs[i].size !== otherChrs[i].size) {
        return false;
      }
    }
    return true;
  }

  isWholeGenome(chrIndex) {
    return (this.wholeGenomeChromosome != null && this.wholeGenomeChromosome.index === chrIndex);
  }

  async getNormVectorIndex() {
    return this.hicFile.getNormVectorIndex()
  }

  async getNormalizationOptions() {
    return this.hicFile.getNormalizationOptions()
  }

  /**
   * Compare 2 datasets for compatibility.  Compatibility is defined as from the same assembly, even if
   * different IDs are used (e.g. GRCh38 vs hg38).
   *
   * Trust the ID for well-known assemblies (hg19, etc).  However, for others compare chromosome lengths
   * as its been observed that uniqueness of ID is not guaranteed.
   *
   * @param d1
   * @param d2
   */
  isCompatible(d2) {
    const id1 = this.genomeId;
    const id2 = d2.genomeId;
    return ((id1 === "hg38" || id1 === "GRCh38") && (id2 === "hg38" || id2 === "GRCh38")) ||
      ((id1 === "hg19" || id1 === "GRCh37") && (id2 === "hg19" || id2 === "GRCh37")) ||
      ((id1 === "mm10" || id1 === "GRCm38") && (id2 === "mm10" || id2 === "GRCm38")) ||
      this.compareChromosomes(d2)
  }

  static async loadDataset(config) {

    // If this is a local file, use the "blob" field for straw
    if (isFile(config.url)) {
      config.blob = config.url;
      delete config.url;
    } else {
      // If this is a google url, add api KEY
      if (isGoogleURL(config.url)) {
        if (isGoogleDriveURL(config.url)) {
          config.url = driveDownloadURL(config.url);
        }
        const copy = Object.assign({}, config);
        config.file = new IGVRemoteFile(copy);
      }
    }

    const dataset = new Dataset(config);
    await dataset.init();
    dataset.url = config.url;
    return dataset
  }
}

function matchGenome(chromosomes) {

  if (chromosomes.length < 4) return undefined;

  const keys = Object.keys(knownGenomes);

  // Find a candidate
  let candidate;
  for (let chr of chromosomes) {
    for (let key of keys) {
      if (knownGenomes[key].includes(chr.size)) {
        candidate = key;
        break;
      }
    }
  }

  // Confirm candidate
  if (candidate) {
    const chrSizes = new Set(chromosomes.map((chr) => chr.size));
    for (let sz of knownGenomes[candidate]) {
      if (!chrSizes.has(sz)) {
        return undefined;
      }
    }
    return candidate;
  } else {
    return undefined;
  }


}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/


/**
* @author Jim Robinson
*/


/**
*
* @param id
* @param chromosomes -- an array of hic.Chromosome objects.
* @constructor
*/
class Genome {
  constructor(id, chromosomes) {

    this.id = id;
    this.chromosomes = chromosomes;
    this.wgChromosomeNames = [];
    this.chromosomeLookupTable = {};

    // Alias for size for igv compatibility
    this.genomeLength = 0;
    for (let c of this.chromosomes) {
      c.bpLength = c.size;
      if ('all' !== c.name.toLowerCase()) {
        this.genomeLength += c.size;
        this.wgChromosomeNames.push(c.name);
      }
    }

    /**
     * Maps chr aliases to the offical name.  Deals with
     * 1 <-> chr1,  chrM <-> MT,  IV <-> chr4, etc.
     * @param str
     */
    var chrAliasTable = {};

    // The standard mappings
    for (let chromosome of chromosomes) {

      const name = chromosome.name;
      if (name.startsWith("arm_")) {
        //Special rule for aidenlab ad-hoc names for dMel
        const officialName = name.substring(4);
        chrAliasTable[officialName] = name;
        chrAliasTable["chr" + officialName] = name;
      } else {
        const alias = name.startsWith("chr") ? name.substring(3) : "chr" + name;
        chrAliasTable[alias] = name;
        if (name === "chrM") chrAliasTable["MT"] = "chrM";
        if (name === "MT") chrAliasTable["chrmM"] = "MT";
      }
      this.chromosomeLookupTable[name.toLowerCase()] = chromosome;
    }

    this.chrAliasTable = chrAliasTable;

  }

  getChromosomeName(str) {
    var chr = this.chrAliasTable[str];
    return chr ? chr : str;
  };

  getChromosome(str) {
    var chrname = this.getChromosomeName(str).toLowerCase();
    return this.chromosomeLookupTable[chrname];
  };

  /**
   * Return the genome coordinate for the give chromosome and position.
   */
  getGenomeCoordinate(chr, bp) {
    return this.getCumulativeOffset(chr.name) + bp;
  };

  getChromsosomeForCoordinate(bp) {
    var i = 0,
      offset = 0,
      l;

    for (i = 1; i < this.chromosomes.length; i++) {
      l = this.chromosomes[i].size;
      if (offset + l > bp) return this.chromosomes[i];
      offset += l;
    }
    return this.chromosomes[this.chromosomes.length - 1];
  }


  /**
   * Return the offset in genome coordinates (kb) of the start of the given chromosome
   */
  getCumulativeOffset(chr) {

    const queryChr = this.getChromosomeName(chr);

    if (this.cumulativeOffsets === undefined) {
      computeCumulativeOffsets.call(this);
    }
    return this.cumulativeOffsets[queryChr];
  }

  // Required for igv.js
  getGenomeLength() {
    return this.genomeLength;
  }
}

function computeCumulativeOffsets() {

  const cumulativeOffsets = {};
  let offset = 0;
  // Skip first chromosome (its chr all).
  for (let chromosome of this.chromosomes) {
    if (chromosome.name === 'all') continue;
    cumulativeOffsets[chromosome.name] = Math.floor(offset);
    offset += (chromosome.size);
  }
  this.cumulativeOffsets = cumulativeOffsets;
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

class State {

  constructor(chr1, chr2, zoom, x, y, width, height, pixelSize, normalization) {

    if (Number.isNaN(pixelSize)) {
      pixelSize = 1;
    }

    if (chr1 !== undefined) {
      if (chr1 <= chr2) {
        this.chr1 = chr1;
        this.chr2 = chr2;
        this.x = x;
        this.y = y;
      } else {
        // Transpose
        this.chr1 = chr2;
        this.chr2 = chr1;
        this.x = y;
        this.y = x;
      }
      this.zoom = zoom;
      this.pixelSize = pixelSize;
      this.width = width;
      this.height = height;

      if ("undefined" === normalization) {
        console.log("No normalization defined !!!");
        normalization = undefined;
      }

      this.normalization = normalization;
    }
  }

  stringify() {
    if (this.normalization) {
      return `${this.chr1},${this.chr2},${this.zoom},${this.x},${this.y},${this.width},${this.height},${this.pixelSize},${this.normalization}`
    } else {
      return `${this.chr1},${this.chr2},${this.zoom},${this.x},${this.y},${this.width},${this.height},${this.pixelSize}`
    }

  }

  clone() {
    return Object.assign(new State(), this);
  }

  equals(state) {
    var s1 = JSON.stringify(this);
    var s2 = JSON.stringify(state);
    return s1 === s2;
  }

  static parse(string) {

    const tokens = string.split(",");

    if (tokens.length <= 7) {

      // Backwards compatibility
      return new State(
        parseInt(tokens[0]),    // chr1
        parseInt(tokens[1]),    // chr2
        parseFloat(tokens[2]), // zoom
        parseFloat(tokens[3]), // x
        parseFloat(tokens[4]), // y
        defaultSize.width,      // width
        defaultSize.height,     // height
        parseFloat(tokens[5]), // pixelSize
        tokens.length > 6 ? tokens[6] : "NONE"   // normalization
      )
    } else {

      return new State(
        parseInt(tokens[0]),    // chr1
        parseInt(tokens[1]),    // chr2
        parseFloat(tokens[2]), // zoom
        parseFloat(tokens[3]), // x
        parseFloat(tokens[4]), // y
        parseInt(tokens[5]), // width
        parseInt(tokens[6]), // height
        parseFloat(tokens[7]), // pixelSize
        tokens.length > 8 ? tokens[8] : "NONE"   // normalization
      )
    }

  }

  static default(configOrUndefined) {

    if (configOrUndefined) {
      return new State(0, 0, 0, 0, 0, configOrUndefined.width, configOrUndefined.height, 1, "NONE")
    } else {
      return new State(0, 0, 0, 0, 0, defaultSize.width, defaultSize.height, 1, "NONE")
    }

  }


}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

async function geneSearch(genomeId, featureName) {

  // Hardcode this for now
  const searchServiceURL = "https://portals.broadinstitute.org/webservices/igv/locus?genome=" + genomeId + "&name=" + featureName;
  const data = await igvxhr.loadString(searchServiceURL);
  var results = parseSearchResults(data);

  if (results.length === 0) {
    //alert('No feature found with name "' + feature + '"');
    return undefined;
  } else {
    // Just take first result for now
    return results[0]
  }
}


function JsAjax(options) {
  let url = options.url
  const method = options.method.toLocaleLowerCase() || 'get'
  const async = options.async != false // default is true
  const data = options.data
  const xhr = new XMLHttpRequest()

  if (options.timeout && options.timeout > 0) {
    xhr.timeout = options.timeout
  }

  return new Promise((resolve, reject) => {
    xhr.ontimeout = () => reject && reject('请求超时')
    xhr.onreadystatechange = () => {
      if (xhr.readyState == 4) {
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
          resolve && resolve(xhr.responseText)
        } else {
          reject && reject()
        }
      }
    }
    xhr.onerror = err => reject && reject(err)

    let paramArr = []
    let encodeData
    if (data instanceof Object) {
      for (let key in data) {
        // 参数拼接需要通过 encodeURIComponent 进行编码
        paramArr.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]))
      }
      encodeData = paramArr.join('&')
    }

    if (method === 'get') {
      // 检测 url 中是否已存在 ? 及其位置
      const index = url.indexOf('?')
      if (index === -1) url += '?'
      else if (index !== url.length - 1) url += '&'
      // 拼接 url
      url += encodeData
    }

    xhr.open(method, url, async)
    if (method === 'get') xhr.send(null)
    else {
      // post 方式需要设置请求头
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8')
      xhr.send(encodeData)
    }
  })
}




function parseSearchResults(data) {

  const lines = splitLines(data);
  const linesTrimmed = [];
  const results = [];

  for (let item of lines) {
    if ("" === item); else {
      linesTrimmed.push(item);
    }
  }

  for (let line of linesTrimmed) {
    // Example result -  EGFR	chr7:55,086,724-55,275,031	refseq
    const tokens = line.split("\t");
    if (tokens.length >= 3) {
      results.push(tokens[1]);
    }
  }

  return results;
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

function check_equal(locus1, locus2) {
  if (locus1 == undefined || locus2 == undefined) return true;
  locus1 = locus1.trim().toLowerCase();
  locus2 = locus2.trim().toLowerCase();
  if (locus1.startsWith('chr')) locus1 = locus1.substring(3, locus1.length);
  if (locus2.startsWith('chr')) locus2 = locus2.substring(3, locus2.length);
  return locus1 == locus2;
}

class LocusGoto {

  constructor(browser, $hic_navbar_container) {

    this.browser = browser;

    const $parent = $hic_navbar_container.find("div[id$='upper-hic-nav-bar-widget-container']");

    this.$container = $("<div>", { class: 'hic-chromosome-goto-container', title: 'Chromosome Goto', id: `hic-chromosome-goto-container-${this.browser.id}` });
    $parent.append(this.$container);
    this.$container.append($("<i>", { class: 'fa fa-search' }));
    this.$resolution_selector = $('<input class ="locus_input" type="text" placeholder="chrx:axis-axis chry:axis-axis">');
    // this.$resolution_selector_button = $(`<button id = 'goto-${this.browser.id}'><i class="fa fa-hand-o-right"></i></button>`,{class: 'hic-chromosome-goto-button'});
    this.$container.append(this.$resolution_selector);
    // this.$container.append(this.$resolution_selector_button);
    this.browser.$resolution_selector = this.$resolution_selector

    this.$resolution_selector.on('keydown', function (e) {
      if (e.keyCode == 13) {
        let _val = $(this).val()
        browser.parseGotoInput(_val);
        $(this).blur();
      }
    })
    this.browser.eventBus.subscribe("LocusChange", this);
  }

  receiveEvent(event) {

    // 移动HiC contact map
    if (event.type === "LocusChange") {
      // 
      // setCurrentBrowser(this.browser);
      let x, y, xy;
      const state = event.data.state || this.browser.state;
      const isWholeGenome = this.browser.dataset.isWholeGenome(state.chr1);
      if (isWholeGenome) {
        xy = 'All';
        call3d(this.browser.id, 0, 0, true, true);
      } else {
        const chr1 = this.browser.dataset.chromosomes[state.chr1];
        const chr2 = this.browser.dataset.chromosomes[state.chr2];
        const bpPerBin = this.browser.dataset.bpResolutions[state.zoom];
        const dimensionsPixels = this.browser.contactMatrixView.getViewDimensions();
        const pixelsPerBin = state.pixelSize;
        const startBP1 = 1 + Math.round(state.x * bpPerBin);
        const startBP2 = 1 + Math.round(state.y * bpPerBin);
        const endBP1 = Math.min(chr1.size, Math.round(((dimensionsPixels.width / pixelsPerBin) * bpPerBin)) + startBP1 - 1);
        const endBP2 = Math.min(chr2.size, Math.round(((dimensionsPixels.height / pixelsPerBin) * bpPerBin)) + startBP2 - 1);
        x = chr1.name + ":" + numberFormatter(startBP1) + "-" + numberFormatter(endBP1)
        y = chr2.name + ":" + numberFormatter(startBP2) + "-" + numberFormatter(endBP2)
        if (this.browser.isDiag || this.browser.contactMatrixView.displayMode === 'AMB') {
          y = x;
        }
        xy = x + ' ' + y;
        call3d(this.browser.id, x, y, true, true);
      }

      this.$resolution_selector.val(xy);


      // 这里触发igv的移动,
      let _id = this.browser.id;
      let igv_selector = $('#igv-goto-input-' + _id);
      let igv_locus = $(igv_selector).val();
      if ($(igv_selector).val() === undefined) return;
      if (xy === 'All') x = 'all';
      if (x.startsWith('chr')) x = x.substring(3, x.length);

      // 为了防止递归调用，需要判断chrx == x 
      if (igv_locus.startsWith('chr')) igv_locus = igv_locus.substring(3, x.length);
      if (igv_locus === x || igv_locus.split('-')[0] === x.split('-')[0]) return;
      let bpPerBin = this.browser.dataset.bpResolutions[state.zoom];
      igv_goto_locus(x, _id, bpPerBin);
    }
  }
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

class ResolutionSelector {

  constructor(browser, $hic_navbar_container) {

    this.browser = browser;

    const $parent = $hic_navbar_container.find("div[id$='upper-hic-nav-bar-widget-container']");

    this.$container = $("<div>", { class: 'hic-resolution-selector-container', title: 'Resolution' });
    $parent.append(this.$container);

    // label container
    this.$label_container = $('<div id="hic-resolution-label-container">');
    this.$container.append(this.$label_container);

    // Resolution (kb)
    this.$label = $("<div>");
    this.$label_container.append(this.$label);
    this.$label.hide();

    // lock/unlock
    this.$resolution_lock = $('<i id="hic-resolution-lock" class="fa fa-unlock" aria-hidden="true">');
    this.$label_container.append(this.$resolution_lock);
    this.$label_container.on('click', () => {
      this.browser.resolutionLocked = !(this.browser.resolutionLocked);
      this.setResolutionLock(this.browser.resolutionLocked);
    });

    this.$resolution_selector = $('<select name="select">');
    this.$container.append(this.$resolution_selector);

    this.$resolution_selector.attr('name', 'resolution_selector');

    this.$resolution_selector.on('change', () => {
      const zoomIndex = parseInt(this.$resolution_selector.val());
      this.browser.setZoom(zoomIndex);
    });


    this.browser.eventBus.subscribe("LocusChange", this);
    this.browser.eventBus.subscribe("MapLoad", this);
    this.browser.eventBus.subscribe("ControlMapLoad", this);
  }

  setResolutionLock(resolutionLocked) {
    this.$resolution_lock.removeClass((true === resolutionLocked) ? 'fa-unlock' : 'fa-lock');
    this.$resolution_lock.addClass((true === resolutionLocked) ? 'fa-lock' : 'fa-unlock');
  }

  receiveEvent(event) {

    const browser = this.browser;

    if (event.type === "LocusChange") {
      if (true === event.data.resolutionChanged) {
        browser.resolutionLocked = false;
        this.setResolutionLock(browser.resolutionLocked);
      }

      if (event.data.chrChanged !== false) {  // Default true
        const isWholeGenome = browser.dataset.isWholeGenome(event.data.state.chr1);
        this.$label.text(isWholeGenome ? 'Resolution (mb)' : 'Resolution (kb)');
        updateResolutions.call(this, browser.state.zoom);
      } else {
        const selectedIndex = browser.state.zoom;
        this.$resolution_selector
          .find('option')
          .filter(function (index) {
            return index === selectedIndex;
          })
          .prop('selected', true);
      }

    } else if (event.type === "MapLoad") {
      browser.resolutionLocked = false;
      this.setResolutionLock(false);
      updateResolutions.call(this, browser.state.zoom);
    } else if (event.type === "ControlMapLoad") {
      updateResolutions.call(this, browser.state.zoom);
    }

    async function updateResolutions(zoomIndex) {

      const resolutions = browser.isWholeGenome() ?
        [{ index: 0, binSize: browser.dataset.wholeGenomeResolution }] :
        browser.getResolutions();
      let htmlString = '';
      for (let resolution of resolutions) {
        const binSize = resolution.binSize;
        const index = resolution.index;
        let divisor;
        let unit;
        if (binSize >= 1e6) {
          divisor = 1e6;
          unit = 'mb';
        } else if (binSize >= 1e3) {
          divisor = 1e3;
          unit = 'kb';
        } else {
          divisor = 1;
          unit = 'bp';
        }
        const pretty = numberFormatter(Math.round(binSize / divisor)) + ' ' + unit;
        const selected = zoomIndex === resolution.index;
        htmlString += '<option' + ' data-resolution=' + binSize.toString() + ' value=' + index + (selected ? ' selected' : '') + '>' + pretty + '</option>';

      }
      this.$resolution_selector.empty();
      this.$resolution_selector.append(htmlString);
    }


  }
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

const defaultColorScaleConfig = { threshold: 2000, r: 25, g: 118, b: 210 };


class ColorScale {

  constructor(scale) {
    this.threshold = scale.threshold;
    this.r = scale.r;
    this.g = scale.g;
    this.b = scale.b;
    this.cache = [];
    this.nbins = 2000;
    this.binsize = this.threshold / this.nbins;
  }

  setThreshold(threshold) {
    this.threshold = threshold;
    this.cache = [];
    this.binsize = this.threshold / this.nbins;
  }

  getThreshold() {
    return this.threshold;
  }

  setColorComponents(components) {
    this.r = components.r;
    this.g = components.g;
    this.b = components.b;
    this.cache = [];
  }

  getColorComponents() {
    return {
      r: this.r,
      g: this.g,
      b: this.b
    }
  }

  equals(cs) {
    return JSON.stringify(this) === JSON.stringify(cs);
  }

  getColor(value) {
    const low = 0;
    const bin = Math.floor(Math.min(this.threshold, value) / this.binsize);
    if (undefined === this.cache[bin]) {
      const alpha = Math.floor(255 * (IGVMath.clamp(value, low, this.threshold) - low) / (this.threshold - low));
      this.cache[bin] = {
        red: this.r,
        green: this.g,
        blue: this.b,
        alpha,
        rgbaString: `rgba(${this.r},${this.g},${this.b}, ${alpha})`
      };
    }
    return this.cache[bin]
  }

  stringify() {
    return "" + this.threshold + ',' + this.r + ',' + this.g + ',' + this.b;
  }

  static parse(string) {

    var pnstr, ratioCS;

    if (string.startsWith("R:")) {
      pnstr = string.substring(2).split(":");
      ratioCS = new RatioColorScale(Number.parseFloat(pnstr[0]));
      ratioCS.positiveScale = foo(pnstr[1]);
      ratioCS.negativeScale = foo(pnstr[2]);
      return ratioCS;
    } else {
      return foo(string);
    }

    function foo(str) {
      var cs, tokens;

      tokens = str.split(",");

      cs = {
        threshold: tokens[0],
        r: tokens[1],
        g: tokens[2],
        b: tokens[3]
      };
      return new ColorScale(cs);
    }
  }
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

const defaultRatioColorScaleConfig = { threshold: 5, positive: { r: 25, g: 118, b: 210 }, negative: { r: 139, g: 94, b: 52 } };


class RatioColorScale {

  constructor(threshold) {

    this.threshold = threshold;

    this.positiveScale = new ColorScale({
      threshold: Math.log(threshold),
      r: 255,
      g: 0,
      b: 0
    });
    this.negativeScale = new ColorScale(
      {
        threshold: Math.log(threshold),
        r: 0,
        g: 0,
        b: 255
      });
  }

  setThreshold(threshold) {
    this.threshold = threshold;
    this.positiveScale.setThreshold(Math.log(threshold));
    this.negativeScale.setThreshold(Math.log(threshold));
  }

  getThreshold() {
    return this.threshold;
  }

  setColorComponents(components, plusOrMinus) {
    if ('-' === plusOrMinus) {
      return this.negativeScale.setColorComponents(components);
    } else {
      return this.positiveScale.setColorComponents(components);
    }
  }

  getColorComponents(plusOrMinus) {

    if ('-' === plusOrMinus) {
      return this.negativeScale.getColorComponents();
    } else {
      return this.positiveScale.getColorComponents();
    }
  }

  getColor(score) {

    var logScore = Math.log(score);

    if (logScore < 0) {
      return this.negativeScale.getColor(-logScore);
    } else {
      return this.positiveScale.getColor(logScore);
    }
  }

  stringify() {
    return "R:" + this.threshold + ":" + this.positiveScale.stringify() + ":" + this.negativeScale.stringify();
  }
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

const DRAG_THRESHOLD = 2;
const DOUBLE_TAP_DIST_THRESHOLD = 20;
const DOUBLE_TAP_TIME_THRESHOLD = 300;

const imageTileDimension = 685;

class ContactMatrixView {


  constructor(browser, $viewport, sweepZoom, scrollbarWidget, colorScale, ratioColorScale, backgroundColor) {


    this.browser = browser;
    this.$viewport = $viewport;
    this.sweepZoom = sweepZoom;
    this.scrollbarWidget = scrollbarWidget;

    // Set initial color scales.  These might be overriden / adjusted via parameters
    this.colorScale = colorScale;

    this.ratioColorScale = ratioColorScale;
    this.diffColorScale = ratioColorScale;

    this.backgroundColor = backgroundColor;
    this.backgroundRGBString = IGVColor.rgbColor(backgroundColor.r, backgroundColor.g, backgroundColor.b);

    this.$canvas = $viewport.find('canvas');
    this.ctx = this.$canvas.get(0).getContext('2d');

    this.$fa_spinner = $viewport.find('.fa-spinner');
    this.spinnerCount = 0;

    this.$x_guide = $viewport.find("div[id$='-x-guide']");
    this.$y_guide = $viewport.find("div[id$='-y-guide']");

    this.displayMode = 'A';
    this.imageTileCache = {};
    this.imageTileCacheKeys = [];
    this.imageTileCacheLimit = 8; //8 is the minimum number required to support A/B cycling
    this.colorScaleThresholdCache = {};


    this.browser.eventBus.subscribe("NormalizationChange", this);
    this.browser.eventBus.subscribe("TrackLoad2D", this);
    this.browser.eventBus.subscribe("TrackState2D", this);
    this.browser.eventBus.subscribe("MapLoad", this);
    this.browser.eventBus.subscribe("ControlMapLoad", this);
    this.browser.eventBus.subscribe("ColorChange", this);

    this.drawsInProgress = new Set();
  }

  setBackgroundColor(rgb) {
    this.backgroundColor = rgb;
    this.backgroundRGBString = IGVColor.rgbColor(rgb.r, rgb.g, rgb.b);
    this.repaint();
  }

  stringifyBackgroundColor() {
    return `${this.backgroundColor.r},${this.backgroundColor.g},${this.backgroundColor.b}`;
  }

  static parseBackgroundColor(rgbString) {
    const [r, g, b] = rgbString.split(",").map(str => parseInt(str));
    return { r, g, b }
  }

  setColorScale(colorScale) {

    switch (this.displayMode) {
      case 'AOB':
      case 'BOA':
        this.ratioColorScale = colorScale;
        break;
      case 'AMB':
        this.diffColorScale = colorScale;
        break;
      default:
        this.colorScale = colorScale;
    }
    this.colorScaleThresholdCache[colorScaleKey(this.browser.state, this.displayMode)] = colorScale.threshold;
  }

  async setColorScaleThreshold(threshold) {
    this.getColorScale().setThreshold(threshold);
    this.colorScaleThresholdCache[colorScaleKey(this.browser.state, this.displayMode)] = threshold;
    this.imageTileCache = {};
    await this.update();
  }

  getColorScale() {
    switch (this.displayMode) {
      case 'AOB':
      case 'BOA':
        return this.ratioColorScale;
      case 'AMB':
        return this.diffColorScale;
      default:
        return this.colorScale;
    }
  }

  async setDisplayMode(mode) {
    this.displayMode = mode;
    this.clearImageCaches();
    await this.update();
  }

  clearImageCaches() {
    this.imageTileCache = {};
    this.imageTileCacheKeys = [];
  }

  getViewDimensions() {
    return {
      width: this.$viewport.width(),
      height: this.$viewport.height()
    }
  }

  async receiveEvent(event) {

    if ("MapLoad" === event.type || "ControlMapLoad" === event.type) {

      // Don't enable mouse actions until we have a dataset.
      if (!this.mouseHandlersEnabled) {
        this.addTouchHandlers(this.$viewport);
        this.addMouseHandlers(this.$viewport);
        this.mouseHandlersEnabled = true;
      }
      this.clearImageCaches();
      this.colorScaleThresholdCache = {};
    } else {
      if (!("LocusChange" === event.type)) {
        this.clearImageCaches();
      }
      this.update();
    }
  }

  async update() {

    if (this.disableUpdates) return   // This flag is set during browser startup

    await this.repaint();

  }

  async repaint() {

    if (!this.browser.dataset) {
      return;
    }

    const viewportWidth = this.$viewport.width();
    const viewportHeight = this.$viewport.height();
    const canvasWidth = this.$canvas.width();
    const canvasHeight = this.$canvas.height();
    if (canvasWidth !== viewportWidth || canvasHeight !== viewportHeight) {
      this.$canvas.width(viewportWidth);
      this.$canvas.height(viewportHeight);
      this.$canvas.attr('width', this.$viewport.width());
      this.$canvas.attr('height', this.$viewport.height());
    }

    const browser = this.browser;
    const state = browser.state;

    let ds;
    let dsControl;
    let zdControl;
    let zoom;
    let controlZoom;
    switch (this.displayMode) {
      case 'A':
        zoom = state.zoom;
        ds = this.browser.dataset;
        break;
      case 'B':
        zoom = getBZoomIndex(state.zoom);
        ds = this.browser.controlDataset;
        break;
      case 'AOB':
      case 'AMB':
        zoom = state.zoom;
        controlZoom = getBZoomIndex(state.zoom);
        ds = this.browser.dataset;
        dsControl = this.browser.controlDataset;
        break;
      case 'BOA':
        zoom = getBZoomIndex(state.zoom);
        controlZoom = state.zoom;
        ds = this.browser.controlDataset;
        dsControl = this.browser.dataset;
    }

    const matrix = await ds.getMatrix(state.chr1, state.chr2);
    const unit = "BP";   // FRAG is not supported
    const zd = matrix.getZoomDataByIndex(zoom, unit);

    if (dsControl) {
      const matrixControl = await dsControl.getMatrix(state.chr1, state.chr2);
      zdControl = matrixControl.getZoomDataByIndex(controlZoom, unit);
    }

    const pixelSizeInt = Math.max(1, Math.floor(state.pixelSize));
    const widthInBins = this.$viewport.width() / pixelSizeInt;
    const heightInBins = this.$viewport.height() / pixelSizeInt;
    const blockCol1 = Math.floor(state.x / imageTileDimension);
    const blockCol2 = Math.floor((state.x + widthInBins) / imageTileDimension);
    const blockRow1 = Math.floor(state.y / imageTileDimension);
    const blockRow2 = Math.floor((state.y + heightInBins) / imageTileDimension);

    if ("NONE" !== state.normalization) {
      if (!ds.hasNormalizationVector(state.normalization, zd.chr1.name, zd.zoom.unit, zd.zoom.binSize)) {
        Alert.presentAlert("Normalization option " + normalization + " unavailable at this resolution.");
        this.browser.eventBus.post(new HICEvent("NormalizationExternalChange", "NONE"));
        state.normalization = "NONE";
      }
    }

    await this.checkColorScale(ds, zd, blockRow1, blockRow2, blockCol1, blockCol2, state.normalization);

    this.ctx.clearRect(0, 0, viewportWidth, viewportHeight);
    for (let r = blockRow1; r <= blockRow2; r++) {
      for (let c = blockCol1; c <= blockCol2; c++) {
        const tile = await this.getImageTile(ds, dsControl, zd, zdControl, r, c, state);
        if (tile.image) {
          this.paintTile(tile);
        }
      }
    }

    // Record genomic extent of current canvas
    this.genomicExtent = {
      chr1: state.chr1,
      chr2: state.chr2,
      x: state.x * zd.zoom.binSize,
      y: state.y * zd.zoom.binSize,
      w: viewportWidth * zd.zoom.binSize / state.pixelSize,
      h: viewportHeight * zd.zoom.binSize / state.pixelSize
    };

    function getBZoomIndex(zoom) {
      const binSize = browser.dataset.getBinSizeForZoomIndex(zoom);
      if (!binSize) {
        throw Error("Invalid zoom (resolution) index: " + zoom);
      }
      const bZoom = browser.controlDataset.getZoomIndexForBinSize(binSize);
      if (bZoom < 0) {
        throw Error(`Invalid binSize for "B" map: ${binSize}`);
      }
      return bZoom;
    }
  }

  /**
   * This is where the image tile is actually drawn, if not in the cache
   *
   * @param ds
   * @param dsControl
   * @param zd
   * @param zdControl
   * @param row
   * @param column
   * @param state
   * @returns {Promise<{image: HTMLCanvasElement, column: *, row: *, blockBinCount}|{image, inProgress: boolean, column: *, row: *, blockBinCount}|*>}
   */
  async getImageTile(ds, dsControl, zd, zdControl, row, column, state) {

    const key = `${zd.chr1.name}_${zd.chr2.name}_${zd.zoom.binSize}_${zd.zoom.unit}_${row}_${column}_${state.normalization}_${this.displayMode}`;
    if (this.imageTileCache.hasOwnProperty(key)) {
      return this.imageTileCache[key]
    } else {
      if (this.drawsInProgress.has(key)) {
        //console.log("In progress")
        const imageSize = imageTileDimension;
        const image = inProgressTile(imageSize);
        return {
          row: row,
          column: column,
          blockBinCount: imageTileDimension,
          image: image,
          inProgress: true
        }  // TODO return an image at a coarser resolution if avaliable

      }
      this.drawsInProgress.add(key);

      try {
        this.startSpinner();
        const sameChr = zd.chr1.index === zd.chr2.index;
        const transpose = sameChr && row < column;
        const averageCount = zd.averageCount;
        const ctrlAverageCount = zdControl ? zdControl.averageCount : 1;
        const averageAcrossMapAndControl = (averageCount + ctrlAverageCount) / 2;

        const imageSize = imageTileDimension;
        const image = document.createElement('canvas');
        image.width = imageSize;
        image.height = imageSize;
        const ctx = image.getContext('2d');
        setCanvasWidth(image, 3);
        //ctx.clearRect(0, 0, image.width, image.height);
        // Get blocks
        const widthInBP = imageTileDimension * zd.zoom.binSize;
        const x0bp = column * widthInBP;
        const region1 = { chr: zd.chr1.name, start: x0bp, end: x0bp + widthInBP };
        const y0bp = row * widthInBP;
        const region2 = { chr: zd.chr2.name, start: y0bp, end: y0bp + widthInBP };

        const records = await ds.getContactRecords(state.normalization, region1, region2, zd.zoom.unit, zd.zoom.binSize);

        let cRecords;
        if (zdControl) {
          cRecords = await dsControl.getContactRecords(state.normalization, region1, region2, zdControl.zoom.unit, zdControl.zoom.binSize);
        }
        if (this.displayMode === 'AMB') {
          let id = ctx.getImageData(0, 0, image.width, image.height);
          const x0 = column * imageTileDimension;
          const y0 = row * imageTileDimension;
          for (let i = 0; i < records.length; i++) {
            let rec = records[i];
            let x = Math.floor((rec.bin1 - x0));
            let y = Math.floor((rec.bin2 - y0));
            let rgba = this.diffColorScale.negativeScale.getColor(rec.counts);
            setPixel(id, x, y, rgba.red, rgba.green, rgba.blue, rgba.alpha);
          }
          // x可能会小于0，y不会小于0
          for (let i = 0; i < cRecords.length; i++) {
            let rec = cRecords[i];
            let x = Math.floor((rec.bin1 - x0));
            let y = Math.floor((rec.bin2 - y0));
            let rgba = this.diffColorScale.positiveScale.getColor(rec.counts);
            if (sameChr && row === column) {
              setPixel(id, y, x, rgba.red, rgba.green, rgba.blue, rgba.alpha);
            } else {
              x = Math.floor((rec.bin1 - y0));
              y = Math.floor((rec.bin2 - x0));
              setPixel(id, y, x, rgba.red, rgba.green, rgba.blue, rgba.alpha);
            }

          }
          ctx.putImageData(id, 0, 0);
        }
        else {
          if (records.length > 0) {
            const controlRecords = {};
            if ('AOB' === this.displayMode || 'BOA' === this.displayMode) {
              for (let record of cRecords) {
                controlRecords[record.getKey()] = record;
              }
            }
            let id = ctx.getImageData(0, 0, image.width, image.height);
            const x0 = transpose ? row * imageTileDimension : column * imageTileDimension;
            const y0 = transpose ? column * imageTileDimension : row * imageTileDimension;
            for (let i = 0; i < records.length; i++) {
              const rec = records[i];
              let x = Math.floor((rec.bin1 - x0));
              let y = Math.floor((rec.bin2 - y0));
              if (transpose) {
                const t = y;
                y = x;
                x = t;
              }
              let rgba, key, controlRec, score;
              switch (this.displayMode) {
                case 'AOB':
                case 'BOA':
                  key = rec.getKey();
                  controlRec = controlRecords[key];
                  if (!controlRec) {
                    continue;    // Skip
                  }
                  score = (rec.counts / averageCount) / (controlRec.counts / ctrlAverageCount);
                  rgba = this.ratioColorScale.getColor(score);
                  setPixel(id, x, y, rgba.red, rgba.green, rgba.blue, rgba.alpha);
                  if (sameChr && row === column) {
                    setPixel(id, y, x, rgba.red, rgba.green, rgba.blue, rgba.alpha);
                  }
                  break;
                default:    // Either 'A' or 'B'
                  rgba = this.colorScale.getColor(rec.counts);
                  setPixel(id, x, y, rgba.red, rgba.green, rgba.blue, rgba.alpha);
                  if (sameChr && row === column) {
                    setPixel(id, y, x, rgba.red, rgba.green, rgba.blue, rgba.alpha);
                  }
              }
            }
            ctx.putImageData(id, 0, 0);
          }
        }

        //Draw 2D tracks
        // 绘制热图
        ctx.save();
        ctx.lineWidth = 2;
        let tad_num = 0;
        for (let track2D of this.browser.tracks2D) {
          // console.log(track2D)
          if (track2D.isVisible) {
            let track_type = track2D.config.track_type
            if (track_type === 'tad') tad_num++;
            const chr1Name = zd.chr1.name;
            const chr2Name = zd.chr2.name;
            const features = track2D.getFeatures(chr1Name, chr2Name);
            if (features) {
              for (let { chr1, x1, x2, y1, y2, color } of features) {
                const flip = chr1Name !== chr1;
                const fx1 = transpose || flip ? y1 : x1;
                const fx2 = transpose || flip ? y2 : x2;
                const fy1 = transpose || flip ? x1 : y1;
                const fy2 = transpose || flip ? x2 : y2;
                let px1 = (fx1 - x0bp) / zd.zoom.binSize;
                let px2 = (fx2 - x0bp) / zd.zoom.binSize;
                let py1 = (fy1 - y0bp) / zd.zoom.binSize;
                let py2 = (fy2 - y0bp) / zd.zoom.binSize;
                let w = px2 - px1;
                let h = py2 - py1;
                const dim = Math.max(image.width, image.height);
                if (px2 > 0 && px1 < dim && py2 > 0 && py1 < dim) {
                  ctx.strokeStyle = track2D.color ? track2D.color : color;
                  ctx.fillStyle = `#d4d4d487`;
                  if (this.displayMode === 'AMB') {
                    if (tad_num == 1) {
                      ctx.beginPath();
                      ctx.moveTo(px1, py1);
                      ctx.lineTo(px1, py1 + h);
                      ctx.lineTo(px1 + w, py1 + h);
                      ctx.strokeStyle = track2D.color ? track2D.color : color;
                      ctx.stroke();
                      ctx.fill();
                    } else {
                      ctx.beginPath();
                      ctx.moveTo(px1, py1);
                      ctx.lineTo(px1 + w, py1);
                      ctx.lineTo(px1 + w, py1 + h);
                      ctx.strokeStyle = track2D.color ? track2D.color : color;
                      ctx.stroke();
                      ctx.fill();
                    }
                  } else {
                    ctx.strokeRect(px1, py1, w, h);
                    ctx.fillRect(px1, py1, w, h);
                    if (sameChr && row === column) {
                      ctx.strokeRect(py1, px1, h, w);
                      ctx.fillRect(py1, px1, h, w);
                    }
                  }
                }
              }
            }
          }
        }
        ctx.restore();
        var imageTile = { row: row, column: column, blockBinCount: imageTileDimension, image: image };
        if (this.imageTileCacheLimit > 0) {
          if (this.imageTileCacheKeys.length > this.imageTileCacheLimit) {
            delete this.imageTileCache[this.imageTileCacheKeys[0]];
            this.imageTileCacheKeys.shift();
          }
          this.imageTileCache[key] = imageTile;

        }
        return imageTile;
      } finally {
        this.drawsInProgress.delete(key);
        this.stopSpinner();
      }
    }

    function setPixel(imageData, x, y, r, g, b, a) {
      let index = (x + y * imageData.width) * 4;
      imageData.data[index + 0] = r;
      imageData.data[index + 1] = g;
      imageData.data[index + 2] = b;
      imageData.data[index + 3] = a;
    }

  };




  /**
   * Return a promise to adjust the color scale, if needed.  This function might need to load the contact
   * data to computer scale.
   *
   * @param zd
   * @param row1
   * @param row2
   * @param col1
   * @param col2
   * @param normalization
   * @returns {*}
   */
  async checkColorScale(ds, zd, row1, row2, col1, col2, normalization) {

    const colorKey = colorScaleKey(this.browser.state, this.displayMode);   // This doesn't feel right, state should be an argument
    if ('AOB' === this.displayMode || 'BOA' === this.displayMode) {
      return this.ratioColorScale;     // Don't adjust color scale for A/B.
    }

    if (this.colorScaleThresholdCache[colorKey]) {
      const changed = this.colorScale.threshold !== this.colorScaleThresholdCache[colorKey];
      this.colorScale.setThreshold(this.colorScaleThresholdCache[colorKey]);
      if (changed) {
        this.browser.eventBus.post(HICEvent("ColorScale", this.colorScale));
      }
      return this.colorScale;
    } else {
      try {
        const widthInBP = imageTileDimension * zd.zoom.binSize;
        const x0bp = col1 * widthInBP;
        const xWidthInBP = (col2 - col1 + 1) * widthInBP;
        const region1 = { chr: zd.chr1.name, start: x0bp, end: x0bp + xWidthInBP };
        const y0bp = row1 * widthInBP;
        const yWidthInBp = (row2 - row1 + 1) * widthInBP;
        const region2 = { chr: zd.chr2.name, start: y0bp, end: y0bp + yWidthInBp };
        const records = await ds.getContactRecords(normalization, region1, region2, zd.zoom.unit, zd.zoom.binSize, true);

        let s = computePercentile(records, 95);
        if (!isNaN(s)) {  // Can return NaN if all blocks are empty
          if (0 === zd.chr1.index) s *= 4;   // Heuristic for whole genome view
          this.colorScale = new ColorScale(this.colorScale);
          this.colorScale.setThreshold(s);
          this.computeColorScale = false;
          this.browser.eventBus.post(HICEvent("ColorScale", this.colorScale));
          this.colorScaleThresholdCache[colorKey] = s;
        }

        return this.colorScale;
      } finally {
        this.stopSpinner();
      }


    }

  }

  async zoomIn() {
    const state = this.browser.state;
    const viewportWidth = this.$viewport.width();
    const viewportHeight = this.$viewport.height();
    const matrices = await getMatrices.call(this, state.chr1, state.chr2);

    var matrix = matrices[0];

    if (matrix) {
      const unit = "BP";
      const zd = await matrix.getZoomDataByIndex(state.zoom, unit);
      const newGenomicExtent = {
        x: state.x * zd.zoom.binSize,
        y: state.y * zd.zoom.binSize,
        w: viewportWidth * zd.zoom.binSize / state.pixelSize,
        h: viewportHeight * zd.zoom.binSize / state.pixelSize
      };

      // Zoom out not supported
      if (newGenomicExtent.w > this.genomicExtent.w) return

      const sx = ((newGenomicExtent.x - this.genomicExtent.x) / this.genomicExtent.w) * viewportWidth;
      const sy = ((newGenomicExtent.y - this.genomicExtent.y) / this.genomicExtent.w) * viewportHeight;
      const sWidth = (newGenomicExtent.w / this.genomicExtent.w) * viewportWidth;
      const sHeight = (newGenomicExtent.h / this.genomicExtent.h) * viewportHeight;
      const img = this.$canvas[0];

      const backCanvas = document.createElement('canvas');
      backCanvas.width = img.width;
      backCanvas.height = img.height;
      const backCtx = backCanvas.getContext('2d');
      backCtx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, viewportWidth, viewportHeight);

      this.ctx.clearRect(0, 0, viewportWidth, viewportHeight);
      this.ctx.drawImage(backCanvas, 0, 0);
    }
  }

  paintTile({ image, row, column, blockBinCount }) {

    const x0 = blockBinCount * column;
    const y0 = blockBinCount * row;

    const { x, y, pixelSize } = this.browser.state;
    //const pixelSizeInt = Math.max(1, Math.floor(pixelSize))
    const offsetX = (x0 - x) * pixelSize;
    const offsetY = (y0 - y) * pixelSize;

    const scale = pixelSize; // / pixelSizeInt
    const scaledWidth = image.width * scale;
    const scaledHeight = image.height * scale;

    const viewportWidth = this.$viewport.width();
    const viewportHeight = this.$viewport.height();

    if (offsetX <= viewportWidth && offsetX + scaledWidth >= 0 && offsetY <= viewportHeight && offsetY + scaledHeight >= 0) {
      this.ctx.fillStyle = this.backgroundRGBString;
      this.ctx.fillRect(offsetX, offsetY, scaledWidth, scaledHeight);
      if (scale === 1) {
        this.ctx.drawImage(image, offsetX, offsetY);
      } else {
        this.ctx.drawImage(image, offsetX, offsetY, scaledWidth, scaledHeight);
      }
      // Debugging aid, uncomment to see tile boundaries
      //this.ctx.strokeRect(offsetX, offsetY, scaledWidth, scaledHeight)
      //this.ctx.strokeText(`${row} ${column}`, offsetX, offsetY);
    }
  }

  startSpinner() {

    if (true === this.browser.isLoadingHICFile && this.browser.$user_interaction_shield) {
      this.browser.$user_interaction_shield.show();
    }
    this.$fa_spinner.css("display", "inline-block");
    this.spinnerCount++;
  }

  stopSpinner() {
    this.spinnerCount--;
    if (0 === this.spinnerCount) {
      this.$fa_spinner.css("display", "none");
    }
    this.spinnerCount = Math.max(0, this.spinnerCount);   // This should not be neccessary
  }

  // 4:1-191,154,276
  parseLocusGotoString(string) {
    let chr = string.split(':')[0];
    let scale = string.split(':')[1];

    let s = scale.split('-')[0];
    s = s.replaceAll(',', '');
    s = parseInt(s);

    let e = scale.split('-')[1];
    e = e.replaceAll(',', '');
    e = parseInt(e);

    return { chr, s, e };

  }
  addMouseHandlers($viewport) {

    let isMouseDown = false;
    let isSweepZooming = false;
    let mouseDown;
    let mouseLast;
    let mouseOver;
    let time = null; // 解决单双击
    let ismove; // 解决拖动后的再执行单击

    const panMouseUpOrMouseOut = (e) => {
      if (true === this.isDragging) {
        this.isDragging = false;
        this.browser.eventBus.post(HICEvent("DragStopped"));
      }
      isMouseDown = false;
      mouseDown = mouseLast = undefined;
    };
    this.isDragging = false;


    if (!this.browser.isMobile) {
      // 鼠标单击事件
      $viewport.click((e) => {
        clearTimeout(time);
        time = setTimeout(() => {
          if (!ismove) {
            if (this.browser.isWholeGenome()) return;
            let TrackLoad2D = [];
            let loadedTAD = this.browser.findTracks('track_type', 'tad');
            for (let tad of loadedTAD) {
              TrackLoad2D.push(tad);
            }
            let loadedLoop = this.browser.findTracks('track_type', 'loop');
            for (let loop of loadedLoop) {
              TrackLoad2D.push(loop);
            }

            let loadedFrag = this.browser.findTracks('track_type', 'fragment');
            for (let frag of loadedFrag) {
              TrackLoad2D.push(frag);
            }

            if (TrackLoad2D.length < 1) {
              return;
            }
            let bpResolutions = this.browser.getResolutions();
            let currentResolution = bpResolutions[this.browser.state.zoom];
            if (currentResolution.index < 6) return; // 分辨率太高

            e.preventDefault;
            e.stopPropagation();


            // 先分析坐标点
            let goto = this.browser.locusGoto.$container[0];
            let input = $(goto).children('input')[0];
            let locus = $(input).val().split(' '); // 4:1-191,154,276 4:1-191,154,276
            let x = this.parseLocusGotoString(locus[0])
            let y = this.parseLocusGotoString(locus[1])
            let b_id = this.browser.id;

            if (x.chr !== y.chr) return;

            let viewDimensions = this.browser.contactMatrixView.getViewDimensions(); // canvas的长宽
            let mouseX = e.offsetX || e.layerX;
            let mouseY = e.offsetY || e.layerX;

            let x_s = x.s + Math.floor(mouseX / viewDimensions.width * (x.e - x.s)); // 向下取整
            let y_s = y.s + Math.floor(mouseY / viewDimensions.height * (y.e - y.s));

            let item_list = [];
            for (let i = 0; i < TrackLoad2D.length; i++) {
              // console.log(TrackLoad2D[i]);
              let features = TrackLoad2D[i].featureMap;
              features = features[x.chr + '_' + y.chr];
              for (let j = 0; j < features.length; j++) {
                let feature = features[j]; // chr1,chr2,color,x1,x2,y1,y2
                // Point 在TAD 圈内
                if (x_s <= feature.x2 && x_s >= feature.x1 && y_s <= feature.y2 && y_s >= feature.y1) {
                  let obj = { feature };
                  obj.name = TrackLoad2D[i].config.name;
                  item_list.push(obj);
                }
                // Loop
                if (feature.x2 - feature.x1 <= 1e4 + 10 && feature.y2 - feature.y1 <= 1e4 + 10) {
                  let auf = 2e4;
                  // Loop 只判断前几位
                  if (Math.abs(parseInt(x_s / auf) - parseInt(feature.y1 / auf)) <= 1
                    && Math.abs(parseInt(y_s / auf) - parseInt(feature.x1 / auf)) <= 1) {
                    //Loop是chr1和chr2是对称的
                    let obj = { feature };
                    obj.name = TrackLoad2D[i].config.name;
                    item_list.push(obj);
                  }
                }
              }
            }
            if (item_list.length < 1) {
              console.log('show record');
              return;
            };
            let content = getPopContent(b_id, item_list)
            if (content) {
              if (this.popover) this.popover.dispose();
              this.popover = new Popover(this.browser.$root.get(0));
              this.popover.presentContentWithEvent(e, content);
            }
          }
          else {
            return;
          }
        }, 1000);
      });

      $viewport.dblclick((e) => {
        clearTimeout(time);
        e.preventDefault;
        e.stopPropagation();
        let mouseX = e.offsetX || e.layerX;
        let mouseY = e.offsetY || e.layerX;
        if (this.browser.isDiag || this.browser.contactMatrixView.displayMode === 'AMB') {
          mouseY = mouseX;
        }
        this.browser.zoomAndCenter(1, mouseX, mouseY);
      });

      $viewport.on('mouseover', (e) => mouseOver = true);

      $viewport.on('mouseout', (e) => mouseOver = undefined);

      $viewport.on('mousedown', (e) => {
        ismove = false;
        //console.log('down:',ismove)
        e.preventDefault;
        e.stopPropagation();

        if (this.browser.$menu.is(':visible')) {
          this.browser.hideMenu();
        }

        mouseLast = { x: e.offsetX, y: e.offsetY };
        mouseDown = { x: e.offsetX, y: e.offsetY };

        isSweepZooming = (true === e.altKey);
        if (isSweepZooming) {
          const eFixed = $.event.fix(e);
          this.sweepZoom.initialize({ x: eFixed.pageX, y: eFixed.pageY });
        }

        isMouseDown = true;

      });

      $viewport.on('mousemove', (e) => {
        ismove = true;
        // 十字架
        //e.preventDefault;
        //e.stopPropagation();
        const coords =
        {
          x: e.offsetX,
          y: e.offsetY
        };

        // Sets pageX and pageY for browsers that don't support them
        const eFixed = $.event.fix(e);

        const xy =
        {
          x: eFixed.pageX - $viewport.offset().left,
          y: eFixed.pageY - $viewport.offset().top
        };

        const { width, height } = $viewport.get(0).getBoundingClientRect();
        xy.xNormalized = xy.x / width;
        xy.yNormalized = xy.y / height;


        this.browser.eventBus.post(HICEvent("UpdateContactMapMousePosition", xy, false));

        /*
        if (true === this.willShowCrosshairs) {
            this.browser.updateCrosshairs(xy);
            this.browser.showCrosshairs();
        }
        */

        if (isMouseDown) { // Possibly dragging
          if (isSweepZooming) {

            this.sweepZoom.update({ x: eFixed.pageX, y: eFixed.pageY });

          } else if (mouseDown.x && Math.abs(coords.x - mouseDown.x) > DRAG_THRESHOLD) {
            // 拖动
            this.isDragging = true;
            let dx = mouseLast.x - coords.x;
            let dy = mouseLast.y - coords.y;
            if (this.browser.isDiag || this.browser.contactMatrixView.displayMode === 'AMB') {
              dy = dx;
            }
            this.browser.shiftPixels(dx, dy);
          }

          mouseLast = coords;
        }
      });

      $viewport.on('mouseup', panMouseUpOrMouseOut);

      $viewport.on('mouseleave', () => {
        this.browser.layoutController.xAxisRuler.unhighlightWholeChromosome();
        this.browser.layoutController.yAxisRuler.unhighlightWholeChromosome();
        panMouseUpOrMouseOut();
      });


      // Mousewheel events -- ie exposes event only via addEventListener, no onwheel attribute
      // NOte from spec -- trackpads commonly map pinch to mousewheel + ctrl
      // $viewport[0].addEventListener("wheel", mouseWheelHandler, 250, false);

      // document level events
      /*
      $(document).on('keydown.contact_matrix_view', (e) => {
          if (undefined === this.willShowCrosshairs && true === mouseOver && true === e.shiftKey) {
              this.willShowCrosshairs = true;
              this.browser.eventBus.post(HICEvent('DidShowCrosshairs', 'DidShowCrosshairs', false));
          }
      });

      $(document).on('keyup.contact_matrix_view', (e) => {
          this.browser.hideCrosshairs();
          this.willShowCrosshairs = undefined;
          this.browser.eventBus.post(HICEvent('DidHideCrosshairs', 'DidHideCrosshairs', false));
      });
      */
      // for sweep-zoom allow user to sweep beyond viewport extent
      // sweep area clamps since viewport mouse handlers stop firing
      // when the viewport boundary is crossed.
      $(document).on('mouseup.contact_matrix_view', (e) => {
        e.preventDefault;
        e.stopPropagation();
        if (isSweepZooming) {
          isSweepZooming = false;
          this.sweepZoom.commit();
        }
      });
    }
  }


  /**
   * Add touch handlers.  Touches are mapped to one of the following application level events
   *  - double tap, equivalent to double click
   *  - move
   *  - pinch
   *
   * @param $viewport
   */

  addTouchHandlers($viewport) {

    let lastTouch, pinch;
    const viewport = $viewport[0];

    /**
     * Touch start -- 3 possibilities
     *   (1) beginning of a drag (pan)
     *   (2) first tap of a double tap
     *   (3) beginning of a pinch
     */
    viewport.ontouchstart = (ev) => {

      ev.preventDefault();
      ev.stopPropagation();

      var touchCoords = translateTouchCoordinates(ev.targetTouches[0], viewport),
        offsetX = touchCoords.x,
        offsetY = touchCoords.y,
        count = ev.targetTouches.length,
        timeStamp = ev.timeStamp || Date.now(),
        resolved = false,
        dx, dy, dist, direction;

      if (count === 2) {
        touchCoords = translateTouchCoordinates(ev.targetTouches[0], viewport);
        offsetX = (offsetX + touchCoords.x) / 2;
        offsetY = (offsetY + touchCoords.y) / 2;
      }

      // NOTE: If the user makes simultaneous touches, the browser may fire a
      // separate touchstart event for each touch point. Thus if there are
      // two simultaneous touches, the first touchstart event will have
      // targetTouches length of one and the second event will have a length
      // of two.  In this case replace previous touch with this one and return
      if (lastTouch && (timeStamp - lastTouch.timeStamp < DOUBLE_TAP_TIME_THRESHOLD) && ev.targetTouches.length > 1 && lastTouch.count === 1) {
        lastTouch = { x: offsetX, y: offsetY, timeStamp: timeStamp, count: ev.targetTouches.length };
        return;
      }


      if (lastTouch && (timeStamp - lastTouch.timeStamp < DOUBLE_TAP_TIME_THRESHOLD)) {

        direction = (lastTouch.count === 2 || count === 2) ? -1 : 1;
        dx = lastTouch.x - offsetX;
        dy = lastTouch.y - offsetY;
        dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < DOUBLE_TAP_DIST_THRESHOLD) {
          this.browser.zoomAndCenter(direction, offsetX, offsetY);
          lastTouch = undefined;
          resolved = true;
        }
      }

      if (!resolved) {
        lastTouch = { x: offsetX, y: offsetY, timeStamp: timeStamp, count: ev.targetTouches.length };
      }
    };

    viewport.ontouchmove = throttle((ev) => {

      var touchCoords1, touchCoords2, t;

      ev.preventDefault();
      ev.stopPropagation();

      if (ev.targetTouches.length === 2) {

        // Update pinch  (assuming 2 finger movement is a pinch)
        touchCoords1 = translateTouchCoordinates(ev.targetTouches[0], viewport);
        touchCoords2 = translateTouchCoordinates(ev.targetTouches[1], viewport);

        t = {
          x1: touchCoords1.x,
          y1: touchCoords1.y,
          x2: touchCoords2.x,
          y2: touchCoords2.y
        };

        if (pinch) {
          pinch.end = t;
        } else {
          pinch = { start: t };
        }
      } else {
        // Assuming 1 finger movement is a drag

        var touchCoords = translateTouchCoordinates(ev.targetTouches[0], viewport),
          offsetX = touchCoords.x,
          offsetY = touchCoords.y;
        if (lastTouch) {
          var dx = lastTouch.x - offsetX,
            dy = lastTouch.y - offsetY;
          if (!isNaN(dx) && !isNaN(dy)) {
            this.isDragging = true;
            this.browser.shiftPixels(lastTouch.x - offsetX, lastTouch.y - offsetY);
          }
        }

        lastTouch = {
          x: offsetX,
          y: offsetY,
          timeStamp: ev.timeStamp || Date.now(),
          count: ev.targetTouches.length
        };
      }

    }, 50);

    viewport.ontouchend = (ev) => {

      ev.preventDefault();
      ev.stopPropagation();

      if (pinch && pinch.end !== undefined) {

        var startT = pinch.start,
          endT = pinch.end,
          dxStart = startT.x2 - startT.x1,
          dyStart = startT.y2 - startT.y1,
          dxEnd = endT.x2 - endT.x1,
          dyEnd = endT.y2 - endT.y1,
          distStart = Math.sqrt(dxStart * dxStart + dyStart * dyStart),
          distEnd = Math.sqrt(dxEnd * dxEnd + dyEnd * dyEnd),
          scale = distEnd / distStart;
        (endT.x1 + endT.x2) / 2 - (startT.x1 + startT.x2) / 2;
        (endT.y1 + endT.y2) / 2 - (startT.y1 + startT.y2) / 2;
        var anchorPx = (startT.x1 + startT.x2) / 2,
          anchorPy = (startT.y1 + startT.y2) / 2;

        if (scale < 0.8 || scale > 1.2) {
          lastTouch = undefined;
          this.browser.pinchZoom(anchorPx, anchorPy, scale);
        }
      } else if (this.isDragging) {
        this.isDragging = false;
        this.browser.eventBus.post(HICEvent("DragStopped"));
      }

      // a touch end always ends a pinch
      pinch = undefined;

    };

    function translateTouchCoordinates(e, target) {

      var $target = $(target),
        posx,
        posy;
      posx = e.pageX - $target.offset().left;
      posy = e.pageY - $target.offset().top;
      return { x: posx, y: posy }
    }

  }

}

ContactMatrixView.defaultBackgroundColor = { r: 255, g: 255, b: 255 };

function colorScaleKey(state, displayMode) {
  return "" + state.chr1 + "_" + state.chr2 + "_" + state.zoom + "_" + state.normalization + "_" + displayMode;
}

/**
 * 
 * @param {*} id：浏览器id 
 * @param {*} itemList : feature maps;
 * @returns 
 */
function getPopContent(id, itemList) {
  let _html = ``;
  for (let i = 0; i < itemList.length; i++) {
    let item = itemList[i];
    let feature = item.feature;

    let chr1 = `${feature.chr1}:${Number(feature.x1).toLocaleString()}-${Number(feature.x2).toLocaleString()}`;
    let chr2 = `${feature.chr2}:${Number(feature.y1).toLocaleString()}-${Number(feature.y2).toLocaleString()}`;

    let call_x, call_y;
    // 同一条染色体
    if (feature.chr1 === feature.chr2) {
      let min = Math.min(Number(feature.x1), Number(feature.y1));
      let max = Math.max(Number(feature.x2), Number(feature.y2));
      call_x = `${feature.chr1}:${min.toLocaleString()}-${max.toLocaleString()}`;
      call_y = call_x;
    } else {
      call_x = chr1;
      call_y = chr2;
    }



    _html += `
      <div>
        <span>Chr1:</span>&nbsp&nbsp&nbsp${chr1}<br/>
        <span>Chr2:</span>&nbsp&nbsp&nbsp${chr2}
      </div>
      <div title="${item.name}">
        <span>Type:</span>&nbsp&nbsp&nbsp${item.name}
      </div>
      <div>
      <span>3D :</span>&nbsp&nbsp&nbsp<span class='click' onclick="call3d('${id}','${call_x}','${call_y}')">Show this area in 3D model</span><br/>
      <span>View :</span>&nbsp&nbsp&nbsp<span class='click' onclick="browser_goto_locus('${chr1} ${chr2}')">View This Structure</span>
    </div>
    `;
    if (i !== itemList.length - 1) {
      _html += `<div title="<hr/>"><hr/></div>`;
    }
  }
  return _html;


}

/**
* Returns a promise for an image tile
*
* @param zd
* @param row
* @param column
* @param state
* @returns {*}
*/

const inProgressCache = {};

function inProgressTile(imageSize) {

  let image = inProgressCache[imageSize];
  if (!image) {
    image = document.createElement('canvas');
    image.width = imageSize;
    image.height = imageSize;
    const ctx = image.getContext('2d');
    ctx.font = '24px sans-serif';
    ctx.fillStyle = 'rgb(230, 230, 230)';
    ctx.fillRect(0, 0, image.width, image.height);
    ctx.fillStyle = 'black';
    for (let i = 100; i < imageSize; i += 300) {
      for (let j = 100; j < imageSize; j += 300) {
        ctx.fillText('Loading...', i, j);
      }
    }
    inProgressCache[imageSize] = image;
  }
  return image;
}

function getMatrices(chr1, chr2) {

  var promises = [];
  if ('B' === this.displayMode && this.browser.controlDataset) {
    promises.push(this.browser.controlDataset.getMatrix(chr1, chr2));
  } else {
    promises.push(this.browser.dataset.getMatrix(chr1, chr2));
    if (this.displayMode && 'A' !== this.displayMode && this.browser.controlDataset) {
      promises.push(this.browser.controlDataset.getMatrix(chr1, chr2));
    }
  }
  return Promise.all(promises);
}


function computePercentile(records, p) {
  const counts = records.map(r => r.counts);
  counts.sort(function (a, b) {
    return a - b;
  });
  const idx = Math.floor((p / 100) * records.length);
  return counts[idx];

  // return HICMath.percentile(array, p);
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

function _parseLocus(x) {
  x = x.split(':');
  let chr = x[0];
  let scales = x[1];
  scales = scales.replaceAll(',', '');
  scales = scales.split('-');
  let x_start = parseInt(scales[0]);
  let x_end = parseInt(scales[1]);
  return [chr, x_start, x_end];
}

function _generate_a_locus(chrx, xs, xe) {
  xs = Number(xs).toLocaleString();
  xe = Number(xe).toLocaleString();
  let cor = chrx + ':' + xs + '-' + xe;
  return cor;
}
function _generate_locus(chrx, xs, xe, chry, ys, ye) {
  let cor = _generate_a_locus(chrx, xs, xe) + ' ' + _generate_a_locus(chry, ys, ye);
  return cor;
}


// check diag
function _browser_goto_locus(browser, locus) {
  let d = browser.isDiag;
  if (d) {
    locus = locus.split(' ');
    locus = locus[0] + ' ' + locus[0];
  }
  browser.gotoLocus(locus);
}


function zoom_in(cur_locus, browser) {
  if (cur_locus === "") {
    try {
      browser.zoomIn();
    } catch (error) {

    }
    return;
  }
  if (cur_locus === 'All') {
    _browser_goto_locus(browser, '1');
  } else {
    let xy = cur_locus.split(' ');
    let [chrx, xs, xe] = _parseLocus(xy[0]);
    let [chry, ys, ye] = _parseLocus(xy[1]);
    let xns = xs + parseInt((xe - xs) / 4);
    let xne = xe - parseInt((xe - xs) / 4);
    let yns = ys + parseInt((ye - ys) / 4);
    let yne = ye - parseInt((ye - ys) / 4);
    let new_loc = _generate_locus(chrx, xns, xne, chry, yns, yne);
    _browser_goto_locus(browser, new_loc);
  }
}

function zoom_out(cur_locus, browser) {
  if (cur_locus === 'All') return;
  if (cur_locus === '') {
    try {
      browser.zoomOut();
    } catch (error) {

    }
    return;
  }
  let xy = cur_locus.split(' ');
  let [chrx, xs, xe] = _parseLocus(xy[0]);
  let [chry, ys, ye] = _parseLocus(xy[1]);
  let xns = xs - parseInt((xe - xs) / 2);
  if (xns < 1) xns = 1;
  let xne = xe + parseInt((xe - xs) / 2);
  let yns = ys - parseInt((ye - ys) / 2);
  if (yns < 1) yns = 1;
  let yne = ye + parseInt((ye - ys) / 2);
  let new_loc = _generate_locus(chrx, xns, xne, chry, yns, yne);
  _browser_goto_locus(browser, new_loc);
}


function _showDiag(browser) {
  // 修改状态
  browser.isDiag = true;
  let _id = browser.id;

  // 旋转iewport
  let viewport = $(`#${_id}-viewport`);
  let ow = viewport.width();
  viewport.css('transform', 'rotate(315deg)');
  viewport.css('clip-path', 'polygon(0 0, 100% 100%, 100% 0%)');
  viewport.css('background', 'transparent');
  viewport.css('margin-left', '20px');

  //.hic-browser-div
  //$('.hic-browser-div').css('padding-bottom','135px');

  // 隐藏axis
  $(`#${_id}-y-axis`).hide();
  $(`#${_id}-x-axis`).hide();
  // 缩小canvas
  let canvas = $(`#${_id}-viewport > canvas`);
  canvas.css('transform', 'scale(0.707)'); // 根号2 分之1
  // 将igV div往上提
  let igv_div = $(`#igv-${_id}`);
  igv_div.css('margin-top', `${-ow / 2}px`);
  igv_div.css('padding-bottom', `${-ow / 2}px`);
  //修改locus
  let locus = get_goto_input();
  locus = locus.split(' ');
  locus = locus[0] + ' ' + locus[0];
  _browser_goto_locus(browser, locus);
}

function _hideDiag(browser) {
  // 修改状态
  browser.isDiag = false;
  let _id = browser.id;

  // 旋转iewport
  let viewport = $(`#${_id}-viewport`);
  let ow = viewport.width();
  viewport.css('transform', '');
  viewport.css('clip-path', '');
  viewport.css('background', '');
  viewport.css('margin-left', '');


  //.hic-browser-div
  $('.hic-browser-div').css('padding-bottom', '');

  $(`#${_id}-y-axis`).show();
  $(`#${_id}-x-axis`).show();

  let canvas = $(`#${_id}-viewport > canvas`);
  canvas.css('transform', '');

  let igv_div = $(`#igv-${_id}`);
  igv_div.css('margin-top', `15px`);
  igv_div.css('padding-bottom', ``);
}

function _showGlassDiag(_id) {
  // 旋转iewport
  let glass_div = $(`#glass_canvas_${_id}`);
  glass_div.css('transform', 'rotate(315deg)');
  glass_div.css('clip-path', 'polygon(0 0, 100% 100%, 100% 0%)');
  glass_div.css('background', 'transparent');
  glass_div.css('margin-left', '5px');
  // 缩小canvas
  let canvas = $(`#glass_canvas_${_id} > canvas`);
  canvas.css('transform', 'scale(0.707)'); // 根号2 分之1
}

function _hideGlassDiag(_id) {
  // 旋转iewport
  let glass_div = $(`#glass_canvas_${_id}`);
  glass_div.css('transform', '');
  glass_div.css('clip-path', '');
  glass_div.css('background', '');
  glass_div.css('margin-left', '');
  // 缩小canvas
  let canvas = $(`#glass_canvas_${_id} > canvas`);
  canvas.css('transform', ''); // 根号2 分之1
}


function _browser_diag_show(browser) {
  let _id = browser.id;
  _showDiag(browser);
  if ($(`#glass_canvas_${_id}`).length > 0) {
    _showGlassDiag(_id);
  }
}

function _browser_diag_hide(browser) {
  _hideDiag(browser);
  let _id = browser.id;
  if ($(`#glass_canvas_${_id}`).length > 0) {
    _hideGlassDiag(_id);
  }
}


class ColorScaleWidget {

  constructor(browser, $hic_navbar_container) {

    this.browser = browser;

    const $container = $hic_navbar_container.find("div[id$='lower-hic-nav-bar-widget-container']");

    this.$container = $('<div class="hic-colorscale-widget-container">');
    $container.append(this.$container);

    // contact map background color picker
    const { r: _r, g: _g, b: _b } = ContactMatrixView.defaultBackgroundColor;
    this.$mapBackgroundColorpickerButton = colorSwatch(IGVColor.rgbColor(_r, _g, _b));
    this.$container.append(this.$mapBackgroundColorpickerButton);
    this.backgroundColorpicker = createColorPicker(browser, this.$mapBackgroundColorpickerButton, undefined);

    // '-' color swatch
    const { r: nr, g: ng, b: nb } = defaultRatioColorScaleConfig.negative;
    this.$minusButton = colorSwatch(IGVColor.rgbColor(nr, ng, nb));
    this.$container.append(this.$minusButton);
    this.minusColorPicker = createColorPicker(browser, this.$minusButton, '-');
    this.$minusButton.hide();

    // '+' color swatch
    const { r, g, b } = defaultRatioColorScaleConfig.positive;
    this.$plusButton = colorSwatch(IGVColor.rgbColor(r, g, b));
    this.$container.append(this.$plusButton);
    this.plusColorPicker = createColorPicker(browser, this.$plusButton, '+');

    this.$minusButton.on('click', () => presentColorPicker(this.minusColorPicker, this.plusColorPicker, this.backgroundColorpicker));
    this.$plusButton.on('click', () => presentColorPicker(this.plusColorPicker, this.minusColorPicker, this.backgroundColorpicker));
    this.$mapBackgroundColorpickerButton.on('click', () => presentColorPicker(this.backgroundColorpicker, this.minusColorPicker, this.plusColorPicker));

    // threshold

    let threshDiv = $("<div>", { class: 'thresh', 'aria-hidden': 'true' });


    let $fa = $("<i>", { class: 'fa fa-minus', 'aria-hidden': 'true', 'title': 'Negative Threshold' });
    $fa.on('click', () => this.$high_colorscale_input.val(updateThreshold(browser, 0.5)));

    threshDiv.append($fa);

    //this.$container.append($fa);



    this.$high_colorscale_input = $('<input>', { 'type': 'text', 'placeholder': '', 'title': 'color scale input' });
    this.$high_colorscale_input.on('change', function (e) {
      var numeric;
      numeric = numberUnFormatter($(this).val());
      if (isNaN(numeric)); else {
        browser.setColorScaleThreshold(numeric);
      }
    });

    // this.$container.append(this.$high_colorscale_input);
    threshDiv.append(this.$high_colorscale_input);

    $fa = $("<i>", { class: 'fa fa-plus', 'aria-hidden': 'true', 'title': 'Positive Threshold' });
    $fa.on('click', () => this.$high_colorscale_input.val(updateThreshold(browser, 2.0)));
    // this.$container.append($fa);
    threshDiv.append($fa);

    this.$container.append(threshDiv);

    let zoomDiv = $("<div>", { class: 'zoom', 'aria-hidden': 'true' });

    $fa = $("<span>", { class: 'zoom-out', 'aria-hidden': 'true', 'title': 'Zoom out' });
    $fa.on('click', () => {
      let _id = this.browser.id;
      let _cur_locus = $(`#hic-chromosome-goto-container-${_id} >input`).val();
      zoom_out(_cur_locus, this.browser);
    });
    zoomDiv.append($fa);
    zoomDiv.append($("<span>", { class: 'line' }))
    $fa = $("<span>", { class: 'zoom-in', 'aria-hidden': 'true', 'title': 'Zoom in' });
    $fa.on('click', () => {
      let _id = this.browser.id;
      let _cur_locus = $(`#hic-chromosome-goto-container-${_id} >input`).val();
      zoom_in(_cur_locus, this.browser)
    });
    zoomDiv.append($fa);
    zoomDiv.append($("<span>", { class: 'line' }))
    // diagnoal
    $fa = $("<span>", { class: 'diagonal', 'id': `display-mode-${this.browser.id}`, 'aria-hidden': 'true', 'title': 'Change Display Mode' });
    $fa.on('click', () => {
      if (this.browser === undefined || this.browser.dataset === undefined) {
        return;
      }
      if (this.browser.isDiag) {
        $fa.removeClass('triangle');
        $fa.addClass('diagonal');
        _browser_diag_hide(this.browser);
      } else {
        $fa.removeClass('diagonal');
        $fa.addClass('triangle');
        _browser_diag_show(this.browser)
      }

    })
    zoomDiv.append($fa);
    //this.$container.append($fa);
    this.$container.append(zoomDiv);




    const handleColorScaleEvent = event => {

      if (event.data instanceof ColorScale) {

        const { threshold } = event.data;
        this.$high_colorscale_input.val(threshold);

        paintSwatch(this.$plusButton, event.data);

      } else if (event.data instanceof RatioColorScale) {

        const { threshold, negativeScale, positiveScale } = event.data;

        this.$high_colorscale_input.val(threshold);

        paintSwatch(this.$minusButton, negativeScale);
        paintSwatch(this.$plusButton, positiveScale);
      }

    };

    this.browser.eventBus.subscribe("ColorScale", handleColorScaleEvent);

    const handleDisplayModeEvent = event => {

      if ("AOB" === event.data || "BOA" === event.data || "AMB" === event.data) {

        this.$minusButton.show();

        const { negativeScale, positiveScale } = this.browser.contactMatrixView.ratioColorScale;
        paintSwatch(this.$minusButton, negativeScale);
        paintSwatch(this.$plusButton, positiveScale);

      } else {
        this.$minusButton.hide();
        paintSwatch(this.$plusButton, this.browser.contactMatrixView.colorScale);
      }
    };

    this.browser.eventBus.subscribe("DisplayMode", handleDisplayModeEvent);

    this.browser.eventBus.subscribe("MapLoad", (ignore) => {
      paintSwatch(this.$mapBackgroundColorpickerButton, this.browser.contactMatrixView.backgroundColor);
    });

  }
}

function paintSwatch($swatch, { r, g, b }) {
  $swatch.get(0).style.backgroundColor = IGVColor.rgbToHex(IGVColor.rgbColor(r, g, b));
}

const updateThreshold = (browser, scaleFactor) => {
  const colorScale = browser.getColorScale();
  browser.setColorScaleThreshold(colorScale.getThreshold() * scaleFactor);
  return numberFormatter(colorScale.getThreshold());
};

function createColorPicker(browser, $parent, type) {

  let defaultColors;
  let colorHandler;
  if (undefined === type) {

    const { r, g, b } = ContactMatrixView.defaultBackgroundColor;
    defaultColors = [IGVColor.rgbToHex(IGVColor.rgbColor(r, g, b))];

    colorHandler = hexString => {
      $parent.get(0).style.backgroundColor = hexString;
      const [r, g, b] = IGVColor.hexToRgb(hexString).split('(').pop().split(')').shift().split(',').map(str => parseInt(str, 10));
      browser.contactMatrixView.setBackgroundColor({ r, g, b });

    };

  } else {

    defaultColors = [defaultRatioColorScaleConfig.negative, defaultRatioColorScaleConfig.positive].map(({ r, g, b }) => IGVColor.rgbToHex(IGVColor.rgbColor(r, g, b)));

    colorHandler = hexString => {
      $parent.get(0).style.backgroundColor = hexString;
      const [r, g, b] = IGVColor.hexToRgb(hexString).split('(').pop().split(')').shift().split(',').map(str => parseInt(str, 10));
      browser.getColorScale().setColorComponents({ r, g, b }, type);
      browser.repaintMatrix();
    };

  }

  const config =
  {
    parent: $parent.get(0),
    top: 64,
    left: 64,
    width: 432,
    defaultColors,
    colorHandler
  };

  return new ColorPicker(config)

}

function presentColorPicker(presentable, hideableA, hideableB) {
  hideableA.hide();
  hideableB.hide();
  presentable.show();
}

function colorSwatch(rgbString) {
  const swatch = div$1({ class: 'igv-ui-color-swatch' });
  swatch.style.backgroundColor = IGVColor.rgbToHex(rgbString);
  return $(swatch)
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

class ControlMapWidget {

  constructor(browser, $hic_navbar_container) {

    this.browser = browser;

    const $parent = $hic_navbar_container.find("div[id$='lower-hic-nav-bar-widget-container']");

    this.$container = $('<div class="hic-control-map-selector-container">');
    this.$container.hide();
    $parent.append(this.$container);

    // select
    this.$select = $('<select>');
    this.$select.attr('name', 'control_map_selector');
    this.$container.append(this.$select);

    // // a-b toggle icon
    // const $toggle_container = $('<div>');
    // this.$container.append($toggle_container);

    // // cycle button
    // const $cycle_container = $('<div>');
    // this.$container.append($cycle_container);

    this.controlMapHash = new ControlMapHash(browser, this.$select);

    const self = this;

    browser.eventBus.subscribe("ControlMapLoad", function (event) {
      self.controlMapHash.updateOptions(browser.getDisplayMode());
      self.$container.show();
    });

    browser.eventBus.subscribe("MapLoad", function (event) {
      if (!browser.controlDataset) {
        self.$container.hide();
      }
    });

    browser.eventBus.subscribe("DisplayMode", function (event) {
      self.controlMapHash.updateOptions(event.data);
    });

  }

  toggleDisplayMode() {
    this.controlMapHash.toggleDisplayMode();
  }

  toggleDisplayModeCycle() {
    this.controlMapHash.toggleDisplayModeCycle();
  }

  getDisplayModeCycle() {
    return this.controlMapHash.cycleID;
  }
}


class ControlMapHash {

  constructor(browser, $select) {

    const self = this;

    this.browser = browser;
    this.$select = $select;
    const A = { title: 'A', value: 'A', other: 'B' };
    const B = { title: 'B', value: 'B', other: 'A' };
    const AOB = { title: 'A/B', value: 'AOB', other: 'BOA' };
    const BOA = { title: 'B/A', value: 'BOA', other: 'AOB' };
    const AMB = { title: 'AMB', value: 'AMB', other: 'BMA' };

    this.hash =
    {
      'A': A,
      'B': B,
      'AOB': AOB,
      'BOA': BOA,
      'AMB': AMB
    };

    this.$select.on('change', function (e) {
      let value;

      self.disableDisplayModeCycle();

      value = $(this).val();
      self.setDisplayMode(value);
    });
  }

  disableDisplayModeCycle() {

    if (this.cycleID) {

      clearTimeout(this.cycleID);
      this.cycleID = undefined;

      this.$cycle_solid.hide();
      this.$cycle_outline.show();
    }

  }

  toggleDisplayModeCycle() {
    let self = this;

    if (this.cycleID) {

      this.disableDisplayModeCycle();
    } else {

      doToggle();

      this.$cycle_solid.show();
      this.$cycle_outline.hide();
    }

    function doToggle() {
      self.cycleID = setTimeout(async function () {
        await self.toggleDisplayMode();
        doToggle();
      }, 2500);
    }

  }

  async toggleDisplayMode() {

    let displayModeOld,
      displayModeNew,
      str;

    displayModeOld = this.browser.getDisplayMode();

    // render new display mode
    displayModeNew = this.hash[displayModeOld].other;
    await this.browser.setDisplayMode(displayModeNew);

    // update exchange icon
    this.hash[displayModeNew].$hidden.hide();
    this.hash[displayModeNew].$shown.show();

    // update select element
    str = 'option[value=' + displayModeNew + ']';
    this.$select.find(str).prop('selected', true);
  }
  setDisplayMode(displayMode) {
    this.browser.setDisplayMode(displayMode);
  }

  updateOptions(displayMode) {
    let self = this;
    this.$select.empty();
    Object.keys(this.hash).forEach(function (key) {
      let item,
        option;

      item = self.hash[key];

      option = $('<option>').attr('title', item.title).attr('value', item.value).text(item.title);

      if (displayMode === item.value) {

        option.attr('selected', true);
      }

      self.$select.append(option);
    });
  }
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

var labels =
{
  NONE: 'None',
  VC: 'Coverage',
  VC_SQRT: 'Coverage - Sqrt',
  KR: 'Balanced',
  INTER_VC: 'Interchromosomal Coverage',
  INTER_VC_SQRT: 'Interchromosomal Coverage - Sqrt',
  INTER_KR: 'Interchromosomal Balanced',
  GW_VC: 'Genome-wide Coverage',
  GW_VC_SQRT: 'Genome-wide Coverage - Sqrt',
  GW_KR: 'Genome-wide Balanced'
};

class NormalizationWidget {

  constructor(browser, $hic_navbar_container) {

    this.browser = browser;

    const $parent = $hic_navbar_container.find("div[id$='lower-hic-nav-bar-widget-container']");

    this.$container = $("<div>", { class: 'hic-normalization-selector-container', title: 'Normalization' });
    $parent.append(this.$container);

    // let $label = $('<div>');
    // $label.text('Norm');
    // this.$container.append($label);
    // $label.hide();

    this.$normalization_selector = $('<select name="select">');
    this.$normalization_selector.attr('name', 'normalization_selector');
    this.$normalization_selector.on('change', () => {
      this.browser.normalization = this.$normalization_selector.val();
      this.browser.setNormalization(this.$normalization_selector.val());
    });
    this.$container.append(this.$normalization_selector);

    this.$spinner = $('<div>');
    this.$spinner.text('Loading ...');
    this.$container.append(this.$spinner);
    this.$spinner.hide();

    this.browser.eventBus.subscribe("MapLoad", this);
    this.browser.eventBus.subscribe("NormVectorIndexLoad", this);
    this.browser.eventBus.subscribe("NormalizationFileLoad", this);
    this.browser.eventBus.subscribe("NormalizationExternalChange", this);

  }

  startNotReady() {
    this.$normalization_selector.hide();
    this.$spinner.show();
  }

  stopNotReady() {
    this.$spinner.hide();
    this.$normalization_selector.show();
  }

  receiveEvent(event) {


    if ("NormVectorIndexLoad" === event.type) {

      updateOptions.call(this);

      // TODO -- end norm widget "not ready" state
      this.stopNotReady();

    } else if ("NormalizationFileLoad" === event.type) {
      if (event.data === "start") {
        this.startNotReady();
      } else {
        this.stopNotReady();
      }
    } else if ("NormalizationExternalChange" === event.type) {

      this.$normalization_selector
        .find('option')
        .filter(function (index) {
          var s1 = this.value;
          var s2 = event.data;
          return s1 === s2;
        })
        .prop('selected', true);
    }

    async function updateOptions() {
      const norm = this.browser.state.normalization;
      const normalizationTypes = await this.browser.getNormalizationOptions();
      if (normalizationTypes) {
        const elements = normalizationTypes.map(function (normalization) {
          const label = labels[normalization] || normalization;
          const isSelected = (norm === normalization);
          const titleString = (label === undefined ? '' : ' title = "' + label + '" ');
          const valueString = ' value=' + normalization + (isSelected ? ' selected' : '');
          // const labelPresentation = '&nbsp &nbsp' + label + '&nbsp &nbsp';
          const labelPresentation = label;
          return '<option' + titleString + valueString + '>' + labelPresentation + '</option>';
        });

        this.$normalization_selector.empty();
        this.$normalization_selector.append(elements.join(''));
      }
    }
  }
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

/**
* Created by dat on 3/22/17.
*/

class ChromosomeSelectorWidget {

  constructor(browser, $container) {

    this.browser = browser;

    this.$x_axis_selector = $container.find("select[name='x-axis-selector']");
    this.$y_axis_selector = $container.find("select[name='y-axis-selector']");

    this.$x_axis_selector.on('change', () => {

      const str = this.$x_axis_selector.val();

      if (0 === parseInt(str, 10)) {
        this.$y_axis_selector.val(str);
      } else if (0 === parseInt(this.$y_axis_selector.val(), 10)) {
        this.$y_axis_selector.val(str);
      }

    });

    this.$y_axis_selector.on('change', () => {

      const str = this.$y_axis_selector.val();

      if (0 === parseInt(str, 10)) {
        this.$x_axis_selector.val(str);
      } else if (0 === parseInt(this.$x_axis_selector.val(), 10)) {
        this.$x_axis_selector.val(str);
      }

    });

    this.$y_axis_selector.next('div').on('click', async () => {
      const chr1Index = parseInt(this.$x_axis_selector.find('option:selected').val(), 10);
      const chr2Index = parseInt(this.$y_axis_selector.find('option:selected').val(), 10);
      //call3d(this.id, chr1Index, chr2Index,true);
      await browser.setChromosomes(chr1Index, chr2Index);
    });

    this.dataLoadConfig =
    {
      receiveEvent: event => {
        if (event.type === "MapLoad") {
          this.respondToDataLoadWithDataset(event.data);
        }
      }
    };

    browser.eventBus.subscribe("MapLoad", this.dataLoadConfig);

    this.locusChangeConfig =
    {
      receiveEvent: event => {
        if (event.type === "LocusChange") {
          this.respondToLocusChangeWithState(event.data.state);
        }
      }
    };

    browser.eventBus.subscribe("LocusChange", this.locusChangeConfig);

  }

  respondToDataLoadWithDataset(dataset) {

    var elements,
      str,
      $xFound,
      $yFound;

    this.$x_axis_selector.empty();
    this.$y_axis_selector.empty();

    elements = dataset.chromosomes.map(({ name }, index) => `<option value=${index.toString()}>${name}</option>`);

    this.$x_axis_selector.append(elements.join(''));
    this.$y_axis_selector.append(elements.join(''));

    str = 'option[value=' + this.browser.state.chr1.toString() + ']';
    $xFound = this.$x_axis_selector.find(str);
    $xFound.prop('selected', true);

    str = 'option[value=' + this.browser.state.chr2.toString() + ']';
    $yFound = this.$y_axis_selector.find(str);
    $yFound.prop('selected', true);
  }

  respondToLocusChangeWithState(state) {
    var ssx,
      ssy,
      $xFound,
      $yFound;

    $xFound = this.$x_axis_selector.find('option');
    $yFound = this.$y_axis_selector.find('option');

    // this happens when the first dataset is loaded.
    if (0 === $xFound.length || 0 === $yFound.length) {
      return;
    }

    $xFound = this.$x_axis_selector.find('option:selected');
    $yFound = this.$y_axis_selector.find('option:selected');

    $xFound.prop('selected', false);
    $yFound.prop('selected', false);

    // chr1 = parseInt($xFound.val(), 10);
    // chr2 = parseInt($yFound.val(), 10);
    // // It is the pair of chromosomes that is important,  1-2 == 2-1,  so update only if the pair does not match
    // if (false === ((chr1 === state.chr1 && chr2 === state.chr2) || (chr1 === state.chr2 && chr2 === state.chr1))) {
    //     ssx = 'option[value=' + state.chr1.toString() + ']';
    //     this.$x_axis_selector.find(ssx).attr('selected', 'selected');
    //
    //     ssx = 'option[value=' + state.chr2.toString() + ']';
    //     this.$y_axis_selector.find(ssx).attr('selected', 'selected');
    // }

    ssx = 'option[value=' + state.chr1.toString() + ']';
    ssy = 'option[value=' + state.chr2.toString() + ']';

    this.$x_axis_selector.find(ssx).prop('selected', true);
    this.$y_axis_selector.find(ssy).prop('selected', true);

  }
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

class AnnotationWidget {

  constructor(browser, $container, { title, alertMessage }, trackListRetrievalCallback) {

    this.browser = browser;
    this.trackListRetrievalCallback = trackListRetrievalCallback;

    annotationPresentationButton.call(this, $container, alertMessage);

    annotationPanel.call(this, this.browser.$root, title);

  }

  updateBody(tracks) {

    var self = this,
      trackPairs,

      isTrack2D,
      zi;

    self.$annotationPanel.find('.hic-annotation-row-container').remove();

    isTrack2D = (tracks[0] instanceof Track2D);

    if (isTrack2D) {
      // Reverse list to present layers in "z" order.
      for (zi = tracks.length - 1; zi >= 0; zi--) {
        annotationPanelRow.call(self, self.$annotationPanel, tracks[zi]);
      }
    } else {
      trackPairs = tracks;
      for (let trackRenderer of trackPairs) {
        annotationPanelRow.call(self, self.$annotationPanel, trackRenderer);
      }
    }
  }
}

function annotationPresentationButton($parent, alertMessage) {

  const $button = $parent.find("button");

  $button.on('click', () => {

    const list = this.trackListRetrievalCallback();

    if (list.length > 0) {
      this.updateBody(this.trackListRetrievalCallback());
      this.$annotationPanel.toggle();
    } else {
      Alert$1.presentAlert(alertMessage);
    }

    this.browser.hideMenu();
  });
}

function annotationPanel($parent, title) {

  var self = this,
    $panel_header,
    $div,
    $fa;

  this.$annotationPanel = $('<div>', { class: 'hic-annotation-panel-container' });
  $parent.append(this.$annotationPanel);

  // close button container
  $panel_header = $('<div>', { class: 'hic-annotation-panel-header' });
  this.$annotationPanel.append($panel_header);

  // panel title
  $div = $('<div>');
  $div.text(title);
  $panel_header.append($div);

  // close button
  $div = $('<div>', { class: 'hic-menu-close-button' });
  $panel_header.append($div);

  $fa = $("<i>", { class: 'fa fa-times' });
  $div.append($fa);

  $fa.on('click', function (e) {
    self.$annotationPanel.toggle();
  });

  // TODO: Continue changes for load functions added to side panel
  // load container
  // $load_container = $('<div>', { class:'hic-annotation-panel-load-container' });
  // this.$annotationPanel.append($load_container);
  //
  // // Load
  // $div = $('<div>');
  // $load_container.append($div);
  // $div.text('Load:');
  //
  // // Blah
  // $div = $('<div>');
  // $load_container.append($div);
  // $div.text('Blah');

  //this.$annotationPanel.draggable();
  makeDraggable$1(this.$annotationPanel.get(0), $panel_header.get(0));
  this.$annotationPanel.hide();
}

function annotationPanelRow($container, track) {
  var self = this,
    $colorpickerContainer,
    $colorpickerButton,
    $row_container,
    $row,
    $hideShowTrack,
    $deleteTrack,
    $upTrack,
    $downTrack,
    $e,
    $o,
    hidden_color = '#f7f7f7',
    str,
    isTrack2D,
    trackList,
    xyTrackRendererPair,
    trackRenderer,
    track1D,
    index,
    upp,
    dwn;

  isTrack2D = (track instanceof Track2D);
  trackList = this.trackListRetrievalCallback();

  if (false === isTrack2D) {
    xyTrackRendererPair = track;
    track1D = xyTrackRendererPair.x.track;
    trackRenderer = xyTrackRendererPair.x.track.trackView;
  }

  // row container
  $row_container = $('<div>', { class: 'hic-annotation-row-container' });
  $container.append($row_container);

  // one row
  $row = $('<div>', { class: 'hic-annotation-modal-row' });
  $row_container.append($row);

  // track name
  $e = $("<div>");
  $e.text(isTrack2D ? track.config.name : track1D.config.name);
  $row.append($e);

  // track hide/show
  if (isTrack2D) {
    str = (true === track.isVisible) ? 'fa fa-eye fa-lg' : 'fa fa-eye-slash fa-lg';
    $hideShowTrack = $("<i>", { class: str, 'aria-hidden': 'true' });
    $row.append($hideShowTrack);
    $hideShowTrack.on('click', function (e) {

      if ($hideShowTrack.hasClass('fa-eye')) {
        $hideShowTrack.addClass('fa-eye-slash');
        $hideShowTrack.removeClass('fa-eye');
        track.isVisible = false;
      } else {
        $hideShowTrack.addClass('fa-eye');
        $hideShowTrack.removeClass('fa-eye-slash');
        track.isVisible = true;
      }

      self.browser.contactMatrixView.clearImageCaches();
      self.browser.contactMatrixView.update();

    });
  }

  // if (isTrack2D) {

  //     // matrix diagonal widget
  //     const $matrix_diagonal_div = $('<div>', {class: 'matrix-diagonal-widget-container matrix-diagonal-widget-all'});
  //     $row.append($matrix_diagonal_div);
  //     $matrix_diagonal_div.on('click.matrix_diagonal_div', (e) => {
  //         e.preventDefault;
  //         matrixDiagionalWidgetHandler($matrix_diagonal_div, track);
  //         self.browser.eventBus.post(HICEvent('TrackState2D', track));
  //     });

  // }

  // color swatch selector button
  $colorpickerButton = annotationColorSwatch(isTrack2D ? track.getColor() : track1D.color);
  $row.append($colorpickerButton);

  // color swatch selector
  $colorpickerContainer = createAnnotationPanelColorpickerContainer($row_container, { width: ((29 * 24) + 1 + 1) }, function () {
    $row.next('.hic-color-swatch-container').toggle();
  });

  $colorpickerButton.on('click', function (e) {
    $row.next('.hic-color-swatch-container').toggle();
  });

  $colorpickerContainer.hide();

  const colorHandler = color => {

    var $swatch;

    $swatch = $row.find('.fa-square');
    $swatch.css({ 'color': color });

    if (isTrack2D) {
      track.color = color;
      self.browser.eventBus.post(HICEvent('TrackState2D', track));
    } else {
      trackRenderer.setColor(color);
    }

  };

  createColorSwatchSelector($colorpickerContainer.get(0), colorHandler);


  // track up/down
  $e = $('<div>', { class: 'up-down-arrow-container' });
  $row.append($e);

  $upTrack = $("<i>", { class: 'fa fa-arrow-up', 'aria-hidden': 'true' });
  $e.append($upTrack);

  $downTrack = $("<i>", { class: 'fa fa-arrow-down', 'aria-hidden': 'true' });
  $e.append($downTrack);

  if (1 === trackList.length) {
    $upTrack.css('color', hidden_color);
    $downTrack.css('color', hidden_color);
  } else if (track === trackList[0]) {
    $o = isTrack2D ? $downTrack : $upTrack;
    $o.css('color', hidden_color);
  } else if (track === trackList[trackList.length - 1]) {
    $o = isTrack2D ? $upTrack : $downTrack;
    $o.css('color', hidden_color);
  }

  index = trackList.indexOf(track);

  upp = function (e) {

    track = trackList[(index + 1)];
    trackList[(index + 1)] = trackList[index];
    trackList[index] = track;
    if (isTrack2D) {
      self.browser.eventBus.post(HICEvent('TrackState2D', trackList));
      self.updateBody(trackList);
    } else {
      self.browser.updateLayout();
      self.updateBody(trackList);
    }
  };

  dwn = function (e) {

    track = trackList[(index - 1)];
    trackList[(index - 1)] = trackList[index];
    trackList[index] = track;
    if (isTrack2D) {
      self.browser.eventBus.post(HICEvent('TrackState2D', trackList));
      self.updateBody(trackList);
    } else {
      self.browser.updateLayout();
      self.updateBody(trackList);
    }
  };

  $upTrack.on('click', isTrack2D ? upp : dwn);

  $downTrack.on('click', isTrack2D ? dwn : upp);


  // track delete
  $deleteTrack = $("<i>", { class: 'fa fa-trash-o fa-lg', 'aria-hidden': 'true' });
  $row.append($deleteTrack);
  $deleteTrack.on('click', function (e) {
    var index;

    if (isTrack2D) {

      index = trackList.indexOf(track);

      trackList.splice(index, 1);

      self.browser.contactMatrixView.clearImageCaches();
      self.browser.contactMatrixView.update();

      self.browser.eventBus.post(HICEvent('TrackLoad2D', trackList));
    } else {
      self.browser.layoutController.removeTrackXYPair(trackRenderer.trackRenderPair);
    }

    self.updateBody(trackList);
  });
}

function matrixDiagionalWidgetHandler($icon, track2D) {

  if ($icon.hasClass('matrix-diagonal-widget-all')) {

    $icon.removeClass('matrix-diagonal-widget-all');

    $icon.addClass('matrix-diagonal-widget-lower');
    track2D.displayMode = Track2DDisplaceModes.displayLowerMatrix;
  } else if ($icon.hasClass('matrix-diagonal-widget-lower')) {

    $icon.removeClass('matrix-diagonal-widget-lower');

    $icon.addClass('matrix-diagonal-widget-upper');
    track2D.displayMode = Track2DDisplaceModes.displayUpperMatrix;
  } else if ($icon.hasClass('matrix-diagonal-widget-upper')) {

    $icon.removeClass('matrix-diagonal-widget-upper');

    $icon.addClass('matrix-diagonal-widget-all');
    track2D.displayMode = Track2DDisplaceModes.displayAllMatrix;
  } else {

    $icon.addClass('matrix-diagonal-widget-all');
    track2D.displayMode = Track2DDisplaceModes.displayAllMatrix;
  }
}

function annotationColorSwatch(rgbString) {
  var $swatch,
    $fa;

  $swatch = $('<div>', { class: 'igv-color-swatch' });

  $fa = $('<i>', { class: 'fa fa-square fa-lg', 'aria-hidden': 'true' });
  $swatch.append($fa);

  $fa.css({ color: rgbString });

  return $swatch;
}

function createAnnotationPanelColorpickerContainer($parent, config, closeHandler) {

  var $container,
    $header,
    $fa;

  $container = $('<div>', { class: 'hic-color-swatch-container' });
  $parent.append($container);

  // width
  if (config && config.width) {
    $container.width(config.width);
  }

  // height
  if (config && config.height) {
    $container.height(config.height);
  }

  // header
  $header = $('<div>');
  $container.append($header);

  // close button
  $fa = $("<i>", { class: 'fa fa-times' });
  $header.append($fa);

  $fa.on('click', function (e) {
    closeHandler();
  });

  return $container;
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

/**
* Created by dat on 3/14/17.
*/

class SweepZoom {

  constructor(browser, $target) {

    this.browser = browser;

    this.$target = $target;

    this.$rulerSweeper = $target.find("div[id$='-sweep-zoom-container']");
    this.$rulerSweeper.hide();

    this.sweepRect = {};
  }

  initialize(pageCoords) {

    this.anchor = pageCoords;
    this.coordinateFrame = this.$rulerSweeper.parent().offset();
    this.aspectRatio = this.$target.width() / this.$target.height();
    this.sweepRect.x = {
      x: pageCoords.x,
      y: pageCoords.y,
      width: 1,
      height: 1
    };
    this.clipped = { value: false };
  }

  update(pageCoords) {

    var anchor = this.anchor,
      dx = Math.abs(pageCoords.x - anchor.x),
      dy = Math.abs(pageCoords.y - anchor.y);

    // Adjust deltas to conform to aspect ratio
    if (dx / dy > this.aspectRatio) {
      dy = dx / this.aspectRatio;
    } else {
      dx = dy * this.aspectRatio;
    }

    this.sweepRect.width = dx;
    this.sweepRect.height = dy;
    this.sweepRect.x = anchor.x < pageCoords.x ? anchor.x : anchor.x - dx;
    this.sweepRect.y = anchor.y < pageCoords.y ? anchor.y : anchor.y - dy;


    this.$rulerSweeper.width(this.sweepRect.width);
    this.$rulerSweeper.height(this.sweepRect.height);


    this.$rulerSweeper.offset(
      {
        left: this.sweepRect.x,
        top: this.sweepRect.y
      }
    );
    this.$rulerSweeper.show();

  }

  commit() {


    this.$rulerSweeper.hide();

    const state = this.browser.state;

    // bp-per-bin
    const resolution = this.browser.resolution();

    // Convert page -> offset coordinates
    const posX = this.sweepRect.x - this.$target.offset().left;
    const posY = this.sweepRect.y - this.$target.offset().top;


    // bp = ((bin + pixel/pixel-per-bin) / bp-per-bin)
    const x = (state.x + (posX / state.pixelSize)) * resolution;
    const y = (state.y + (posY / state.pixelSize)) * resolution;

    // bp = ((bin + pixel/pixel-per-bin) / bp-per-bin)
    const width = (this.sweepRect.width / state.pixelSize) * resolution;
    const height = (this.sweepRect.height / state.pixelSize) * resolution;

    // bp = bp + bp
    const xMax = x + width;
    const yMax = y + height;

    const minimumResolution = this.browser.dataset.bpResolutions[this.browser.dataset.bpResolutions.length - 1];
    this.browser.goto(state.chr1, x, xMax, state.chr2, y, yMax, minimumResolution);

  }
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

class ScrollbarWidget {

  constructor(browser, $x_axis_scrollbar_container, $y_axis_scrollbar_container) {

    this.browser = browser;
    this.isDragging = false;

    // x-axis
    this.$x_axis_scrollbar_container = $x_axis_scrollbar_container;
    this.$x_axis_scrollbar = this.$x_axis_scrollbar_container.find("div[id$='-x-axis-scrollbar']");
    this.$x_label = this.$x_axis_scrollbar.find('div');
    this.$x_label.text('');

    // y-axis
    this.$y_axis_scrollbar_container = $y_axis_scrollbar_container;
    this.$y_axis_scrollbar = this.$y_axis_scrollbar_container.find("div[id$='-y-axis-scrollbar']");
    this.$y_label = this.$y_axis_scrollbar.find('.scrollbar-label-rotation-in-place');
    this.$y_label.text('');

    this.browser.eventBus.subscribe("LocusChange", this);

  }

  css2Bin(chromosome, $element, attribute) {
    var numer,
      denom,
      percentage;

    numer = $element.css(attribute).slice(0, -2);
    denom = $element.parent().css('left' === attribute ? 'width' : 'height').slice(0, -2);
    percentage = parseInt(numer, 10) / parseInt(denom, 10);

    return percentage * chromosome.size / this.browser.dataset.bpResolutions[this.browser.state.zoom];
  }

  receiveEvent(event) {
    var self = this,
      chromosomeLengthsBin,
      chromosomeLengthsPixel,
      pixels,
      bins,
      percentage,
      percentages;

    if (!this.isDragging && event.type === "LocusChange") {

      var state = event.data.state,
        dataset = self.browser.dataset;

      if (0 === state.chr1) {
        this.$x_axis_scrollbar.hide();
        this.$y_axis_scrollbar.hide();
      } else {

        this.$x_axis_scrollbar.show();
        this.$y_axis_scrollbar.show();

        this.$x_axis_scrollbar_container.show();
        this.$y_axis_scrollbar_container.show();

        const { chr1, chr2, zoom, pixelSize, x, y } = state;

        // bp / bp-per-bin -> bin
        chromosomeLengthsBin = [chr1, chr2].map(chr => {
          return dataset.chromosomes[chr].size / dataset.bpResolutions[zoom]
        });

        chromosomeLengthsPixel = chromosomeLengthsBin.map(bin => bin * pixelSize);

        pixels = [this.browser.contactMatrixView.getViewDimensions().width, this.browser.contactMatrixView.getViewDimensions().height];

        // pixel / pixel-per-bin -> bin
        bins = [pixels[0] / pixelSize, pixels[pixels.length - 1] / pixelSize];

        // bin / bin -> percentage
        percentages = bins.map((bin, i) => {
          const binPercentage = Math.min(bin, chromosomeLengthsBin[i]) / chromosomeLengthsBin[i];
          const pixelPercentage = Math.min(chromosomeLengthsPixel[i], pixels[i]) / pixels[i];
          return Math.max(1, Math.round(100 * binPercentage * pixelPercentage));
        });

        this.$x_axis_scrollbar.css('width', `${percentages[0]}%`);
        this.$y_axis_scrollbar.css('height', `${percentages[percentages.length - 1]}%`);

        // bin / bin -> percentage
        percentage = Math.round(100 * x / chromosomeLengthsBin[0]);
        this.$x_axis_scrollbar.css('left', `${percentage}%`);

        // bin / bin -> percentage
        percentage = Math.round(100 * y / chromosomeLengthsBin[chromosomeLengthsBin.length - 1]);
        this.$y_axis_scrollbar.css('top', `${percentage}%`);

        this.$x_label.text(dataset.chromosomes[chr1].name);
        this.$y_label.text(dataset.chromosomes[chr2].name);

      }

    }
  }
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

const DEFAULT_PIXEL_SIZE = 1;
const MAX_PIXEL_SIZE = 12;
const DEFAULT_ANNOTATION_COLOR$1 = "rgb(22, 129, 198)";

class HICBrowser {

  constructor($app_container, config) {

    this.config = config;
    this.config.hideIdeogram = true;
    this.config.hideGear = false;
    this.config.hideRuler = true;
    this.config.hideSequence = true;
    this.config.hideScroll = false;
    this.isSync = false; // 同步
    this.isDiag = false; // 对角线
    this.isForce = false; // 强制同步

    //console.log("config:",config);
    this.figureMode = config.figureMode || config.miniMode;    // Mini mode for backward compatibility
    this.resolutionLocked = false;
    this.eventBus = new EventBus();

    this.showTrackLabelAndGutter = true;
    if (config.id) {
      this.id = `browser_${config.id}`;
    }
    else {
      this.id = `browser_${guid()}`;
    }
    this.trackPairs = [];
    this.tracks2D = [];
    this.normVectorFiles = [];

    this.synchable = config.synchable !== false;
    this.synchedBrowsers = [];

    this.isMobile = isMobile();

    this.$root = $(`<div class="hic-root unselect" id = ${this.id}>`);

    if (config.width) {
      this.$root.css("width", String(config.width));
    }
    if (config.height) {
      this.$root.css("height", String(config.height + getNavbarHeight() - 36));
    }

    let s_span = $(`<span class="hic-selected-span"></span>`)
    this.$root.append(s_span);


    let viewer = $('<div class="hic-browser-div"></div>');
    //calc(100% - (0px + 40px + 20px) - ${String(12)}px)
    // margin-left:calc(40px + ${String(nav_bar_widget_container_margin  + 2)}px )

    // 创建IGV viewer
    let track_container_x =
      `
      <div style=" max-width:100%" id="igv-${this.id}" class="igv-browser-div">
      </div>
      `;

    viewer.append(this.$root);
    viewer.append(track_container_x);
    $app_container.append(viewer);

    //$app_container.append(this.$root);

    // 坐标轴 canvas
    this.layoutController = new LayoutController(this, this.$root);

    // nav bar related objects
    this.locusGoto = new LocusGoto(this, getNavbarContainer(this));
    this.resolutionSelector = new ResolutionSelector(this, getNavbarContainer(this));
    this.resolutionSelector.setResolutionLock(this.resolutionLocked);
    this.colorscaleWidget = new ColorScaleWidget(this, getNavbarContainer(this));
    this.controlMapWidget = new ControlMapWidget(this, getNavbarContainer(this));
    this.normalizationSelector = new NormalizationWidget(this, getNavbarContainer(this));
    this.inputDialog = new InputDialog($app_container.get(0), this);

    // contact map container related objects
    const sweepZoom = new SweepZoom(this, this.layoutController.getContactMatrixViewport());
    const scrollbarWidget = new ScrollbarWidget(this, this.layoutController.getXAxisScrollbarContainer(), this.layoutController.getYAxisScrollbarContainer());

    const colorScale = new ColorScale(defaultColorScaleConfig);

    const ratioColorScale = new RatioColorScale(defaultRatioColorScaleConfig.threshold);
    ratioColorScale.setColorComponents(defaultRatioColorScaleConfig.negative, '-');
    ratioColorScale.setColorComponents(defaultRatioColorScaleConfig.positive, '+');
    const backgroundColor = config.backgroundColor || ContactMatrixView.defaultBackgroundColor;
    this.contactMatrixView = new ContactMatrixView(this, this.layoutController.getContactMatrixViewport(), sweepZoom, scrollbarWidget, colorScale, ratioColorScale, backgroundColor);

    this.$menu = this.createMenu(this.$root);
    this.$menu.hide();

    const that = this;
    for (let igv_set_item of ['Ideogram', 'Ruler', 'Sequence', 'Gear', 'Scroll']) {
      let set_igv = this.$menu.find(`#set_${igv_set_item}`);
      set_igv.change(function () {
        let check = $(this).is(':checked');
        that.config[`hide${igv_set_item}`] = check;
        updateIGV(that.id, igv_set_item, check);
      })
    }
    this.chromosomeSelector = new ChromosomeSelectorWidget(this, this.$menu.find('.hic-chromosome-selector-widget-container'));

    const annotation2DWidgetConfig =
    {
      title: '2D Annotations',
      alertMessage: 'No 2D annotations currently loaded for this map'
    };

    this.annotation2DWidget = new AnnotationWidget(this, this.$menu.find(".hic-annotation-presentation-button-container"), annotation2DWidgetConfig, () => this.tracks2D);

    // prevent user interaction during lengthy data loads
    this.$user_interaction_shield = $('<div>', { class: 'hic-root-prevent-interaction' });
    this.$root.append(this.$user_interaction_shield);
    this.$user_interaction_shield.hide();

    this.hideCrosshairs();

    //this.eventBus.subscribe("LocusChange", this);
  }

  // HiC 浏览器init
  async init(config) {
    this.state = config.state ? config.state : State.default();
    this.pending = new Map();
    this.eventBus.hold();
    this.contactMatrixView.disableUpdates = true;

    try {
      this.contactMatrixView.startSpinner();
      this.$user_interaction_shield.show();

      // if (!config.name) config.name = await extractName(config)
      // const prefix = hasControl ? "A: " : "";
      // browser.$contactMaplabel.text(prefix + config.name);
      // browser.$contactMaplabel.attr('title', config.name);

      await this.loadHicFile(config, true);

      if (config.controlUrl) {
        await this.loadHicControlFile({
          url: config.controlUrl,
          name: config.controlName,
          nvi: config.controlNvi,
          isControl: true
        }, true);
      }

      if (config.cycle) {
        config.displayMode = "A";
      }

      if (config.displayMode) {
        this.contactMatrixView.displayMode = config.displayMode;
        this.eventBus.post({ type: "DisplayMode", data: config.displayMode });
      }
      if (config.colorScale) {
        // This must be done after dataset load
        this.contactMatrixView.setColorScale(config.colorScale);
        this.eventBus.post({ type: "ColorScale", data: this.contactMatrixView.getColorScale() });
      }
      if (config.locus) {
        await this.parseGotoInput(config.locus);
      }

      var promises = [];
      if (config.tracks) {
        promises.push(this.loadTracks(config.tracks));
      }

      // TODO -- find out if this is even being used
      if (config.normVectorFiles) {
        config.normVectorFiles.forEach(function (nv) {
          promises.push(this.loadNormalizationFile(nv));
        });
      }
      await Promise.all(promises);

      if (config.normalization) {
        const normalizations = await this.getNormalizationOptions();
        const validNormalizations = new Set(normalizations);
        this.state.normalization = validNormalizations.has(config.normalization) ? config.normalization : 'NONE';
      }

      const tmp = this.contactMatrixView.colorScaleThresholdCache;
      this.eventBus.release();
      this.contactMatrixView.colorScaleThresholdCache = tmp;

      if (config.cycle) {
        this.controlMapWidget.toggleDisplayModeCycle();
      } else {
        await this.update();
      }

    } finally {
      this.contactMatrixView.stopSpinner();
      this.$user_interaction_shield.hide();
      this.contactMatrixView.disableUpdates = false;
      this.contactMatrixView.update();
    }

  }

  createMenu($root) {

    const html =
      `<div class="hic-menu" style="display: none;">
          <div class="hic-menu-close-button">
              <i class="fa fa-times"></i>
          </div>
        <div class="hic-chromosome-selector-widget-container">
          <div>Chromosomes</div>
              <div>
                  <select name="x-axis-selector"></select>
                  <select name="y-axis-selector"></select>
                  <div></div>
              </div>
        </div>
        <div class="hic-igv-setting-container">
            <div>
              <span>Hide Ideogram</span>
              <input id="set_Ideogram" type="checkbox" name="", value="", checked="checked" />
            </div>
            <div>
              <span>Hide Ruler</span>
              <input id="set_Ruler"  type="checkbox" name="", value="", checked="checked" />
            </div>
            <div>
              <span>Hide Sequence</span>
              <input id="set_Sequence" type="checkbox" name="", value="", checked="checked" />
            </div>
            <div>
              <span>Hide Gear</span>
              <input id="set_Gear" type="checkbox" name="", value="" />
            </div>
            <div>
              <span>Hide Scroll</span>
              <input id="set_Scroll" type="checkbox" name="", value="" />
            </div>
        </div>
        <div class="hic-annotation-presentation-button-container">
          <button type="button">2D Annotations</button>
        </div>
      </div>`;

    $root.append($(html));

    const $menu = $root.find(".hic-menu");
    const $fa = $root.find(".fa-times");
    $fa.on('click', () => this.toggleMenu());

    return $menu;

  }

  toggleTrackLabelAndGutterState() {
    this.showTrackLabelAndGutter = !this.showTrackLabelAndGutter;
  }

  toggleMenu() {
    if (this.$menu.is(':visible')) {
      this.hideMenu();
    } else {
      this.showMenu();
    }
  }

  showMenu() {
    this.$menu.show();
  }

  hideMenu() {
    this.$menu.hide();
  };

  startSpinner() {
    this.contactMatrixView.startSpinner();
  }

  stopSpinner() {
    this.contactMatrixView.stopSpinner();
  }

  async setDisplayMode(mode) {
    await this.contactMatrixView.setDisplayMode(mode);
    this.eventBus.post(HICEvent("DisplayMode", mode));
  }

  getDisplayMode() {
    return this.contactMatrixView ? this.contactMatrixView.displayMode : undefined;
  }

  toggleDisplayMode() {
    this.controlMapWidget.toggleDisplayMode();
  }

  async getNormalizationOptions() {

    if (!this.dataset) return [];

    const baseOptions = await this.dataset.getNormalizationOptions();
    if (this.controlDataset) {
      let controlOptions = await this.controlDataset.getNormalizationOptions();
      controlOptions = new Set(controlOptions);
      return baseOptions.filter(base => controlOptions.has(base));
    } else {
      return baseOptions;
    }
  }

  /**
   * Return usable resolutions, that is the union of resolutions between dataset and controlDataset.
   * @returns {{index: *, binSize: *}[]|Array}
   */
  getResolutions() {
    if (!this.dataset) return [];

    const baseResolutions = this.dataset.bpResolutions.map(function (resolution, index) {
      return { index: index, binSize: resolution }
    });
    if (this.controlDataset) {
      let controlResolutions = new Set(this.controlDataset.bpResolutions);
      return baseResolutions.filter(base => controlResolutions.has(base.binSize));
    } else {
      return baseResolutions;
    }
  }

  isWholeGenome() {
    return this.dataset && this.state && this.dataset.isWholeGenome(this.state.chr1)
  }

  getColorScale() {

    if (!this.contactMatrixView) return undefined;

    switch (this.getDisplayMode()) {
      case 'AOB':
      case 'BOA':
        return this.contactMatrixView.ratioColorScale;
      case 'AMB':
        return this.contactMatrixView.diffColorScale;
      default:
        return this.contactMatrixView.colorScale;
    }
  }

  setColorScaleThreshold(threshold) {
    this.contactMatrixView.setColorScaleThreshold(threshold);
  }

  updateCrosshairs({ x, y, xNormalized, yNormalized }) {

    const xGuide = y < 0 ? { left: 0 } : { top: y, left: 0 };
    this.contactMatrixView.$x_guide.css(xGuide);
    this.layoutController.$x_track_guide.css(xGuide);

    const yGuide = x < 0 ? { top: 0 } : { top: 0, left: x };
    this.contactMatrixView.$y_guide.css(yGuide);
    this.layoutController.$y_track_guide.css(yGuide);

    if (this.customCrosshairsHandler) {

      const { x: stateX, y: stateY, pixelSize } = this.state;
      const resolution = this.resolution();

      const xBP = (stateX + (x / pixelSize)) * resolution;
      const yBP = (stateY + (y / pixelSize)) * resolution;

      let { startBP: startXBP, endBP: endXBP } = this.genomicState('x');
      let { startBP: startYBP, endBP: endYBP } = this.genomicState('y');

      this.customCrosshairsHandler({
        xBP,
        yBP,
        startXBP,
        startYBP,
        endXBP,
        endYBP,
        interpolantX: xNormalized,
        interpolantY: yNormalized
      });
    }

  }

  setCustomCrosshairsHandler(crosshairsHandler) {
    this.customCrosshairsHandler = crosshairsHandler;
  }

  hideCrosshairs() {

    this.contactMatrixView.$x_guide.hide();
    this.layoutController.$x_track_guide.hide();

    this.contactMatrixView.$y_guide.hide();
    this.layoutController.$y_track_guide.hide();

  }

  showCrosshairs() {

    this.contactMatrixView.$x_guide.show();
    this.layoutController.$x_track_guide.show();

    this.contactMatrixView.$y_guide.show();
    this.layoutController.$y_track_guide.show();
  }

  genomicState(axis) {

    let width = this.contactMatrixView.getViewDimensions().width;
    let resolution = this.dataset.bpResolutions[this.state.zoom];
    const bpp =
      (this.dataset.chromosomes[this.state.chr1].name.toLowerCase() === "all") ?
        this.genome.getGenomeLength() / width :
        resolution / this.state.pixelSize;

    const gs = {
      bpp: bpp
    };

    if (axis === "x") {
      gs.chromosome = this.dataset.chromosomes[this.state.chr1];
      gs.startBP = this.state.x * resolution;
      gs.endBP = gs.startBP + bpp * width;
    } else {
      gs.chromosome = this.dataset.chromosomes[this.state.chr2];
      gs.startBP = this.state.y * resolution;
      gs.endBP = gs.startBP + bpp * this.contactMatrixView.getViewDimensions().height;
    }
    return gs;
  }



  findTracks(property, value) {
    let f = track2D => value === track2D.config[property];
    return this.tracks2D.filter(f).map(tv => tv);
  }


  async gotoLocus(locus, is_igv) {
    await this.parseGotoInput(locus, is_igv);
    return;
  }

  resize() {
    this.$root.css("width", String(this.config.width));
    this.$root.css("height", String(this.config.height + getNavbarHeight() - 36));
  }

  /**
   * Load a list of 1D genome tracks (wig, etc).
   *
   * NOTE: public API function
   *
   * @param configs
   */
  async loadTrackDatas(configs) {
    try {
      this.contactMatrixView.startSpinner();
      const tracks = [];
      const promises2D = [];
      for (let config of configs) {
        if ("annotation" === config.type && config.color === DEFAULT_ANNOTATION_COLOR$1) {
          delete config.color;
        }

        if (config.max === undefined) {
          config.autoscale = true;
        }

        config.height = trackHeight;

        if (undefined === config.format || "bedpe" === config.format || "interact" === config.format) {
          promises2D.push(Track2D.loadTrack2DData(config, this.genome));
        } else {
          const track = await igv.createTrack(config, this);
          tracks.push(track);
        }
      }

      if (tracks.length > 0) {

        this.layoutController.tracksLoaded(tracks);

        const $gear_container = $('.hic-igv-right-hand-gutter');
        if (true === this.showTrackLabelAndGutter) {
          $gear_container.show();
        } else {
          $gear_container.hide();
        }

        await this.updateLayout();
      }

      if (promises2D.length > 0) {

        const tracks2D = await Promise.all(promises2D);
        if (tracks2D && tracks2D.length > 0) {
          this.tracks2D = this.tracks2D.concat(tracks2D);
          this.eventBus.post(HICEvent("TrackLoad2D", this.tracks2D));
        }
      }

    } catch (error) {
      presentError(errorPrefix, error);
      console.error(error);
    } finally {
      this.contactMatrixView.stopSpinner();
    }
  }

  async loadTracks(configs) {

    // If loading a single track remember its name, for error message
    const errorPrefix = 1 === configs.length ? ("Error loading track " + configs[0].name) : "Error loading tracks";

    try {
      this.contactMatrixView.startSpinner();

      const tracks = [];
      const promises2D = [];

      for (let config of /*trackConfigurations*/configs) {

        const fileName = isFile(config.url) ? config.url.name : await getFilenameExtended(config.url);

        if (!config.format) {
          config.format = inferFileFormat(fileName);
        }

        config.color = '#0d47a1';

        if (config.max === undefined) {
          config.autoscale = true;
        }

        // config.height = ("annotation" === config.type) ? annotationTrackHeight : wigTrackHeight;
        config.height = trackHeight;

        if (undefined === config.format || "bedpe" === config.format || "interact" === config.format) {
          // Assume this is a 2D track
          promises2D.push(Track2D.loadTrack2D(config, this.genome));
        } else {
          //const track = await igv.createTrack(config, this);
          //tracks.push(track);
        }
      }

      if (tracks.length > 0) {

        this.layoutController.tracksLoaded(tracks);

        const $gear_container = $('.hic-igv-right-hand-gutter');
        if (true === this.showTrackLabelAndGutter) {
          $gear_container.show();
        } else {
          $gear_container.hide();
        }

        await this.updateLayout();
      }

      if (promises2D.length > 0) {

        const tracks2D = await Promise.all(promises2D);
        if (tracks2D && tracks2D.length > 0) {
          this.tracks2D = this.tracks2D.concat(tracks2D);
          this.eventBus.post(HICEvent("TrackLoad2D", this.tracks2D));
        }

      }

    } catch (error) {
      presentError(errorPrefix, error);
      console.error(error);

    } finally {
      this.contactMatrixView.stopSpinner();
    }
  }

  async loadNormalizationFile(url) {

    if (!this.dataset) return;
    this.eventBus.post(HICEvent("NormalizationFileLoad", "start"));

    const normVectors = await this.dataset.hicFile.readNormalizationVectorFile(url, this.dataset.chromosomes);
    for (let type of normVectors['types']) {
      if (!this.dataset.normalizationTypes) {
        this.dataset.normalizationTypes = [];
      }
      if (!this.dataset.normalizationTypes.includes(type)) {
        this.dataset.normalizationTypes.push(type);
      }
      this.eventBus.post(HICEvent("NormVectorIndexLoad", this.dataset));
    }

    return normVectors;
  }

  /**
   * Render the XY pair of tracks.
   *
   * @param xy
   */
  async renderTrackXY(xy) {

    try {
      this.startSpinner();
      await xy.updateViews();
    } finally {
      this.stopSpinner();
    }
  }

  reset() {
    this.layoutController.removeAllTrackXYPairs();
    this.contactMatrixView.clearImageCaches();
    this.tracks2D = [];
    this.tracks = [];
    this.$contactMaplabel.text("");
    this.$contactMaplabel.attr('title', "");
    this.$controlMaplabel.text("");
    this.$controlMaplabel.attr('title', "");
    this.dataset = undefined;
    this.controlDataset = undefined;
    this.unsyncSelf();
  }

  clearSession() {
    // Clear current datasets.
    this.dataset = undefined;
    this.synchedBrowsers = [];
    this.isSync = false;
    this.isForce = false;
    this.controlDataset = undefined;
    this.setDisplayMode('A');
    $(`#sync-${this.id}`).addClass('fa-ban');
    $(`#sync-${this.id}`).removeClass('fa-circle-o');
    this.unsyncSelf();
  }

  /**
   * Remove reference to self from all synchedBrowsers lists.
   */
  unsyncSelf() {
    const allBrowsers = getAllBrowsers();
    for (let b of allBrowsers) {
      b.unsync(this);
    }
  }

  /**
   * Remove the reference browser from this collection of synched browsers
   * @param browser
   */
  unsync(browser) {
    this.synchedBrowsers = this.synchedBrowsers.filter(b => b != browser);
  }

  /**
   * Load a .hic file
   *
   * NOTE: public API function
   *
   * @return a promise for a dataset
   * @param config
   * @param noUpdates
   */
  async loadHicFile(config, noUpdates) {

    if (!config.url) {
      //console.log("No .hic url specified");
      return undefined;
    }

    this.clearSession();

    try {

      this.contactMatrixView.startSpinner();
      if (!noUpdates) {
        this.$user_interaction_shield.show();
      }

      const name = extractName(config);
      const prefix = this.controlDataset ? "A: " : "";
      this.$contactMaplabel.text(prefix + name);
      this.$contactMaplabel.attr('title', name);
      config.name = name;

      this.dataset = await Dataset.loadDataset(config);
      this.dataset.name = name;

      const previousGenomeId = this.genome ? this.genome.id : undefined;
      this.genome = new Genome(this.dataset.genomeId, this.dataset.chromosomes);

      // TODO -- this is not going to work with browsers on different assemblies on the same page.
      //igv.browser.genome = this.genome;

      if (this.genome.id !== previousGenomeId) {
        EventBus.globalBus.post(HICEvent("GenomeChange", this.genome.id));
      }
      this.eventBus.post(HICEvent("MapLoad", this.dataset));

      if (config.state) {
        if (!config.state.hasOwnProperty("chr1")) {
          config.state = State.parse(config.state);
        }
        await this.setState(config.state);
      } else if (config.synchState && this.canBeSynched(config.synchState)) {
        this.syncState(config.synchState);
      } else {
        await this.setState(State.default(this.config));
      }


      // Initiate loading of the norm vector index, but don't block if the "nvi" parameter is not available.
      // Let it load in the background
      const eventBus = this.eventBus;

      // If nvi is not supplied, try reading it from remote lambda service
      if (!config.nvi && typeof config.url === "string") {
        const url = new URL(config.url);
        const key = encodeURIComponent(url.hostname + url.pathname);
        const nviResponse = await fetch('https://t5dvc6kn3f.execute-api.us-east-1.amazonaws.com/dev/nvi/' + key);
        if (nviResponse.status === 200) {
          const nvi = await nviResponse.text();
          if (nvi) {
            config.nvi = nvi;
          }
        }
      }

      if (config.nvi) {
        await this.dataset.getNormVectorIndex(config);
        eventBus.post(HICEvent("NormVectorIndexLoad", this.dataset));
      } else {
        const dataset = this.dataset;
        dataset.getNormVectorIndex(config)
          .then(function (normVectorIndex) {
            if (!config.isControl) {
              eventBus.post(HICEvent("NormVectorIndexLoad", dataset));
            }
          });
      }

      //syncBrowsers();
      /*
      // Find a browser to sync with, if any
      const compatibleBrowsers = getAllBrowsers().filter(b => b != this &&
          b.dataset && b.dataset.isCompatible(this.dataset));
      if (compatibleBrowsers.length > 0) {
          this.syncState(compatibleBrowsers[0].getSyncState());
      }
      */

    } catch (error) {
      this.$contactMaplabel.text('');
      this.$contactMaplabel.attr('');
      config.name = name;
      throw error;
    } finally {
      this.stopSpinner();
      if (!noUpdates) {
        this.$user_interaction_shield.hide();
      }
    }
  }

  /**
   * Load a .hic file for a control map
   *
   * NOTE: public API function
   *
   * @return a promise for a dataset
   * @param config
   */
  async loadHicControlFile(config, noUpdates) {

    try {
      this.$user_interaction_shield.show();
      this.contactMatrixView.startSpinner();
      this.controlUrl = config.url;
      const name = extractName(config);
      config.name = name;

      const controlDataset = await Dataset.loadDataset(config);
      controlDataset.name = name;

      if (!this.dataset || this.dataset.isCompatible(controlDataset)) {
        this.controlDataset = controlDataset;
        if (this.dataset) {
          // this.$contactMaplabel.text("A: " + this.dataset.name);
          this.$contactMaplabel.text("A: " + this.dataset.name + " + B: " + controlDataset.name);
          this.$contactMaplabel.attr('title', "A: " + this.dataset.name + " + B: " + controlDataset.name);
        }
        // this.$controlMaplabel.text("B: " + controlDataset.name);
        // this.$controlMaplabel.attr('title', controlDataset.name);

        //For the control dataset, block until the norm vector index is loaded
        await controlDataset.getNormVectorIndex(config);
        this.eventBus.post(HICEvent("ControlMapLoad", this.controlDataset));

        if (!noUpdates) {
          this.update();
        }
      } else {
        Alert$1.presentAlert('"B" map genome (' + controlDataset.genomeId + ') does not match "A" map genome (' + this.genome.id + ')');
      }
    } finally {
      this.$user_interaction_shield.hide();
      this.stopSpinner();
    }
  }



  async parseGotoInput(string, is_igv) {
    // console.log(is_igv)
    let xLocus;
    let yLocus;
    const loci = string.split(' ');
    if (loci.length === 1) {
      xLocus = this.parseLocusString(loci[0]);
      yLocus = xLocus;
    } else {
      xLocus = this.parseLocusString(loci[0]);
      yLocus = this.parseLocusString(loci[1]);
      if (yLocus === undefined) yLocus = xLocus;
    }

    if (xLocus === undefined) {
      // Try a gene name search.
      const result = await geneSearch(this.genome.id, loci[0].trim());

      if (result) {
        //console.log(result);
        Globals.selectedGene = loci[0].trim();
        xLocus = this.parseLocusString(result);
        yLocus = xLocus;
        this.state.selectedGene = Globals.selectedGene;
        this.goto(xLocus.chr, xLocus.start, xLocus.end, yLocus.chr, yLocus.start, yLocus.end, 5000);
      } else {
        alert('No feature found with name "' + loci[0] + '"');
      }

    } else {

      if (xLocus.wholeChr && yLocus.wholeChr) {
        // 点击axis
        await this.setChromosomes(xLocus.chr, yLocus.chr);
        //call3d(this.id, xLocus.chr, yLocus.chr,true);
      } else {
        this.goto(xLocus.chr, xLocus.start, xLocus.end, yLocus.chr, yLocus.start, yLocus.end, undefined, is_igv);
      }
    }

  };

  /**
   * Find the closest matching zoom index (index into the dataset resolutions array) for the target resolution.
   *
   * resolutionAraay can be either
   *   (1) an array of bin sizes
   *   (2) an array of objects with index and bin size
   * @param targetResolution
   * @param resolutionArray
   * @returns {number}
   */
  findMatchingZoomIndex(targetResolution, resolutionArray) {
    const isObject = resolutionArray.length > 0 && resolutionArray[0].index !== undefined;
    for (let z = resolutionArray.length - 1; z > 0; z--) {
      const binSize = isObject ? resolutionArray[z].binSize : resolutionArray[z];
      const index = isObject ? resolutionArray[z].index : z;
      if (binSize >= targetResolution) {
        return index;
      }
    }
    return 0;
  };

  parseLocusString(locus) {

    const locusObject = {};
    const parts = locus.trim().split(':');
    if (this.genome === undefined) return undefined;
    let chromosome = this.genome.getChromosome(parts[0].toLowerCase());
    if (chromosome === undefined) {
      chromosome = this.genome.getChromosome(parts[0].substr(3));
    }
    if (!chromosome) {
      return undefined;
    } else {
      locusObject.chr = chromosome.index;
    }

    if (parts.length === 1) {
      // Chromosome name only
      locusObject.start = 0;
      locusObject.end = this.dataset.chromosomes[locusObject.chr].size;
      locusObject.wholeChr = true;
    } else {
      const extent = parts[1].split("-");
      let numeric = extent[0].replace(/\,/g, '');
      locusObject.start = isNaN(numeric) ? undefined : parseInt(numeric, 10) - 1;
      if (extent.length == 2) {
        numeric = extent[1].replace(/\,/g, '');
        locusObject.end = isNaN(numeric) ? undefined : parseInt(numeric, 10);
      }
    }
    return locusObject;
  };


  /**
   * @param scaleFactor Values range from greater then 1 to decimal values less then one
   *                    Value > 1 are magnification (zoom in)
   *                    Decimal values (.9, .75, .25, etc.) are minification (zoom out)
   * @param anchorPx -- anchor position in pixels (should not move after transformation)
   * @param anchorPy
   */
  async pinchZoom(anchorPx, anchorPy, scaleFactor) {

    if (this.state.chr1 === 0) {
      await this.zoomAndCenter(1, anchorPx, anchorPy);
    } else {
      try {
        this.startSpinner();

        const bpResolutions = this.getResolutions();
        const currentResolution = bpResolutions[this.state.zoom];

        let newBinSize;
        let newZoom;
        let newPixelSize;
        let zoomChanged;

        if (this.resolutionLocked ||
          (this.state.zoom === bpResolutions.length - 1 && scaleFactor > 1) ||
          (this.state.zoom === 0 && scaleFactor < 1)) {
          // Can't change resolution level, must adjust pixel size
          newBinSize = currentResolution.binSize;
          newPixelSize = Math.min(MAX_PIXEL_SIZE, this.state.pixelSize * scaleFactor);
          newZoom = this.state.zoom;
          zoomChanged = false;
        } else {
          const targetBinSize = (currentResolution.binSize / this.state.pixelSize) / scaleFactor;
          newZoom = this.findMatchingZoomIndex(targetBinSize, bpResolutions);
          newBinSize = bpResolutions[newZoom].binSize;
          zoomChanged = newZoom !== this.state.zoom;
          newPixelSize = Math.min(MAX_PIXEL_SIZE, newBinSize / targetBinSize);
        }
        const z = await this.minZoom(this.state.chr1, this.state.chr2);


        if (!this.resolutionLocked && scaleFactor < 1 && newZoom < z) {
          // Zoom out to whole genome
          this.setChromosomes(0, 0);
        } else {

          const minPS = await this.minPixelSize(this.state.chr1, this.state.chr2, newZoom);

          const state = this.state;

          newPixelSize = Math.max(newPixelSize, minPS);

          // Genomic anchor  -- this position should remain at anchorPx, anchorPy after state change
          const gx = (state.x + anchorPx / state.pixelSize) * currentResolution.binSize;
          const gy = (state.y + anchorPy / state.pixelSize) * currentResolution.binSize;

          state.x = gx / newBinSize - anchorPx / newPixelSize;
          state.y = gy / newBinSize - anchorPy / newPixelSize;

          state.zoom = newZoom;
          state.pixelSize = newPixelSize;

          this.clamp();

          this.contactMatrixView.zoomIn(anchorPx, anchorPy, 1 / scaleFactor);

          let event = HICEvent("LocusChange", {
            state: state,
            resolutionChanged: zoomChanged,
            chrChanged: false
          });

          this.update(event);
          //this.eventBus.post(event);
        }
      } finally {
        this.stopSpinner();
      }
    }

  }

  // TODO -- apparently not used.  Where is this handled?
  // async wheelClickZoom(direction, centerPX, centerPY) {
  //     if (this.resolutionLocked || this.state.chr1 === 0) {   // Resolution locked OR whole genome view
  //         this.zoomAndCenter(direction, centerPX, centerPY);
  //     } else {
  //         const z = await minZoom.call(this, this.state.chr1, this.state.chr2)
  //         var newZoom = this.state.zoom + direction;
  //         if (direction < 0 && newZoom < z) {
  //             this.setChromosomes(0, 0);
  //         } else {
  //             this.zoomAndCenter(direction, centerPX, centerPY);
  //         }
  //
  //     }
  // }

  // Zoom in response to a double-click
  /**
   * Zoom and center on bins at given screen coordinates.  Supports double-click zoom, pinch zoom.
   * @param direction
   * @param centerPX  screen coordinate to center on
   * @param centerPY  screen coordinate to center on
   * @returns {Promise<void>}
   */
  async zoomAndCenter(direction, centerPX, centerPY) {

    if (!this.dataset) return;

    if (this.dataset.isWholeGenome(this.state.chr1) && direction > 0) {
      // 从全部跳转到一条染色体！
      const genomeCoordX = centerPX * this.dataset.wholeGenomeResolution / this.state.pixelSize;
      const genomeCoordY = centerPY * this.dataset.wholeGenomeResolution / this.state.pixelSize;
      const chrX = this.genome.getChromsosomeForCoordinate(genomeCoordX);
      const chrY = this.genome.getChromsosomeForCoordinate(genomeCoordY);
      this.setChromosomes(chrX.index, chrY.index);
      //call3d(this.id,chrX.index, chrY.index,true);
    } else {
      const resolutions = this.getResolutions();
      const viewDimensions = this.contactMatrixView.getViewDimensions();
      const dx = centerPX === undefined ? 0 : centerPX - viewDimensions.width / 2;
      const dy = centerPY === undefined ? 0 : centerPY - viewDimensions.height / 2;

      this.state.x += (dx / this.state.pixelSize);
      this.state.y += (dy / this.state.pixelSize);

      if (this.resolutionLocked ||
        (direction > 0 && this.state.zoom === resolutions[resolutions.length - 1].index) ||
        (direction < 0 && this.state.zoom === resolutions[0].index)) {

        const minPS = await this.minPixelSize(this.state.chr1, this.state.chr2, this.state.zoom);
        const state = this.state;
        const newPixelSize = Math.max(Math.min(MAX_PIXEL_SIZE, state.pixelSize * (direction > 0 ? 2 : 0.5)), minPS);

        const shiftRatio = (newPixelSize - state.pixelSize) / newPixelSize;
        state.pixelSize = newPixelSize;
        state.x += shiftRatio * (viewDimensions.width / state.pixelSize);
        state.y += shiftRatio * (viewDimensions.height / state.pixelSize);

        this.clamp();

        let event = HICEvent("LocusChange", {
          state: state,
          resolutionChanged: false,
          chrChanged: false
        });

        this.update(event);
        //this.eventBus.post(event);

      } else {
        let i;
        for (i = 0; i < resolutions.length; i++) {
          if (this.state.zoom === resolutions[i].index) break;
        }
        if (i !== undefined) {
          const newZoom = resolutions[i + direction].index;
          this.setZoom(newZoom);
        }
      }
    }
  }

  /**
   * Set the current zoom state and opctionally center over supplied coordinates.
   * @param zoom - index to the datasets resolution array (dataset.bpResolutions)
   * @returns {Promise<void>}
   */
  async setZoom(zoom) {

    try {

      // Shift x,y to maintain center, if possible
      const bpResolutions = this.dataset.bpResolutions;
      const currentResolution = bpResolutions[this.state.zoom];
      const viewDimensions = this.contactMatrixView.getViewDimensions();
      const xCenter = this.state.x + viewDimensions.width / (2 * this.state.pixelSize);    // center in bins
      const yCenter = this.state.y + viewDimensions.height / (2 * this.state.pixelSize);    // center in bins

      const newResolution = bpResolutions[zoom];
      const newXCenter = xCenter * (currentResolution / newResolution);
      const newYCenter = yCenter * (currentResolution / newResolution);
      const minPS = await this.minPixelSize(this.state.chr1, this.state.chr2, zoom);
      const state = this.state;
      const newPixelSize = Math.max(DEFAULT_PIXEL_SIZE, minPS);
      const zoomChanged = (state.zoom !== zoom);

      state.zoom = zoom;
      state.x = Math.max(0, newXCenter - viewDimensions.width / (2 * newPixelSize));
      state.y = Math.max(0, newYCenter - viewDimensions.height / (2 * newPixelSize));
      state.pixelSize = newPixelSize;
      this.clamp();

      await this.contactMatrixView.zoomIn();

      let event = HICEvent("LocusChange", {
        state: state,
        resolutionChanged: zoomChanged,
        chrChanged: false
      });

      this.update(event);
      //this.eventBus.post(event);

    } finally {
      // this.stopSpinner()
    }

  };

  async setChromosomes(chr1, chr2) {

    try {
      this.startSpinner();

      const z = await this.minZoom(chr1, chr2);
      this.state.chr1 = Math.min(chr1, chr2);
      this.state.chr2 = Math.max(chr1, chr2);
      this.state.x = 0;
      this.state.y = 0;
      this.state.zoom = z;

      const minPS = await this.minPixelSize(this.state.chr1, this.state.chr2, this.state.zoom);
      this.state.pixelSize = Math.min(100, Math.max(DEFAULT_PIXEL_SIZE, minPS));

      let event = HICEvent("LocusChange", { state: this.state, resolutionChanged: true, chrChanged: true });

      this.update(event);
      //this.eventBus.post(event);

    } finally {
      this.stopSpinner();
    }
  }

  /**
   * Called on loading tracks
   * @returns {Promise<void>}
   */
  async updateLayout() {

    this.clamp();

    this.trackPairs.forEach(function (xyTrackRenderPair, index) {
      sync(xyTrackRenderPair.x, index);
      sync(xyTrackRenderPair.y, index);
    });

    function sync(trackRenderer, index) {
      trackRenderer.$viewport.css({ order: index });
      trackRenderer.syncCanvas();
    }

    this.layoutController.xAxisRuler.update();
    this.layoutController.yAxisRuler.update();

    await this.update();

  }


  /**
   * Set the matrix state.  Used to restore state from a bookmark
   * @param state  browser state
   */
  async setState(state) {

    const chrChanged = !this.state || this.state.chr1 !== state.chr1 || this.state.chr2 !== state.chr2;
    this.state = state;
    // Possibly adjust pixel size
    const minPS = await this.minPixelSize(this.state.chr1, this.state.chr2, this.state.zoom);
    this.state.pixelSize = Math.max(state.pixelSize, minPS);

    let hicEvent = new HICEvent("LocusChange", {
      state: this.state,
      resolutionChanged: true,
      chrChanged: chrChanged
    });

    this.update(hicEvent);
    this.eventBus.post(hicEvent);
  }


  /**
   * Return a modified state object used for synching.  Other datasets might have different chromosome ordering
   * and resolution arrays
   */
  getSyncState() {
    return {
      chr1Name: this.dataset.chromosomes[this.state.chr1].name,
      chr2Name: this.dataset.chromosomes[this.state.chr2].name,
      binSize: this.dataset.bpResolutions[this.state.zoom],
      binX: this.state.x,            // TODO -- tranlsate to lower right corner
      binY: this.state.y,
      pixelSize: this.state.pixelSize
    };
  }

  /**
   * Return true if this browser can be synched to the given state
   * @param syncState
   */
  canBeSynched(syncState) {

    if (false === this.synchable) return false;   // Explicitly not synchable

    return this.dataset &&
      (this.dataset.getChrIndexFromName(syncState.chr1Name) !== undefined) &&
      (this.dataset.getChrIndexFromName(syncState.chr2Name) !== undefined);

  }

  /**
   * Used to synch state with other browsers
   * @param state  browser state
   */
  syncState(syncState) {

    if (!syncState || false === this.synchable) return;

    if (!this.dataset) return;

    var chr1 = this.genome.getChromosome(syncState.chr1Name),
      chr2 = this.genome.getChromosome(syncState.chr2Name),
      zoom = this.dataset.getZoomIndexForBinSize(syncState.binSize, "BP"),
      x = syncState.binX,
      y = syncState.binY,
      pixelSize = syncState.pixelSize;

    if (!(chr1 && chr2)) {
      return;   // Can't be synched.
    }

    if (zoom === undefined) {
      // Get the closest zoom available and adjust pixel size.   TODO -- cache this somehow
      zoom = this.findMatchingZoomIndex(syncState.binSize, this.dataset.bpResolutions);

      // Compute equivalent in basepairs / pixel
      pixelSize = (syncState.pixelSize / syncState.binSize) * this.dataset.bpResolutions[zoom];

      // Translate bins so that origin is unchanged in basepairs
      x = (syncState.binX / syncState.pixelSize) * pixelSize;
      y = (syncState.binY / syncState.pixelSize) * pixelSize;

      if (pixelSize > MAX_PIXEL_SIZE) {
        console.log("Cannot synch map " + this.dataset.name + " (resolution " + syncState.binSize + " not available)");
        return;
      }
    }


    const zoomChanged = (this.state.zoom !== zoom);
    const chrChanged = (this.state.chr1 !== chr1.index || this.state.chr2 !== chr2.index);
    this.state.chr1 = chr1.index;
    this.state.chr2 = chr2.index;
    this.state.zoom = zoom;
    this.state.x = x;
    this.state.y = y;
    this.state.pixelSize = pixelSize;

    let event = HICEvent("LocusChange", {
      state: this.state,
      resolutionChanged: zoomChanged,
      chrChanged: chrChanged
    }, false);

    this.update(event);
    //this.eventBus.post(event);

  }

  setNormalization(normalization) {

    this.state.normalization = normalization;
    this.eventBus.post(HICEvent("NormalizationChange", this.state.normalization));
  }

  shiftPixels(dx, dy) {

    if (!this.dataset) return;
    this.state.x += (dx / this.state.pixelSize);
    this.state.y += (dy / this.state.pixelSize);
    this.clamp();

    const locusChangeEvent = HICEvent("LocusChange", {
      state: this.state,
      resolutionChanged: false,
      dragging: true,
      chrChanged: false
    });
    locusChangeEvent.dragging = true;

    this.update(locusChangeEvent);
    this.eventBus.post(locusChangeEvent);
  }

  goto(chr1, bpX, bpXMax, chr2, bpY, bpYMax, minResolution, is_igv) {
    // console.log(is_igv);
    if (is_igv === undefined) is_igv = false;
    // goto按钮触发
    const viewDimensions = this.contactMatrixView.getViewDimensions();
    const bpResolutions = this.getResolutions();
    const currentResolution = bpResolutions[this.state.zoom].binSize;
    const viewWidth = viewDimensions.width;

    if (!bpXMax) {
      bpX = Math.max(0, bpX - Math.floor(viewWidth * currentResolution / 2));
      bpXMax = bpX + viewWidth * currentResolution;
    }
    if (!bpYMax) {
      bpY = Math.max(0, bpY - Math.floor(viewDimensions.height * currentResolution / 2));
      bpYMax = bpY + viewDimensions.height * currentResolution;
    }

    let targetResolution = Math.max((bpXMax - bpX) / viewDimensions.width, (bpYMax - bpY) / viewDimensions.height);

    if (minResolution && targetResolution < minResolution) {
      const maxExtent = viewWidth * minResolution;
      const xCenter = (bpX + bpXMax) / 2;
      const yCenter = (bpY + bpYMax) / 2;
      bpX = Math.max(xCenter - maxExtent / 2);
      bpY = Math.max(0, yCenter - maxExtent / 2);
      targetResolution = minResolution;
    }

    let zoomChanged;
    let newZoom;
    if (is_igv || (true === this.resolutionLocked && minResolution === undefined)) {
      zoomChanged = false;
      newZoom = this.state.zoom;
    } else {
      newZoom = this.findMatchingZoomIndex(targetResolution, bpResolutions);
      zoomChanged = (newZoom !== this.state.zoom);
    }

    const newResolution = bpResolutions[newZoom].binSize;
    const newPixelSize = Math.min(MAX_PIXEL_SIZE, Math.max(1, newResolution / targetResolution));
    const newXBin = bpX / newResolution;
    const newYBin = bpY / newResolution;

    const chrChanged = !this.state || this.state.chr1 !== chr1 || this.state.chr2 !== chr2;
    this.state.chr1 = chr1;
    this.state.chr2 = chr2;
    this.state.zoom = newZoom;
    this.state.x = newXBin;
    this.state.y = newYBin;
    this.state.pixelSize = newPixelSize;

    if (!is_igv) this.contactMatrixView.clearImageCaches();


    let event = HICEvent("LocusChange", {
      state: this.state,
      resolutionChanged: zoomChanged,
      chrChanged: chrChanged
    });

    this.update(event);
    //this.eventBus.post(event);

  }

  clamp() {
    var viewDimensions = this.contactMatrixView.getViewDimensions(),
      chr1Length = this.dataset.chromosomes[this.state.chr1].size,
      chr2Length = this.dataset.chromosomes[this.state.chr2].size,
      binSize = this.dataset.bpResolutions[this.state.zoom],
      maxX = (chr1Length / binSize) - (viewDimensions.width / this.state.pixelSize),
      maxY = (chr2Length / binSize) - (viewDimensions.height / this.state.pixelSize);

    // Negative maxX, maxY indicates pixelSize is not enough to fill view.  In this case we clamp x, y to 0,0
    maxX = Math.max(0, maxX);
    maxY = Math.max(0, maxY);


    this.state.x = Math.min(Math.max(0, this.state.x), maxX);
    this.state.y = Math.min(Math.max(0, this.state.y), maxY);
  }

  receiveEvent(event) {
  }

  /**
   * Update the maps and tracks.  This method can be called from the browser event thread repeatedly, for example
   * while mouse dragging.  If called while an update is in progress queue the event for processing later.  It
   * is only neccessary to queue the most recent recently received event, so a simple instance variable will suffice
   * for the queue.
   *
   * @param event
   */
  async update(event) {

    if (this.updating) {
      const type = event ? event.type : "NONE";
      this.pending.set(type, event);
    } else {
      this.updating = true;
      try {

        this.startSpinner();
        if (event !== undefined && "LocusChange" === event.type) {
          this.layoutController.xAxisRuler.locusChange(event);
          this.layoutController.yAxisRuler.locusChange(event);
        }

        const promises = [];

        for (let xyTrackRenderPair of this.trackPairs) {
          promises.push(this.renderTrackXY(xyTrackRenderPair));
        }
        promises.push(this.contactMatrixView.update(event));
        await Promise.all(promises);

        if (event && event.propogate) {
          let syncState1 = this.getSyncState();
          for (let browser of this.synchedBrowsers) {
            browser.syncState(syncState1);
          }
        }

      } finally {
        this.updating = false;
        if (this.pending.size > 0) {
          const events = [];
          for (let [k, v] of this.pending) {
            events.push(v);
          }
          this.pending.clear();
          for (let e of events) {
            this.update(e);
          }
        }
        if (event) {
          // possibly, unless update was called from an event post (infinite loop)
          this.eventBus.post(event);
        }
        this.stopSpinner();
      }
    }
  }

  repaintMatrix() {
    this.contactMatrixView.imageTileCache = {};
    this.contactMatrixView.initialImage = undefined;
    this.contactMatrixView.update();
  }

  resolution() {
    return this.dataset.bpResolutions[this.state.zoom];
  };


  toJSON() {

    if (!(this.dataset && this.dataset.url)) return "{}";   // URL is required

    const jsonOBJ = {};

    jsonOBJ.backgroundColor = this.contactMatrixView.stringifyBackgroundColor();
    jsonOBJ.url = this.dataset.url;
    if (this.dataset.name) {
      jsonOBJ.name = this.dataset.name;
    }
    jsonOBJ.state = this.state.stringify();
    jsonOBJ.colorScale = this.contactMatrixView.getColorScale().stringify();
    if (Globals.selectedGene) {
      jsonOBJ.selectedGene = Globals.selectedGene;
    }
    let nviString = getNviString(this.dataset);
    if (nviString) {
      jsonOBJ.nvi = nviString;
    }
    if (this.controlDataset) {
      jsonOBJ.controlUrl = this.controlUrl;
      if (this.controlDataset.name) {
        jsonOBJ.controlName = this.controlDataset.name;
      }
      const displayMode = this.getDisplayMode();
      if (displayMode) {
        jsonOBJ.displayMode = this.getDisplayMode();
      }
      nviString = getNviString(this.controlDataset);
      if (nviString) {
        jsonOBJ.controlNvi = nviString;
      }
      if (this.controlMapWidget.getDisplayModeCycle() !== undefined) {
        jsonOBJ.cycle = true;
      }
    }

    if (this.trackPairs.length > 0 || this.tracks2D.length > 0) {
      let tracks = [];
      jsonOBJ.tracks = tracks;
      for (let trackRenderer of this.trackPairs) {
        const track = trackRenderer.x.track;
        const config = track.config;
        if (typeof config.url === "string") {
          const t = {
            url: config.url
          };
          if (track.name) {
            t.name = track.name;
          }
          if (track.dataRange) {
            t.min = track.dataRange.min;
            t.max = track.dataRange.max;
          }
          if (track.color) {
            t.color = track.color;
          }
          tracks.push(t);
        }

      }
      for (let track of this.tracks2D) {
        var config = track.config;
        if (typeof config.url === "string") {
          const t = {
            url: config.url
          };
          if (track.name) {
            t.name = track.name;
          }
          if (track.color) {
            t.color = track.color;
          }
          tracks.push(t);
        }
      }
    }

    return jsonOBJ;
  }


  async minZoom(chr1, chr2) {

    const viewDimensions = this.contactMatrixView.getViewDimensions();
    const chromosome1 = this.dataset.chromosomes[chr1];
    const chromosome2 = this.dataset.chromosomes[chr2];
    const chr1Length = chromosome1.size;
    const chr2Length = chromosome2.size;
    const binSize = Math.max(chr1Length / viewDimensions.width, chr2Length / viewDimensions.height);

    const matrix = await this.dataset.getMatrix(chr1, chr2);
    if (!matrix) {
      throw new Error(`Data not avaiable for chromosomes ${chromosome1.name} - ${chromosome2.name}`);
    }
    return matrix.findZoomForResolution(binSize);
  }

  async minPixelSize(chr1, chr2, z) {

    const viewDimensions = this.contactMatrixView.getViewDimensions();
    const chr1Length = this.dataset.chromosomes[chr1].size;
    const chr2Length = this.dataset.chromosomes[chr2].size;

    const matrix = await this.dataset.getMatrix(chr1, chr2);
    const zd = matrix.getZoomDataByIndex(z, "BP");
    const binSize = zd.zoom.binSize;
    const nBins1 = chr1Length / binSize;
    const nBins2 = chr2Length / binSize;
    return (Math.min(viewDimensions.width / nBins1, viewDimensions.height / nBins2));

  }
}


function extractName(config) {
  if (config.name === undefined) {
    const urlOrFile = config.url;
    if (isFile(urlOrFile)) {
      return urlOrFile.name;
    } else {
      const str = urlOrFile.split('?').shift();
      const idx = urlOrFile.lastIndexOf("/");
      return idx > 0 ? str.substring(idx + 1) : str;
    }
  } else {
    return config.name;
  }
}

function getNviString(dataset) {

  return dataset.hicFile.config.nvi
  // if (dataset.hicFile.normalizationVectorIndexRange) {
  //     var range = dataset.hicFile.normalizationVectorIndexRange,
  //         nviString = String(range.start) + "," + String(range.size);
  //     return nviString
  // } else {
  //     return undefined;
  // }
}

function presentError(prefix, error) {
  const httpMessages = {
    "401": "Access unauthorized",
    "403": "Access forbidden",
    "404": "Not found"
  };
  var msg = error.message;
  if (httpMessages.hasOwnProperty(msg)) {
    msg = httpMessages[msg];
  }
  Alert$1.presentAlert(prefix + ": " + msg);

}

/*
* @author Jim Robinson Dec-2020
*/
// 默认长宽
let cur_container_width = (document.documentElement.clientWidth * 0.89) / 3
if (cur_container_width < 450) cur_container_width = (document.documentElement.clientWidth * 0.8) / 2
const defaultSize = { width: cur_container_width, height: cur_container_width };
//const defaultSize = {width: default_w > cur_container_width ? cur_container_width : default_w, height: default_w > cur_container_width ? cur_container_width : default_w};
let allBrowsers = [];
let currentBrowser;
// 克隆浏览器
async function createBrowser(hic_container, config, callback) {

  const $hic_container = $(hic_container);

  setDefaults(config);

  if (isString$2(config.state)) {
    config.state = State.parse(config.state);
  }
  if (isString$2(config.colorScale)) {
    config.colorScale = ColorScale.parse(config.colorScale);
  }
  if (isString$2(config.backgroundColor)) {
    config.backgroundColor = ContactMatrixView.parseBackgroundColor(config.backgroundColor);
  }

  const browser = new HICBrowser($hic_container, config);
  await browser.init(config);
  if (typeof callback === "function") {
    callback();
  }

  allBrowsers.push(browser);
  setCurrentBrowser(browser);
  // 克隆，，所有的浏览器都移除class，当前的添加class
  if (allBrowsers.length > 1) {
    allBrowsers.forEach(function (b) {
      b.$root.removeClass('hic-root-selected');
      b.$browser_panel_delete_button.show();
    });
  }
  browser.$root.addClass('hic-root-selected');

  return browser;
}

/**
* Create multiple browsers, maintaining order specified in configList.  Called from restore session
*
* @param hic_container
* @param configList
*/
async function createBrowserList(hic_container, session) {

  const $hic_container = $(hic_container);
  const configList = session.browsers || [session];


  allBrowsers = [];
  const initPromises = [];
  for (let config of configList) {
    setDefaults(config);
    if (isString$2(config.state)) {
      config.state = State.parse(config.state);
    }
    if (isString$2(config.colorScale)) {
      config.colorScale = ColorScale.parse(config.colorScale);
    }
    if (isString$2(config.backgroundColor)) {
      config.backgroundColor = ContactMatrixView.parseBackgroundColor(config.backgroundColor);
    }
    if (false === session.syncDatasets) {
      config.synchable = false;
    }

    const browser = new HICBrowser($hic_container, config);

    allBrowsers.push(browser);
    initPromises.push(browser.init(config));
  }
  await Promise.all(initPromises);

  setCurrentBrowser(allBrowsers[0]);

  if (allBrowsers.length > 1) {
    allBrowsers.forEach(function (b) {
      b.$browser_panel_delete_button.show();
    });
  }
}

function deleteAllBrowsers() {
  for (let b of allBrowsers) {
    b.$root.remove();
  }
  allBrowsers = [];
}

// 设置当前选中的浏览器
function setCurrentBrowser(browser) {// unselect current browser
  if (browser.dataset === undefined) {
    $('#dropdown-b-map').addClass('disabled')
    $('#hic-track').addClass('disabled')
    $('#dropdown-genome').addClass('disabled')
  } else {
    $('#dropdown-genome').removeClass('disabled')
    $('#dropdown-b-map').removeClass('disabled')
    $('#hic-track').removeClass('disabled')
  }
  if (undefined === browser) {
    if (currentBrowser) {
      currentBrowser.$root.removeClass('hic-root-selected');
    }
    currentBrowser = browser;
    return;
  }
  if (browser !== currentBrowser) {
    if (currentBrowser) {
      currentBrowser.$root.removeClass('hic-root-selected');
    }
    browser.$root.addClass('hic-root-selected');
    currentBrowser = browser;
    EventBus.globalBus.post(HICEvent("BrowserSelect", browser));
  }
}


function deleteBrowser(browser) {
  let is_selected = browser.$root.hasClass('hic-root-selected');
  $('#delete_panel').val(browser.id);
  $('#delete_panel_button').click();

  // 删除浏览器，
  browser.unsyncSelf();
  browser.$root.parent().remove(); // 删除父亲元素，
  allBrowsers = allBrowsers.filter(b => b != browser);
  if (allBrowsers.length > 0 && is_selected) {
    let _length = allBrowsers.length - 1;
    allBrowsers[_length].$root.addClass('hic-root-selected');
    setCurrentBrowser(allBrowsers[_length]);
  }
  if (allBrowsers.length <= 1) {
    allBrowsers.forEach(function (b) {
      b.$browser_panel_delete_button.hide();
    });
  }
}

function getCurrentBrowser() {
  return currentBrowser;
}

function syncBrowsers(a, b) {
  if (a === b) return true;
  if (a.synchable === false || a.dataset === undefined) return true;
  if (b.synchable === false || b.dataset === undefined) return true;
  if (a.isForce || b.isForce || a.dataset.isCompatible(b.dataset)) {
    a.synchedBrowsers.push(b);
    b.synchedBrowsers.push(a);
    return true;
  }
  return false;
  /*

  //同步浏览器
  const synchableBrowsers = (browsers || allBrowsers).filter(b => (false !== b.synchable) && (b.dataset !== undefined));

  // Sync compatible maps only
  for (let b1 of synchableBrowsers) {
      for (let b2 of synchableBrowsers) {
          if (b1 === b2) continue;
          if (b1.dataset.isCompatible(b2.dataset)) {
              b1.synchedBrowsers.push(b2);
              b2.synchedBrowsers.push(b1);
          }
      }
  }*/
}

// 解除两个浏览器的同步
function unsyncBrowsers(a, b) {
  if (a === b) return;
  if (a.synchable === false || a.dataset === undefined) return true;
  if (b.synchable === false || b.dataset === undefined) return true;

  a.synchedBrowsers = a.synchedBrowsers.filter(item => item != b); // a的同步浏览器中删除b
  b.synchedBrowsers = b.synchedBrowsers.filter(item => item != a);
  return true;
}



function getAllBrowsers() {
  return allBrowsers;
}


// Set default values for config properties
function setDefaults(config) {

  if (config.state) {

    if (isString$2(config.state)) {
      config.state = State.parse(config.state);
    } else {
      // copy
      config.state = new State(
        config.state.chr1,
        config.state.chr2,
        config.state.zoom,
        config.state.x,
        config.state.y,
        config.width,
        config.height,
        config.state.pixelSize,
        config.state.normalization);
    }
  }

  if (config.figureMode === true) {
    config.showLocusGoto = false;
    config.showHicContactMapLabel = false;
    config.showChromosomeSelector = false;
  } else {
    if (undefined === config.width) {
      config.width = config.state ? config.state.width : defaultSize.width;
    }
    if (undefined === config.height) {
      config.height = config.state ? config.state.height : defaultSize.height;
    }
    if (undefined === config.showLocusGoto) {
      config.showLocusGoto = true;
    }
    if (undefined === config.showHicContactMapLabel) {
      config.showHicContactMapLabel = true;
    }
    if (undefined === config.showChromosomeSelector) {
      config.showChromosomeSelector = true;
    }
  }

}

const version = "2.2.1";
//, commit}

function toJSON() {
  const jsonOBJ = {};
  const browserJson = [];
  const allBrowsers = getAllBrowsers();
  for (let browser of allBrowsers) {
    browserJson.push(browser.toJSON());
  }
  jsonOBJ.browsers = browserJson;

  if (Globals.selectedGene) {
    jsonOBJ["selectedGene"] = Globals.selectedGene;
  }

  const captionDiv = document.getElementById('hic-caption');
  if (captionDiv) {
    var captionText = captionDiv.textContent;
    if (captionText) {
      captionText = captionText.trim();
      if (captionText) {
        jsonOBJ.caption = captionText;
      }
    }
  }

  return jsonOBJ;
}

function compressedSession() {
  const jsonString = JSON.stringify(toJSON());
  return `session=blob:${compressString(jsonString)}`
}


async function restoreSession(container, session) {

  deleteAllBrowsers();

  if (session.hasOwnProperty("selectedGene")) {
    Globals.selectedGene = session.selectedGene;
  }
  if (session.hasOwnProperty("caption")) {
    const captionText = session.caption;
    var captionDiv = document.getElementById("hic-caption");
    if (captionDiv) {
      captionDiv.textContent = captionText;
    }
  }

  await createBrowserList(container, session);

  if (false !== session.syncDatasets) {
    syncBrowsers();
  }

}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

const DEFAULT_ANNOTATION_COLOR = "rgb(22, 129, 198)";

const urlShortcuts = {
  "*s3e/": "https://hicfiles.s3.amazonaws.com/external/",
  "*s3/": "https://hicfiles.s3.amazonaws.com/",
  "*s3e_/": "http://hicfiles.s3.amazonaws.com/external/",
  "*s3_/": "http://hicfiles.s3.amazonaws.com/",
  "*enc/": "https://www.encodeproject.org/files/"
};

async function extractConfig(queryString) {

  let query = extractQuery(queryString);
  let sessionConfig;

  if (query.hasOwnProperty("session")) {
    if (query.session.startsWith("blob:") || query.session.startsWith("data:")) {
      sessionConfig = JSON.parse(uncompressString(query.session.substr(5)));
    }
  }

  if (query.hasOwnProperty("juiceboxURL")) {
    const jbURL = await expandURL(query["juiceboxURL"]);   // Legacy bitly urls
    query = extractQuery(jbURL);
  }

  if (query.hasOwnProperty("juicebox") || query.hasOwnProperty("juiceboxData")) {
    let q;
    if (query.hasOwnProperty("juiceboxData")) {
      q = uncompressString(query["juiceboxData"]);
    } else {
      q = query["juicebox"];
      if (q.startsWith("%7B")) {
        q = decodeURIComponent(q);
      }
    }

    q = q.substr(1, q.length - 2);  // Strip leading and trailing bracket
    const parts = q.split("},{");
    const browsers = [];
    for (let p of parts) {
      const qObj = extractQuery(decodeURIComponent(p));
      browsers.push(decodeQuery(qObj));
    }
    sessionConfig = { browsers };
  }

  // Try query parameter style
  const uriDecode = true;
  const queryConfig = decodeQuery(query, uriDecode);
  if (queryConfig.url) {
    sessionConfig = queryConfig;
  }

  // Fix certain defaults
  if (sessionConfig) {
    if (sessionConfig.browsers) {
      for (let b of sessionConfig.browsers) {
        fixDefaults(b);
      }
    } else {
      fixDefaults(sessionConfig);
    }
  }

  return sessionConfig;

}

function fixDefaults(browserConfig) {
  if (browserConfig.tracks) {
    for (let t of browserConfig.tracks) {
      if (t.color === DEFAULT_ANNOTATION_COLOR) {
        delete t.color;
      }
      if (t.min !== undefined && Number.isNaN(t.min)) {
        delete t.min;
      }
      if (t.max !== undefined && Number.isNaN(t.max)) {
        delete t.max;
      }
      t.displayMode = "COLLAPSED";
    }
  }
}


/**
* Extend config properties with query parameters
*
* @param query
* @param config
*/
function decodeQuery(query, uriDecode) {

  const config = {};

  let hicUrl = query["hicUrl"];
  const name = query["name"];
  let stateString = query["state"];
  let colorScale = query["colorScale"];
  let trackString = query["tracks"];
  const selectedGene = query["selectedGene"];
  const nvi = query["nvi"];

  let controlUrl = query["controlUrl"];
  const controlName = query["controlName"];
  const displayMode = query["displayMode"];
  const controlNvi = query["controlNvi"];
  const cycle = query["cycle"];

  if (hicUrl) {
    hicUrl = paramDecode(hicUrl, uriDecode);
    Object.keys(urlShortcuts).forEach(function (key) {
      var value = urlShortcuts[key];
      if (hicUrl.startsWith(key)) hicUrl = hicUrl.replace(key, value);
    });
    config.url = hicUrl;

  }
  if (name) {
    config.name = paramDecode(name, uriDecode);
  }
  if (controlUrl) {
    controlUrl = paramDecode(controlUrl, uriDecode);
    Object.keys(urlShortcuts).forEach(function (key) {
      var value = urlShortcuts[key];
      if (controlUrl.startsWith(key)) controlUrl = controlUrl.replace(key, value);
    });
    config.controlUrl = controlUrl;
  }
  if (controlName) {
    config.controlName = paramDecode(controlName, uriDecode);
  }

  if (stateString) {
    stateString = paramDecode(stateString, uriDecode);
    config.state = State.parse(stateString);
  }
  if (colorScale) {
    colorScale = paramDecode(colorScale, uriDecode);
    config.colorScale = ColorScale.parse(colorScale);
  }

  if (displayMode) {
    config.displayMode = paramDecode(displayMode, uriDecode);
  }

  if (trackString) {
    trackString = paramDecode(trackString, uriDecode);
    config.tracks = destringifyTracksV0(trackString);

    // If an oAuth token is provided append it to track configs.
    if (config.tracks && config.oauthToken) {
      config.tracks.forEach(function (t) {
        t.oauthToken = config.oauthToken;
      });
    }
  }

  if (selectedGene) {
    Globals.selectedGene = selectedGene;
  }

  config.cycle = cycle;

  if (nvi) {
    config.nvi = paramDecode(nvi, uriDecode);
  }
  if (controlNvi) {
    config.controlNvi = paramDecode(controlNvi, uriDecode);
  }

  return config;

  function destringifyTracksV0(tracks) {

    const trackStringList = tracks.split("|||");
    const configList = [];
    for (let trackString of trackStringList) {

      const tokens = trackString.split("|");
      const color = tokens.pop();
      let url = tokens.length > 1 ? tokens[0] : trackString;
      if (url && url.trim().length > 0 && "undefined" !== url) {
        const keys = Object.keys(urlShortcuts);
        for (let key of keys) {
          var value = urlShortcuts[key];
          if (url.startsWith(key)) {
            url = url.replace(key, value);
            break;
          }
        }
        const trackConfig = { url: url };

        if (tokens.length > 1) {
          trackConfig.name = replaceAll(tokens[1], "$", "|");
        }

        if (tokens.length > 2) {
          const dataRangeString = tokens[2];
          if (dataRangeString.startsWith("-")) {
            const r = dataRangeString.substring(1).split("-");
            trackConfig.min = -parseFloat(r[0]);
            trackConfig.max = parseFloat(r[1]);
          } else {
            const r = dataRangeString.split("-");
            trackConfig.min = parseFloat(r[0]);
            trackConfig.max = parseFloat(r[1]);
          }
        }

        if (color) {
          trackConfig.color = color;
        }

        configList.push(trackConfig);
      }
    }
    return configList;
  }

}


function paramDecode(str, uriDecode) {

  if (uriDecode) {
    return decodeURIComponent(str);   // Still more backward compatibility
  } else {
    var s = replaceAll(str, '%26', '&');
    s = replaceAll(s, '%20', ' ');
    s = replaceAll(s, '+', ' ');
    s = replaceAll(s, "%7C", "|");
    s = replaceAll(s, "%23", "#");
    s = replaceAll(s, "%3F", "?");
    s = replaceAll(s, "%3D", "=");
    return s;
  }
}


function replaceAll(str, target, replacement) {
  return str.split(target).join(replacement);
}

function extractQuery(uri) {
  var i1, i2, i, j, s, query, tokens;

  query = {};
  i1 = uri.indexOf("?");
  i2 = uri.lastIndexOf("#");
  const i3 = uri.indexOf("=");
  if (i1 > i3) i1 = -1;

  if (i2 < 0) i2 = uri.length;
  for (i = i1 + 1; i < i2;) {

    j = uri.indexOf("&", i);
    if (j < 0) j = i2;

    s = uri.substring(i, j);
    tokens = s.split("=", 2);
    if (tokens.length === 2) {
      query[tokens[0]] = tokens[1];
    }

    i = j + 1;

  }
  return query;
}

/**
* Expand legacy bitly URLs
* @param url
* @returns {Promise<*>}
*/
async function expandURL(url) {

  const endpoint = `https://api-ssl.bitly.com/v4/expand`;
  const id = url.startsWith("http://") ? url.substring(7) : url.substring(8);
  const message = {
    "bitlink_id": id
  };

  const response = await fetch(endpoint, {
    method: 'POST', // or 'PUT'
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${btoa("ëtá¾´ãÎtsßéÆºÙçµóf¸í¿9snéÝz")}`
    },
    body: JSON.stringify(message),
  });

  if (!response.ok) {
    throw new Error(`Network error (${response.status}): ${response.statusText}`)
  }
  const json = await response.json();
  let longUrl = json.long_url;

  // Fix some Bitly "normalization"
  longUrl = longUrl.replace("{", "%7B").replace("}", "%7D");
  return longUrl;

}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

async function init(container, config) {

  Alert$1.init(container);

  if (false !== config.queryParametersSupported) {
    const queryConfig = await extractConfig(window.location.href);
    if (queryConfig) {
      config = queryConfig;
    }
  }

  await restoreSession(container, config);

  const allBrowsers = getAllBrowsers();

  return allBrowsers.length === 1 ? allBrowsers[0] : allBrowsers
}

/*
*  The MIT License (MIT)
*
* Copyright (c) 2016-2017 The Regents of the University of California
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*/

var index = {
  version,
  init,
  toJSON,
  restoreSession,
  compressedSession,
  createBrowser,
  getCurrentBrowser,
  setCurrentBrowser,
  getAllBrowsers,
  igvxhr,
  EventBus
};

export { index as default };
